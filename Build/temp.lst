
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000bb3 	.word	0x00000bb3
  10:	00000bb5 	.word	0x00000bb5
  14:	00000bb7 	.word	0x00000bb7
  18:	00000bb9 	.word	0x00000bb9
	...
  2c:	00000bbb 	.word	0x00000bbb
  30:	00000bbd 	.word	0x00000bbd
  34:	00000000 	.word	0x00000000
  38:	00000bbf 	.word	0x00000bbf
  3c:	00000bc1 	.word	0x00000bc1
  40:	00000bc3 	.word	0x00000bc3
  44:	00000bc3 	.word	0x00000bc3
  48:	00000bc3 	.word	0x00000bc3
  4c:	00000bc3 	.word	0x00000bc3
  50:	00000bc3 	.word	0x00000bc3
  54:	00000bc3 	.word	0x00000bc3
  58:	00000bc3 	.word	0x00000bc3
  5c:	00000bc3 	.word	0x00000bc3
  60:	00000bc3 	.word	0x00000bc3
  64:	00000bc3 	.word	0x00000bc3
  68:	00000bc3 	.word	0x00000bc3
  6c:	00000bc3 	.word	0x00000bc3
  70:	00000bc3 	.word	0x00000bc3
  74:	00000bc3 	.word	0x00000bc3
  78:	00000bc3 	.word	0x00000bc3
  7c:	00000bc3 	.word	0x00000bc3
  80:	00000bc3 	.word	0x00000bc3
  84:	00000bc3 	.word	0x00000bc3
  88:	00000bc3 	.word	0x00000bc3
  8c:	00000bc3 	.word	0x00000bc3
  90:	00000bc3 	.word	0x00000bc3
  94:	00000bc3 	.word	0x00000bc3
  98:	00000bc3 	.word	0x00000bc3
  9c:	00000bc3 	.word	0x00000bc3
  a0:	00000bc3 	.word	0x00000bc3
  a4:	00000bc3 	.word	0x00000bc3
  a8:	00000bc3 	.word	0x00000bc3
  ac:	00000bc3 	.word	0x00000bc3
  b0:	00000bc3 	.word	0x00000bc3
  b4:	00000bc3 	.word	0x00000bc3
  b8:	00000bc3 	.word	0x00000bc3
  bc:	00000bc3 	.word	0x00000bc3
  c0:	00000bc3 	.word	0x00000bc3
  c4:	00000bc3 	.word	0x00000bc3
  c8:	00000bc3 	.word	0x00000bc3
  cc:	00000bc3 	.word	0x00000bc3
  d0:	00000bc3 	.word	0x00000bc3
  d4:	00000bc3 	.word	0x00000bc3
  d8:	00000bc3 	.word	0x00000bc3
  dc:	00000bc3 	.word	0x00000bc3
  e0:	00000bc3 	.word	0x00000bc3
  e4:	00000bc3 	.word	0x00000bc3
  e8:	00000bc3 	.word	0x00000bc3
  ec:	00000bc3 	.word	0x00000bc3
  f0:	00000bc3 	.word	0x00000bc3
  f4:	00000bc3 	.word	0x00000bc3
  f8:	00000bc3 	.word	0x00000bc3
  fc:	00000bc3 	.word	0x00000bc3
 100:	00000bc3 	.word	0x00000bc3
 104:	00000bc3 	.word	0x00000bc3
 108:	00000bc3 	.word	0x00000bc3
 10c:	00000bc3 	.word	0x00000bc3
 110:	00000bc3 	.word	0x00000bc3
 114:	00000bc3 	.word	0x00000bc3
 118:	00000bc3 	.word	0x00000bc3
 11c:	00000bc3 	.word	0x00000bc3
 120:	00000bc3 	.word	0x00000bc3
 124:	00000bc3 	.word	0x00000bc3
 128:	00000bc3 	.word	0x00000bc3
 12c:	00000bc3 	.word	0x00000bc3
 130:	00000bc3 	.word	0x00000bc3
 134:	00000bc3 	.word	0x00000bc3
 138:	00000bc3 	.word	0x00000bc3
 13c:	00000bc3 	.word	0x00000bc3
 140:	00000bc3 	.word	0x00000bc3
 144:	00000bc3 	.word	0x00000bc3
 148:	00000bc3 	.word	0x00000bc3
 14c:	00000bc3 	.word	0x00000bc3
 150:	00000bc3 	.word	0x00000bc3
 154:	00000bc3 	.word	0x00000bc3
 158:	00000bc3 	.word	0x00000bc3
 15c:	00000bc3 	.word	0x00000bc3
 160:	00000bc3 	.word	0x00000bc3
 164:	00000bc3 	.word	0x00000bc3
 168:	00000bc3 	.word	0x00000bc3
 16c:	00000bc3 	.word	0x00000bc3
 170:	00000bc3 	.word	0x00000bc3
 174:	00000bc3 	.word	0x00000bc3
 178:	00000bc3 	.word	0x00000bc3
 17c:	00000bc3 	.word	0x00000bc3
 180:	00000bc3 	.word	0x00000bc3
 184:	00000bc3 	.word	0x00000bc3
 188:	00000bc3 	.word	0x00000bc3
 18c:	00000bc3 	.word	0x00000bc3
 190:	00000bc3 	.word	0x00000bc3
 194:	00000bc3 	.word	0x00000bc3
 198:	00000bc3 	.word	0x00000bc3
 19c:	00000bc3 	.word	0x00000bc3
 1a0:	00000bc3 	.word	0x00000bc3
 1a4:	00000bc3 	.word	0x00000bc3
 1a8:	00000bc3 	.word	0x00000bc3
 1ac:	00000bc3 	.word	0x00000bc3
 1b0:	00000bc3 	.word	0x00000bc3
 1b4:	00000bc3 	.word	0x00000bc3
 1b8:	00000bc3 	.word	0x00000bc3
 1bc:	00000bc3 	.word	0x00000bc3
 1c0:	00000bc3 	.word	0x00000bc3
 1c4:	00000bc3 	.word	0x00000bc3
 1c8:	00000bc3 	.word	0x00000bc3
 1cc:	00000bc3 	.word	0x00000bc3
 1d0:	00000bc3 	.word	0x00000bc3
 1d4:	00000bc3 	.word	0x00000bc3
 1d8:	00000bc3 	.word	0x00000bc3
 1dc:	00000bc3 	.word	0x00000bc3
 1e0:	00000bc3 	.word	0x00000bc3
 1e4:	00000bc3 	.word	0x00000bc3
 1e8:	00000bc3 	.word	0x00000bc3
 1ec:	00000bc3 	.word	0x00000bc3
 1f0:	00000bc3 	.word	0x00000bc3
 1f4:	00000bc3 	.word	0x00000bc3
 1f8:	00000bc3 	.word	0x00000bc3
 1fc:	00000bc3 	.word	0x00000bc3
 200:	00000bc3 	.word	0x00000bc3
 204:	00000bc3 	.word	0x00000bc3
 208:	00000bc3 	.word	0x00000bc3
 20c:	00000bc3 	.word	0x00000bc3
 210:	00000bc3 	.word	0x00000bc3
 214:	00000bc3 	.word	0x00000bc3
 218:	00000bc3 	.word	0x00000bc3
 21c:	00000bc3 	.word	0x00000bc3
 220:	00000bc3 	.word	0x00000bc3
 224:	00000bc3 	.word	0x00000bc3
 228:	00000bc3 	.word	0x00000bc3
 22c:	00000bc3 	.word	0x00000bc3
 230:	00000bc3 	.word	0x00000bc3
 234:	00000bc3 	.word	0x00000bc3
 238:	00000bc3 	.word	0x00000bc3
 23c:	00000bc3 	.word	0x00000bc3
 240:	00000bc3 	.word	0x00000bc3
 244:	00000bc3 	.word	0x00000bc3
 248:	00000bc3 	.word	0x00000bc3
 24c:	00000bc3 	.word	0x00000bc3
 250:	00000bc3 	.word	0x00000bc3
 254:	00000bc3 	.word	0x00000bc3
 258:	00000bc3 	.word	0x00000bc3
 25c:	00000bc3 	.word	0x00000bc3
 260:	00000bc3 	.word	0x00000bc3
 264:	00000bc3 	.word	0x00000bc3
 268:	00000bc3 	.word	0x00000bc3
 26c:	00000bc3 	.word	0x00000bc3
 270:	00000bc3 	.word	0x00000bc3
 274:	00000bc3 	.word	0x00000bc3
 278:	00000bc3 	.word	0x00000bc3
 27c:	00000bc3 	.word	0x00000bc3
 280:	00000bc3 	.word	0x00000bc3
 284:	00000bc3 	.word	0x00000bc3
 288:	00000bc3 	.word	0x00000bc3
 28c:	00000bc3 	.word	0x00000bc3
 290:	00000bc3 	.word	0x00000bc3
 294:	00000bc3 	.word	0x00000bc3
 298:	00000bc3 	.word	0x00000bc3
 29c:	00000bc3 	.word	0x00000bc3
 2a0:	00000bc3 	.word	0x00000bc3
 2a4:	00000bc3 	.word	0x00000bc3
 2a8:	00000bc3 	.word	0x00000bc3
 2ac:	00000bc3 	.word	0x00000bc3
 2b0:	00000bc3 	.word	0x00000bc3
 2b4:	00000bc3 	.word	0x00000bc3
 2b8:	00000bc3 	.word	0x00000bc3
 2bc:	00000bc3 	.word	0x00000bc3
 2c0:	00000bc3 	.word	0x00000bc3
 2c4:	00000bc3 	.word	0x00000bc3
 2c8:	00000bc3 	.word	0x00000bc3
 2cc:	00000bc3 	.word	0x00000bc3
 2d0:	00000bc3 	.word	0x00000bc3
 2d4:	00000bc3 	.word	0x00000bc3
 2d8:	00000bc3 	.word	0x00000bc3
 2dc:	00000bc3 	.word	0x00000bc3
 2e0:	00000bc3 	.word	0x00000bc3
 2e4:	00000bc3 	.word	0x00000bc3
 2e8:	00000bc3 	.word	0x00000bc3
 2ec:	00000bc3 	.word	0x00000bc3
 2f0:	00000bc3 	.word	0x00000bc3
 2f4:	00000bc3 	.word	0x00000bc3
 2f8:	00000bc3 	.word	0x00000bc3
 2fc:	00000bc3 	.word	0x00000bc3
 300:	00000bc3 	.word	0x00000bc3
 304:	00000bc3 	.word	0x00000bc3
 308:	00000bc3 	.word	0x00000bc3
 30c:	00000bc3 	.word	0x00000bc3

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 facd 	bl	a20 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fb8c 	bl	ba8 <startup_go_to_user_mode>
     490:	f000 fa0e 	bl	8b0 <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff9094 	.word	0x1fff9094

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fad7 	bl	b4c <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <main>:
#include "Port.h"
#include "Dio.h"
#include "Gpt.h"
void EcuM_Init( void );
int main( void )
{
     8b0:	b508      	push	{r3, lr}
    EcuM_Init();
     8b2:	f000 f817 	bl	8e4 <EcuM_Init>
    /*Start the timer and set it to Running state*/
    Gpt_StartTimer( GptConf_GptChannelConfiguration_GptChannelConfiguration_0, 37500u );
     8b6:	f249 217c 	movw	r1, #37500	; 0x927c
     8ba:	2000      	movs	r0, #0
     8bc:	f005 fc70 	bl	61a0 <Gpt_StartTimer>
    while( 1u )
    {
        if( Gpt_GetTimeRemaining( GptConf_GptChannelConfiguration_GptChannelConfiguration_0 ) == 0u )
     8c0:	2000      	movs	r0, #0
     8c2:	f005 fbf1 	bl	60a8 <Gpt_GetTimeRemaining>
     8c6:	4603      	mov	r3, r0
     8c8:	2b00      	cmp	r3, #0
     8ca:	d1f9      	bne.n	8c0 <main+0x10>
        {
            /*if we are not using notifications it is neceseary to change the channel status from running
            manually, we can use the Stop function for that purpose, otherwise the Start function will 
            never reload the timer with a new count again */
            Gpt_StopTimer( GptConf_GptChannelConfiguration_GptChannelConfiguration_0 );
     8cc:	2000      	movs	r0, #0
     8ce:	f005 fcd5 	bl	627c <Gpt_StopTimer>
            Dio_FlipChannel( DioConf_DioChannel_DioChannel_0 );
     8d2:	2060      	movs	r0, #96	; 0x60
     8d4:	f005 f9d1 	bl	5c7a <Dio_FlipChannel>
            /*start the timer again*/
            Gpt_StartTimer( GptConf_GptChannelConfiguration_GptChannelConfiguration_0, 37500u );
     8d8:	f249 217c 	movw	r1, #37500	; 0x927c
     8dc:	2000      	movs	r0, #0
     8de:	f005 fc5f 	bl	61a0 <Gpt_StartTimer>
        if( Gpt_GetTimeRemaining( GptConf_GptChannelConfiguration_GptChannelConfiguration_0 ) == 0u )
     8e2:	e7ed      	b.n	8c0 <main+0x10>

000008e4 <EcuM_Init>:
        }
    }
    return 0u;
}
void EcuM_Init( void )
{
     8e4:	b508      	push	{r3, lr}
    Mcu_Init( &Mcu_Config );
     8e6:	4808      	ldr	r0, [pc, #32]	; (908 <EcuM_Init+0x24>)
     8e8:	f002 fefa 	bl	36e0 <Mcu_Init>
    /* Initialize the clock tree with no PLL active*/
    Mcu_InitClock( McuClockSettingConfig_0 );
     8ec:	2000      	movs	r0, #0
     8ee:	f002 ff4b 	bl	3788 <Mcu_InitClock>
    Mcu_SetMode( McuModeSettingConf_0 );
     8f2:	2000      	movs	r0, #0
     8f4:	f002 ff6c 	bl	37d0 <Mcu_SetMode>
    /*Apply all the Pin Port microcontroller configuration, for this case
    only Port Pin 96  (D0) is configured as output*/
    Port_Init( &Port_Config );
     8f8:	4804      	ldr	r0, [pc, #16]	; (90c <EcuM_Init+0x28>)
     8fa:	f004 fd87 	bl	540c <Port_Init>
    /*Apply Gpt configuration for FTM0 channel 0*/
    Gpt_Init( &Gpt_Config );
     8fe:	4804      	ldr	r0, [pc, #16]	; (910 <EcuM_Init+0x2c>)
     900:	f005 fa62 	bl	5dc8 <Gpt_Init>
     904:	bf00      	nop
     906:	bd08      	pop	{r3, pc}
     908:	0000b1dc 	.word	0x0000b1dc
     90c:	0000b2f0 	.word	0x0000b2f0
     910:	0000b1c8 	.word	0x0000b1c8

00000914 <Gpt_Ipw_FtmGetTimeElapsed>:
#define GPT_START_SEC_CODE
#include "Gpt_MemMap.h"

#if (FTM_GPT_IP_USED == STD_ON)
static Gpt_ValueType Gpt_Ipw_FtmGetTimeElapsed(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig, Gpt_HwChannelInfoType * pReturnHwChannelInfo)
{
     914:	b500      	push	{lr}
     916:	b087      	sub	sp, #28
     918:	9001      	str	r0, [sp, #4]
     91a:	9100      	str	r1, [sp, #0]
    Gpt_ValueType returnValue;
    boolean HasChEvOccurred;

    /* Read compare and counter registers */
    uint32 counterValue = Ftm_Gpt_Ip_GetCntValue(pHwChannelConfig->instance);
     91c:	9b01      	ldr	r3, [sp, #4]
     91e:	791b      	ldrb	r3, [r3, #4]
     920:	4618      	mov	r0, r3
     922:	f006 f99b 	bl	6c5c <Ftm_Gpt_Ip_GetCntValue>
     926:	9004      	str	r0, [sp, #16]
    uint32 compareValue = Ftm_Gpt_Ip_GetCompareValue(pHwChannelConfig->instance, pHwChannelConfig->channel);
     928:	9b01      	ldr	r3, [sp, #4]
     92a:	791a      	ldrb	r2, [r3, #4]
     92c:	9b01      	ldr	r3, [sp, #4]
     92e:	795b      	ldrb	r3, [r3, #5]
     930:	4619      	mov	r1, r3
     932:	4610      	mov	r0, r2
     934:	f006 f9a2 	bl	6c7c <Ftm_Gpt_Ip_GetCompareValue>
     938:	9003      	str	r0, [sp, #12]

    pReturnHwChannelInfo->uTargetTime = Ftm_Gpt_Ip_u32TargetValue[pHwChannelConfig->instance][pHwChannelConfig->channel];
     93a:	9b01      	ldr	r3, [sp, #4]
     93c:	791b      	ldrb	r3, [r3, #4]
     93e:	4618      	mov	r0, r3
     940:	9b01      	ldr	r3, [sp, #4]
     942:	795b      	ldrb	r3, [r3, #5]
     944:	4619      	mov	r1, r3
     946:	4a23      	ldr	r2, [pc, #140]	; (9d4 <Gpt_Ipw_FtmGetTimeElapsed+0xc0>)
     948:	00c3      	lsls	r3, r0, #3
     94a:	440b      	add	r3, r1
     94c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
     950:	9b00      	ldr	r3, [sp, #0]
     952:	605a      	str	r2, [r3, #4]

    /* Calculate the elapsed time */
    if (counterValue > compareValue)
     954:	9a04      	ldr	r2, [sp, #16]
     956:	9b03      	ldr	r3, [sp, #12]
     958:	429a      	cmp	r2, r3
     95a:	d918      	bls.n	98e <Gpt_Ipw_FtmGetTimeElapsed+0x7a>
    {
        /* Counter value passed the set-up Target value - might have roll-over */
        if(((FTM_CNT_MAX_VALUE_U32 - counterValue) + compareValue) <= pReturnHwChannelInfo->uTargetTime)
     95c:	9a03      	ldr	r2, [sp, #12]
     95e:	9b04      	ldr	r3, [sp, #16]
     960:	1ad3      	subs	r3, r2, r3
     962:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
     966:	33ff      	adds	r3, #255	; 0xff
     968:	9a00      	ldr	r2, [sp, #0]
     96a:	6852      	ldr	r2, [r2, #4]
     96c:	4293      	cmp	r3, r2
     96e:	d80a      	bhi.n	986 <Gpt_Ipw_FtmGetTimeElapsed+0x72>
        {
            /* New compare value was read by register read - isr served in time - we have roll-over */
            returnValue =   (Gpt_ValueType)(    (   pReturnHwChannelInfo->uTargetTime - \
     970:	9b00      	ldr	r3, [sp, #0]
     972:	685a      	ldr	r2, [r3, #4]
                                                    ((FTM_CNT_MAX_VALUE_U32 - counterValue) + compareValue) ) + \
     974:	9904      	ldr	r1, [sp, #16]
     976:	9b03      	ldr	r3, [sp, #12]
     978:	1acb      	subs	r3, r1, r3
            returnValue =   (Gpt_ValueType)(    (   pReturnHwChannelInfo->uTargetTime - \
     97a:	4413      	add	r3, r2
     97c:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
     980:	3bfe      	subs	r3, #254	; 0xfe
     982:	9305      	str	r3, [sp, #20]
     984:	e00a      	b.n	99c <Gpt_Ipw_FtmGetTimeElapsed+0x88>
                                                FTM_OVERFLOW_PAD_U32 );
        }
        else
        {
            /* There is an delay in serving ISR or updating u32CompareValue - report last timer time */
            returnValue = (Gpt_ValueType)(pReturnHwChannelInfo->uTargetTime);
     986:	9b00      	ldr	r3, [sp, #0]
     988:	685b      	ldr	r3, [r3, #4]
     98a:	9305      	str	r3, [sp, #20]
     98c:	e006      	b.n	99c <Gpt_Ipw_FtmGetTimeElapsed+0x88>
        }
    }
    else
    {
        /* Timer in between ISRs period */
        returnValue = (Gpt_ValueType)(pReturnHwChannelInfo->uTargetTime - (compareValue - counterValue));
     98e:	9b00      	ldr	r3, [sp, #0]
     990:	685a      	ldr	r2, [r3, #4]
     992:	9904      	ldr	r1, [sp, #16]
     994:	9b03      	ldr	r3, [sp, #12]
     996:	1acb      	subs	r3, r1, r3
     998:	4413      	add	r3, r2
     99a:	9305      	str	r3, [sp, #20]
    }

    /* check if channel event has occurred */
    HasChEvOccurred = Ftm_Gpt_Ip_GetChInterruptStatusFlag(pHwChannelConfig->instance, pHwChannelConfig->channel);
     99c:	9b01      	ldr	r3, [sp, #4]
     99e:	791a      	ldrb	r2, [r3, #4]
     9a0:	9b01      	ldr	r3, [sp, #4]
     9a2:	795b      	ldrb	r3, [r3, #5]
     9a4:	4619      	mov	r1, r3
     9a6:	4610      	mov	r0, r2
     9a8:	f006 f938 	bl	6c1c <Ftm_Gpt_Ip_GetChInterruptStatusFlag>
     9ac:	4603      	mov	r3, r0
     9ae:	f88d 300b 	strb.w	r3, [sp, #11]

    /*Check interrupt status flag*/
    if (HasChEvOccurred)
     9b2:	f89d 300b 	ldrb.w	r3, [sp, #11]
     9b6:	2b00      	cmp	r3, #0
     9b8:	d003      	beq.n	9c2 <Gpt_Ipw_FtmGetTimeElapsed+0xae>
    {
        /* Channel counter was roll-over */
        pReturnHwChannelInfo->bChannelRollover = TRUE;
     9ba:	9b00      	ldr	r3, [sp, #0]
     9bc:	2201      	movs	r2, #1
     9be:	701a      	strb	r2, [r3, #0]
     9c0:	e002      	b.n	9c8 <Gpt_Ipw_FtmGetTimeElapsed+0xb4>
    }
    else
    {
        /* Channel counter was not rollover */
        pReturnHwChannelInfo->bChannelRollover = FALSE;
     9c2:	9b00      	ldr	r3, [sp, #0]
     9c4:	2200      	movs	r2, #0
     9c6:	701a      	strb	r2, [r3, #0]
    }
    return returnValue;
     9c8:	9b05      	ldr	r3, [sp, #20]
}
     9ca:	4618      	mov	r0, r3
     9cc:	b007      	add	sp, #28
     9ce:	f85d fb04 	ldr.w	pc, [sp], #4
     9d2:	bf00      	nop
     9d4:	1fff8d2c 	.word	0x1fff8d2c

000009d8 <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     9d8:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9da:	f3ef 8310 	mrs	r3, PRIMASK
     9de:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9e0:	4623      	mov	r3, r4
}
     9e2:	4618      	mov	r0, r3
     9e4:	f85d 4b04 	ldr.w	r4, [sp], #4
     9e8:	4770      	bx	lr

000009ea <Gpt_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Gpt_schm_read_msr(void)
{
     9ea:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9ec:	f3ef 8310 	mrs	r3, PRIMASK
     9f0:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9f2:	4623      	mov	r3, r4
}
     9f4:	4618      	mov	r0, r3
     9f6:	f85d 4b04 	ldr.w	r4, [sp], #4
     9fa:	4770      	bx	lr

000009fc <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     9fc:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9fe:	f3ef 8310 	mrs	r3, PRIMASK
     a02:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     a04:	4623      	mov	r3, r4
}
     a06:	4618      	mov	r0, r3
     a08:	f85d 4b04 	ldr.w	r4, [sp], #4
     a0c:	4770      	bx	lr

00000a0e <Dio_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Dio_schm_read_msr(void)
{
     a0e:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     a10:	f3ef 8310 	mrs	r3, PRIMASK
     a14:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     a16:	4623      	mov	r3, r4
}
     a18:	4618      	mov	r0, r3
     a1a:	f85d 4b04 	ldr.w	r4, [sp], #4
     a1e:	4770      	bx	lr

00000a20 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     a20:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     a22:	2300      	movs	r3, #0
     a24:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     a26:	2300      	movs	r3, #0
     a28:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     a2a:	2300      	movs	r3, #0
     a2c:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     a2e:	2300      	movs	r3, #0
     a30:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     a32:	4b44      	ldr	r3, [pc, #272]	; (b44 <init_data_bss+0x124>)
     a34:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     a36:	4b44      	ldr	r3, [pc, #272]	; (b48 <init_data_bss+0x128>)
     a38:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     a3a:	9b05      	ldr	r3, [sp, #20]
     a3c:	681b      	ldr	r3, [r3, #0]
     a3e:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     a40:	9b05      	ldr	r3, [sp, #20]
     a42:	3304      	adds	r3, #4
     a44:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     a46:	9b05      	ldr	r3, [sp, #20]
     a48:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     a4a:	2300      	movs	r3, #0
     a4c:	9309      	str	r3, [sp, #36]	; 0x24
     a4e:	e03d      	b.n	acc <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     a50:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a52:	4613      	mov	r3, r2
     a54:	005b      	lsls	r3, r3, #1
     a56:	4413      	add	r3, r2
     a58:	009b      	lsls	r3, r3, #2
     a5a:	461a      	mov	r2, r3
     a5c:	9b03      	ldr	r3, [sp, #12]
     a5e:	4413      	add	r3, r2
     a60:	685b      	ldr	r3, [r3, #4]
     a62:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     a64:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a66:	4613      	mov	r3, r2
     a68:	005b      	lsls	r3, r3, #1
     a6a:	4413      	add	r3, r2
     a6c:	009b      	lsls	r3, r3, #2
     a6e:	461a      	mov	r2, r3
     a70:	9b03      	ldr	r3, [sp, #12]
     a72:	4413      	add	r3, r2
     a74:	681b      	ldr	r3, [r3, #0]
     a76:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     a78:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a7a:	4613      	mov	r3, r2
     a7c:	005b      	lsls	r3, r3, #1
     a7e:	4413      	add	r3, r2
     a80:	009b      	lsls	r3, r3, #2
     a82:	461a      	mov	r2, r3
     a84:	9b03      	ldr	r3, [sp, #12]
     a86:	4413      	add	r3, r2
     a88:	689b      	ldr	r3, [r3, #8]
     a8a:	4619      	mov	r1, r3
     a8c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a8e:	4613      	mov	r3, r2
     a90:	005b      	lsls	r3, r3, #1
     a92:	4413      	add	r3, r2
     a94:	009b      	lsls	r3, r3, #2
     a96:	461a      	mov	r2, r3
     a98:	9b03      	ldr	r3, [sp, #12]
     a9a:	4413      	add	r3, r2
     a9c:	685b      	ldr	r3, [r3, #4]
     a9e:	1acb      	subs	r3, r1, r3
     aa0:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     aa2:	2300      	movs	r3, #0
     aa4:	9308      	str	r3, [sp, #32]
     aa6:	e00a      	b.n	abe <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     aa8:	9a00      	ldr	r2, [sp, #0]
     aaa:	9b08      	ldr	r3, [sp, #32]
     aac:	441a      	add	r2, r3
     aae:	9901      	ldr	r1, [sp, #4]
     ab0:	9b08      	ldr	r3, [sp, #32]
     ab2:	440b      	add	r3, r1
     ab4:	7812      	ldrb	r2, [r2, #0]
     ab6:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     ab8:	9b08      	ldr	r3, [sp, #32]
     aba:	3301      	adds	r3, #1
     abc:	9308      	str	r3, [sp, #32]
     abe:	9a08      	ldr	r2, [sp, #32]
     ac0:	9b06      	ldr	r3, [sp, #24]
     ac2:	429a      	cmp	r2, r3
     ac4:	d3f0      	bcc.n	aa8 <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     ac6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ac8:	3301      	adds	r3, #1
     aca:	9309      	str	r3, [sp, #36]	; 0x24
     acc:	9a09      	ldr	r2, [sp, #36]	; 0x24
     ace:	9b07      	ldr	r3, [sp, #28]
     ad0:	429a      	cmp	r2, r3
     ad2:	d3bd      	bcc.n	a50 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     ad4:	9b04      	ldr	r3, [sp, #16]
     ad6:	681b      	ldr	r3, [r3, #0]
     ad8:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     ada:	9b04      	ldr	r3, [sp, #16]
     adc:	3304      	adds	r3, #4
     ade:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     ae0:	9b04      	ldr	r3, [sp, #16]
     ae2:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     ae4:	2300      	movs	r3, #0
     ae6:	9309      	str	r3, [sp, #36]	; 0x24
     ae8:	e024      	b.n	b34 <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     aea:	9b09      	ldr	r3, [sp, #36]	; 0x24
     aec:	00db      	lsls	r3, r3, #3
     aee:	9a02      	ldr	r2, [sp, #8]
     af0:	4413      	add	r3, r2
     af2:	681b      	ldr	r3, [r3, #0]
     af4:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     af6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     af8:	00db      	lsls	r3, r3, #3
     afa:	9a02      	ldr	r2, [sp, #8]
     afc:	4413      	add	r3, r2
     afe:	685b      	ldr	r3, [r3, #4]
     b00:	4619      	mov	r1, r3
     b02:	9b09      	ldr	r3, [sp, #36]	; 0x24
     b04:	00db      	lsls	r3, r3, #3
     b06:	9a02      	ldr	r2, [sp, #8]
     b08:	4413      	add	r3, r2
     b0a:	681b      	ldr	r3, [r3, #0]
     b0c:	1acb      	subs	r3, r1, r3
     b0e:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     b10:	2300      	movs	r3, #0
     b12:	9308      	str	r3, [sp, #32]
     b14:	e007      	b.n	b26 <init_data_bss+0x106>
        {
            ram[j] = 0U;
     b16:	9a01      	ldr	r2, [sp, #4]
     b18:	9b08      	ldr	r3, [sp, #32]
     b1a:	4413      	add	r3, r2
     b1c:	2200      	movs	r2, #0
     b1e:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     b20:	9b08      	ldr	r3, [sp, #32]
     b22:	3301      	adds	r3, #1
     b24:	9308      	str	r3, [sp, #32]
     b26:	9a08      	ldr	r2, [sp, #32]
     b28:	9b06      	ldr	r3, [sp, #24]
     b2a:	429a      	cmp	r2, r3
     b2c:	d3f3      	bcc.n	b16 <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     b2e:	9b09      	ldr	r3, [sp, #36]	; 0x24
     b30:	3301      	adds	r3, #1
     b32:	9309      	str	r3, [sp, #36]	; 0x24
     b34:	9a09      	ldr	r2, [sp, #36]	; 0x24
     b36:	9b07      	ldr	r3, [sp, #28]
     b38:	429a      	cmp	r2, r3
     b3a:	d3d6      	bcc.n	aea <init_data_bss+0xca>
        }
    }
}
     b3c:	bf00      	nop
     b3e:	bf00      	nop
     b40:	b00a      	add	sp, #40	; 0x28
     b42:	4770      	bx	lr
     b44:	0000b368 	.word	0x0000b368
     b48:	0000b384 	.word	0x0000b384

00000b4c <sys_m4_cache_init>:
{
     b4c:	b084      	sub	sp, #16
     b4e:	4603      	mov	r3, r0
     b50:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     b54:	2300      	movs	r3, #0
     b56:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     b5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
     b5e:	2b00      	cmp	r3, #0
     b60:	d118      	bne.n	b94 <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     b62:	4b10      	ldr	r3, [pc, #64]	; (ba4 <sys_m4_cache_init+0x58>)
     b64:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     b68:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     b6a:	4b0e      	ldr	r3, [pc, #56]	; (ba4 <sys_m4_cache_init+0x58>)
     b6c:	681b      	ldr	r3, [r3, #0]
     b6e:	4a0d      	ldr	r2, [pc, #52]	; (ba4 <sys_m4_cache_init+0x58>)
     b70:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     b74:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     b76:	bf00      	nop
     b78:	4b0a      	ldr	r3, [pc, #40]	; (ba4 <sys_m4_cache_init+0x58>)
     b7a:	681b      	ldr	r3, [r3, #0]
     b7c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     b80:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     b84:	d0f8      	beq.n	b78 <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     b86:	4b07      	ldr	r3, [pc, #28]	; (ba4 <sys_m4_cache_init+0x58>)
     b88:	681b      	ldr	r3, [r3, #0]
     b8a:	4a06      	ldr	r2, [pc, #24]	; (ba4 <sys_m4_cache_init+0x58>)
     b8c:	f043 0301 	orr.w	r3, r3, #1
     b90:	6013      	str	r3, [r2, #0]
     b92:	e002      	b.n	b9a <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     b94:	2301      	movs	r3, #1
     b96:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     b9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     b9e:	4618      	mov	r0, r3
     ba0:	b004      	add	sp, #16
     ba2:	4770      	bx	lr
     ba4:	e0082000 	.word	0xe0082000

00000ba8 <startup_go_to_user_mode>:
}
     ba8:	bf00      	nop
     baa:	4770      	bx	lr

00000bac <Sys_GetCoreID>:
    return 0U;
     bac:	2300      	movs	r3, #0
}
     bae:	4618      	mov	r0, r3
     bb0:	4770      	bx	lr

00000bb2 <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     bb2:	e7fe      	b.n	bb2 <HardFault_Handler>

00000bb4 <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     bb4:	e7fe      	b.n	bb4 <MemManage_Handler>

00000bb6 <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     bb6:	e7fe      	b.n	bb6 <BusFault_Handler>

00000bb8 <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     bb8:	e7fe      	b.n	bb8 <UsageFault_Handler>

00000bba <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     bba:	e7fe      	b.n	bba <SVC_Handler>

00000bbc <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     bbc:	e7fe      	b.n	bbc <DebugMon_Handler>

00000bbe <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     bbe:	e7fe      	b.n	bbe <PendSV_Handler>

00000bc0 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     bc0:	e7fe      	b.n	bc0 <SysTick_Handler>

00000bc2 <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     bc2:	e7fe      	b.n	bc2 <undefined_handler>

00000bc4 <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
     bc4:	b500      	push	{lr}
     bc6:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
     bc8:	2300      	movs	r3, #0
     bca:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
     bcc:	4a09      	ldr	r2, [pc, #36]	; (bf4 <OsIf_Timer_System_Init+0x30>)
     bce:	9b01      	ldr	r3, [sp, #4]
     bd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     bd4:	685a      	ldr	r2, [r3, #4]
     bd6:	4908      	ldr	r1, [pc, #32]	; (bf8 <OsIf_Timer_System_Init+0x34>)
     bd8:	9b01      	ldr	r3, [sp, #4]
     bda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
     bde:	4a06      	ldr	r2, [pc, #24]	; (bf8 <OsIf_Timer_System_Init+0x34>)
     be0:	9b01      	ldr	r3, [sp, #4]
     be2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
     be6:	4618      	mov	r0, r3
     be8:	f000 f868 	bl	cbc <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
     bec:	bf00      	nop
     bee:	b003      	add	sp, #12
     bf0:	f85d fb04 	ldr.w	pc, [sp], #4
     bf4:	0000b33c 	.word	0x0000b33c
     bf8:	1fff8b60 	.word	0x1fff8b60

00000bfc <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
     bfc:	b500      	push	{lr}
     bfe:	b083      	sub	sp, #12
    uint32 Counter = 0U;
     c00:	2300      	movs	r3, #0
     c02:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
     c04:	2300      	movs	r3, #0
     c06:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
     c08:	f000 f86c 	bl	ce4 <OsIf_Timer_System_Internal_GetCounter>
     c0c:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
     c0e:	9b01      	ldr	r3, [sp, #4]
}
     c10:	4618      	mov	r0, r3
     c12:	b003      	add	sp, #12
     c14:	f85d fb04 	ldr.w	pc, [sp], #4

00000c18 <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
     c18:	b500      	push	{lr}
     c1a:	b085      	sub	sp, #20
     c1c:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
     c1e:	2300      	movs	r3, #0
     c20:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
     c22:	2300      	movs	r3, #0
     c24:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
     c26:	9801      	ldr	r0, [sp, #4]
     c28:	f000 f864 	bl	cf4 <OsIf_Timer_System_Internal_GetElapsed>
     c2c:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
     c2e:	9b03      	ldr	r3, [sp, #12]
}
     c30:	4618      	mov	r0, r3
     c32:	b005      	add	sp, #20
     c34:	f85d fb04 	ldr.w	pc, [sp], #4

00000c38 <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
     c38:	b084      	sub	sp, #16
     c3a:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
     c3c:	2300      	movs	r3, #0
     c3e:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
     c40:	4903      	ldr	r1, [pc, #12]	; (c50 <OsIf_Timer_System_SetTimerFrequency+0x18>)
     c42:	9b03      	ldr	r3, [sp, #12]
     c44:	9a01      	ldr	r2, [sp, #4]
     c46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
     c4a:	bf00      	nop
     c4c:	b004      	add	sp, #16
     c4e:	4770      	bx	lr
     c50:	1fff8b60 	.word	0x1fff8b60

00000c54 <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
     c54:	b5f0      	push	{r4, r5, r6, r7, lr}
     c56:	b087      	sub	sp, #28
     c58:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
     c5a:	2100      	movs	r1, #0
     c5c:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
     c5e:	2100      	movs	r1, #0
     c60:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
     c62:	9901      	ldr	r1, [sp, #4]
     c64:	2000      	movs	r0, #0
     c66:	460e      	mov	r6, r1
     c68:	4607      	mov	r7, r0
     c6a:	4812      	ldr	r0, [pc, #72]	; (cb4 <OsIf_Timer_System_MicrosToTicks+0x60>)
     c6c:	9904      	ldr	r1, [sp, #16]
     c6e:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
     c72:	2000      	movs	r0, #0
     c74:	460c      	mov	r4, r1
     c76:	4605      	mov	r5, r0
     c78:	fb04 f007 	mul.w	r0, r4, r7
     c7c:	fb06 f105 	mul.w	r1, r6, r5
     c80:	4401      	add	r1, r0
     c82:	fba6 2304 	umull	r2, r3, r6, r4
     c86:	4419      	add	r1, r3
     c88:	460b      	mov	r3, r1
     c8a:	e9cd 2302 	strd	r2, r3, [sp, #8]
     c8e:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
     c92:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
     c96:	4a08      	ldr	r2, [pc, #32]	; (cb8 <OsIf_Timer_System_MicrosToTicks+0x64>)
     c98:	f04f 0300 	mov.w	r3, #0
     c9c:	f7ff fc82 	bl	5a4 <__aeabi_uldivmod>
     ca0:	4602      	mov	r2, r0
     ca2:	460b      	mov	r3, r1
     ca4:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
     ca8:	9b02      	ldr	r3, [sp, #8]
     caa:	9305      	str	r3, [sp, #20]
    }

    return ticks;
     cac:	9b05      	ldr	r3, [sp, #20]
}
     cae:	4618      	mov	r0, r3
     cb0:	b007      	add	sp, #28
     cb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
     cb4:	1fff8b60 	.word	0x1fff8b60
     cb8:	000f4240 	.word	0x000f4240

00000cbc <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
     cbc:	b082      	sub	sp, #8
     cbe:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
     cc0:	4b07      	ldr	r3, [pc, #28]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cc2:	2200      	movs	r2, #0
     cc4:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
     cc6:	4b06      	ldr	r3, [pc, #24]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cc8:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
     ccc:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
     cce:	4b04      	ldr	r3, [pc, #16]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cd0:	2200      	movs	r2, #0
     cd2:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
     cd4:	4b02      	ldr	r3, [pc, #8]	; (ce0 <OsIf_Timer_System_Internal_Init+0x24>)
     cd6:	2205      	movs	r2, #5
     cd8:	601a      	str	r2, [r3, #0]
}
     cda:	bf00      	nop
     cdc:	b002      	add	sp, #8
     cde:	4770      	bx	lr
     ce0:	e000e010 	.word	0xe000e010

00000ce4 <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
     ce4:	4b02      	ldr	r3, [pc, #8]	; (cf0 <OsIf_Timer_System_Internal_GetCounter+0xc>)
     ce6:	689b      	ldr	r3, [r3, #8]
     ce8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
     cec:	4618      	mov	r0, r3
     cee:	4770      	bx	lr
     cf0:	e000e010 	.word	0xe000e010

00000cf4 <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
     cf4:	b084      	sub	sp, #16
     cf6:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
     cf8:	4b10      	ldr	r3, [pc, #64]	; (d3c <OsIf_Timer_System_Internal_GetElapsed+0x48>)
     cfa:	689b      	ldr	r3, [r3, #8]
     cfc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
     d00:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
     d02:	2300      	movs	r3, #0
     d04:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
     d06:	9b01      	ldr	r3, [sp, #4]
     d08:	681b      	ldr	r3, [r3, #0]
     d0a:	9a02      	ldr	r2, [sp, #8]
     d0c:	429a      	cmp	r2, r3
     d0e:	d909      	bls.n	d24 <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
     d10:	9b01      	ldr	r3, [sp, #4]
     d12:	681a      	ldr	r2, [r3, #0]
     d14:	9b02      	ldr	r3, [sp, #8]
     d16:	1ad3      	subs	r3, r2, r3
     d18:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
     d1c:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
     d20:	9303      	str	r3, [sp, #12]
     d22:	e004      	b.n	d2e <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
     d24:	9b01      	ldr	r3, [sp, #4]
     d26:	681a      	ldr	r2, [r3, #0]
     d28:	9b02      	ldr	r3, [sp, #8]
     d2a:	1ad3      	subs	r3, r2, r3
     d2c:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
     d2e:	9b01      	ldr	r3, [sp, #4]
     d30:	9a02      	ldr	r2, [sp, #8]
     d32:	601a      	str	r2, [r3, #0]

    return dif;
     d34:	9b03      	ldr	r3, [sp, #12]
}
     d36:	4618      	mov	r0, r3
     d38:	b004      	add	sp, #16
     d3a:	4770      	bx	lr
     d3c:	e000e010 	.word	0xe000e010

00000d40 <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
     d40:	2300      	movs	r3, #0
}
     d42:	4618      	mov	r0, r3
     d44:	4770      	bx	lr

00000d46 <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
     d46:	b082      	sub	sp, #8
     d48:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
     d4a:	2301      	movs	r3, #1
}
     d4c:	4618      	mov	r0, r3
     d4e:	b002      	add	sp, #8
     d50:	4770      	bx	lr

00000d52 <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
     d52:	b082      	sub	sp, #8
     d54:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
     d56:	bf00      	nop
     d58:	b002      	add	sp, #8
     d5a:	4770      	bx	lr

00000d5c <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
     d5c:	b082      	sub	sp, #8
     d5e:	9001      	str	r0, [sp, #4]
    return Micros;
     d60:	9b01      	ldr	r3, [sp, #4]
}
     d62:	4618      	mov	r0, r3
     d64:	b002      	add	sp, #8
     d66:	4770      	bx	lr

00000d68 <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
     d68:	b500      	push	{lr}
     d6a:	b083      	sub	sp, #12
     d6c:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
     d6e:	f7ff ff29 	bl	bc4 <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
     d72:	bf00      	nop
     d74:	b003      	add	sp, #12
     d76:	f85d fb04 	ldr.w	pc, [sp], #4

00000d7a <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
     d7a:	b500      	push	{lr}
     d7c:	b085      	sub	sp, #20
     d7e:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
     d80:	2300      	movs	r3, #0
     d82:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     d84:	9b01      	ldr	r3, [sp, #4]
     d86:	2b00      	cmp	r3, #0
     d88:	d003      	beq.n	d92 <OsIf_GetCounter+0x18>
     d8a:	9b01      	ldr	r3, [sp, #4]
     d8c:	2b01      	cmp	r3, #1
     d8e:	d004      	beq.n	d9a <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     d90:	e007      	b.n	da2 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
     d92:	f7ff ffd5 	bl	d40 <OsIf_Timer_Dummy_GetCounter>
     d96:	9003      	str	r0, [sp, #12]
            break;
     d98:	e003      	b.n	da2 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
     d9a:	f7ff ff2f 	bl	bfc <OsIf_Timer_System_GetCounter>
     d9e:	9003      	str	r0, [sp, #12]
            break;
     da0:	bf00      	nop
    }

    return Value;
     da2:	9b03      	ldr	r3, [sp, #12]
}
     da4:	4618      	mov	r0, r3
     da6:	b005      	add	sp, #20
     da8:	f85d fb04 	ldr.w	pc, [sp], #4

00000dac <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
     dac:	b500      	push	{lr}
     dae:	b085      	sub	sp, #20
     db0:	9001      	str	r0, [sp, #4]
     db2:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
     db4:	2300      	movs	r3, #0
     db6:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     db8:	9b00      	ldr	r3, [sp, #0]
     dba:	2b00      	cmp	r3, #0
     dbc:	d003      	beq.n	dc6 <OsIf_GetElapsed+0x1a>
     dbe:	9b00      	ldr	r3, [sp, #0]
     dc0:	2b01      	cmp	r3, #1
     dc2:	d005      	beq.n	dd0 <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     dc4:	e009      	b.n	dda <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
     dc6:	9801      	ldr	r0, [sp, #4]
     dc8:	f7ff ffbd 	bl	d46 <OsIf_Timer_Dummy_GetElapsed>
     dcc:	9003      	str	r0, [sp, #12]
            break;
     dce:	e004      	b.n	dda <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
     dd0:	9801      	ldr	r0, [sp, #4]
     dd2:	f7ff ff21 	bl	c18 <OsIf_Timer_System_GetElapsed>
     dd6:	9003      	str	r0, [sp, #12]
            break;
     dd8:	bf00      	nop
    }

    return Value;
     dda:	9b03      	ldr	r3, [sp, #12]
}
     ddc:	4618      	mov	r0, r3
     dde:	b005      	add	sp, #20
     de0:	f85d fb04 	ldr.w	pc, [sp], #4

00000de4 <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
     de4:	b500      	push	{lr}
     de6:	b083      	sub	sp, #12
     de8:	9001      	str	r0, [sp, #4]
     dea:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
     dec:	9b00      	ldr	r3, [sp, #0]
     dee:	2b00      	cmp	r3, #0
     df0:	d003      	beq.n	dfa <OsIf_SetTimerFrequency+0x16>
     df2:	9b00      	ldr	r3, [sp, #0]
     df4:	2b01      	cmp	r3, #1
     df6:	d004      	beq.n	e02 <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     df8:	e007      	b.n	e0a <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
     dfa:	9801      	ldr	r0, [sp, #4]
     dfc:	f7ff ffa9 	bl	d52 <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
     e00:	e003      	b.n	e0a <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
     e02:	9801      	ldr	r0, [sp, #4]
     e04:	f7ff ff18 	bl	c38 <OsIf_Timer_System_SetTimerFrequency>
            break;
     e08:	bf00      	nop
    }
}
     e0a:	bf00      	nop
     e0c:	b003      	add	sp, #12
     e0e:	f85d fb04 	ldr.w	pc, [sp], #4

00000e12 <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
     e12:	b500      	push	{lr}
     e14:	b085      	sub	sp, #20
     e16:	9001      	str	r0, [sp, #4]
     e18:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
     e1a:	2300      	movs	r3, #0
     e1c:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
     e1e:	9b00      	ldr	r3, [sp, #0]
     e20:	2b00      	cmp	r3, #0
     e22:	d003      	beq.n	e2c <OsIf_MicrosToTicks+0x1a>
     e24:	9b00      	ldr	r3, [sp, #0]
     e26:	2b01      	cmp	r3, #1
     e28:	d005      	beq.n	e36 <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
     e2a:	e009      	b.n	e40 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
     e2c:	9801      	ldr	r0, [sp, #4]
     e2e:	f7ff ff95 	bl	d5c <OsIf_Timer_Dummy_MicrosToTicks>
     e32:	9003      	str	r0, [sp, #12]
            break;
     e34:	e004      	b.n	e40 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
     e36:	9801      	ldr	r0, [sp, #4]
     e38:	f7ff ff0c 	bl	c54 <OsIf_Timer_System_MicrosToTicks>
     e3c:	9003      	str	r0, [sp, #12]
            break;
     e3e:	bf00      	nop
    }

    return Value;
     e40:	9b03      	ldr	r3, [sp, #12]
}
     e42:	4618      	mov	r0, r3
     e44:	b005      	add	sp, #20
     e46:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00000e4c <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
     e4c:	b082      	sub	sp, #8
     e4e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
     e50:	bf00      	nop
     e52:	b002      	add	sp, #8
     e54:	4770      	bx	lr

00000e56 <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
     e56:	b500      	push	{lr}
     e58:	b083      	sub	sp, #12
     e5a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     e5c:	9b01      	ldr	r3, [sp, #4]
     e5e:	2b00      	cmp	r3, #0
     e60:	d002      	beq.n	e68 <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
     e62:	9801      	ldr	r0, [sp, #4]
     e64:	f000 f8ee 	bl	1044 <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     e68:	bf00      	nop
     e6a:	b003      	add	sp, #12
     e6c:	f85d fb04 	ldr.w	pc, [sp], #4

00000e70 <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
     e70:	b500      	push	{lr}
     e72:	b083      	sub	sp, #12
     e74:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     e76:	9b01      	ldr	r3, [sp, #4]
     e78:	2b00      	cmp	r3, #0
     e7a:	d002      	beq.n	e82 <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
     e7c:	9801      	ldr	r0, [sp, #4]
     e7e:	f000 f8ff 	bl	1080 <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     e82:	bf00      	nop
     e84:	b003      	add	sp, #12
     e86:	f85d fb04 	ldr.w	pc, [sp], #4

00000e8a <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
     e8a:	b500      	push	{lr}
     e8c:	b083      	sub	sp, #12
     e8e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     e90:	9b01      	ldr	r3, [sp, #4]
     e92:	2b00      	cmp	r3, #0
     e94:	d002      	beq.n	e9c <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
     e96:	9801      	ldr	r0, [sp, #4]
     e98:	f000 f912 	bl	10c0 <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     e9c:	bf00      	nop
     e9e:	b003      	add	sp, #12
     ea0:	f85d fb04 	ldr.w	pc, [sp], #4

00000ea4 <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
     ea4:	b500      	push	{lr}
     ea6:	b083      	sub	sp, #12
     ea8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     eaa:	9b01      	ldr	r3, [sp, #4]
     eac:	2b00      	cmp	r3, #0
     eae:	d002      	beq.n	eb6 <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
     eb0:	9801      	ldr	r0, [sp, #4]
     eb2:	f000 f925 	bl	1100 <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     eb6:	bf00      	nop
     eb8:	b003      	add	sp, #12
     eba:	f85d fb04 	ldr.w	pc, [sp], #4

00000ebe <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
     ebe:	b500      	push	{lr}
     ec0:	b083      	sub	sp, #12
     ec2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     ec4:	9b01      	ldr	r3, [sp, #4]
     ec6:	2b00      	cmp	r3, #0
     ec8:	d002      	beq.n	ed0 <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
     eca:	9801      	ldr	r0, [sp, #4]
     ecc:	f000 f936 	bl	113c <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     ed0:	bf00      	nop
     ed2:	b003      	add	sp, #12
     ed4:	f85d fb04 	ldr.w	pc, [sp], #4

00000ed8 <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
     ed8:	b500      	push	{lr}
     eda:	b083      	sub	sp, #12
     edc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     ede:	9b01      	ldr	r3, [sp, #4]
     ee0:	2b00      	cmp	r3, #0
     ee2:	d002      	beq.n	eea <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
     ee4:	9801      	ldr	r0, [sp, #4]
     ee6:	f000 f949 	bl	117c <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     eea:	bf00      	nop
     eec:	b003      	add	sp, #12
     eee:	f85d fb04 	ldr.w	pc, [sp], #4

00000ef2 <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
     ef2:	b500      	push	{lr}
     ef4:	b083      	sub	sp, #12
     ef6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     ef8:	9b01      	ldr	r3, [sp, #4]
     efa:	2b00      	cmp	r3, #0
     efc:	d002      	beq.n	f04 <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
     efe:	9801      	ldr	r0, [sp, #4]
     f00:	f000 f958 	bl	11b4 <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     f04:	bf00      	nop
     f06:	b003      	add	sp, #12
     f08:	f85d fb04 	ldr.w	pc, [sp], #4

00000f0c <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
     f0c:	b500      	push	{lr}
     f0e:	b083      	sub	sp, #12
     f10:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     f12:	9b01      	ldr	r3, [sp, #4]
     f14:	2b00      	cmp	r3, #0
     f16:	d002      	beq.n	f1e <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
     f18:	9801      	ldr	r0, [sp, #4]
     f1a:	f000 f969 	bl	11f0 <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     f1e:	bf00      	nop
     f20:	b003      	add	sp, #12
     f22:	f85d fb04 	ldr.w	pc, [sp], #4

00000f26 <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
     f26:	b500      	push	{lr}
     f28:	b083      	sub	sp, #12
     f2a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     f2c:	9b01      	ldr	r3, [sp, #4]
     f2e:	2b00      	cmp	r3, #0
     f30:	d002      	beq.n	f38 <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
     f32:	9801      	ldr	r0, [sp, #4]
     f34:	f000 f978 	bl	1228 <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     f38:	bf00      	nop
     f3a:	b003      	add	sp, #12
     f3c:	f85d fb04 	ldr.w	pc, [sp], #4

00000f40 <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
     f40:	b500      	push	{lr}
     f42:	b083      	sub	sp, #12
     f44:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     f46:	9b01      	ldr	r3, [sp, #4]
     f48:	2b00      	cmp	r3, #0
     f4a:	d002      	beq.n	f52 <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
     f4c:	9801      	ldr	r0, [sp, #4]
     f4e:	f000 f989 	bl	1264 <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     f52:	bf00      	nop
     f54:	b003      	add	sp, #12
     f56:	f85d fb04 	ldr.w	pc, [sp], #4

00000f5a <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
     f5a:	b500      	push	{lr}
     f5c:	b083      	sub	sp, #12
     f5e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     f60:	9b01      	ldr	r3, [sp, #4]
     f62:	2b00      	cmp	r3, #0
     f64:	d002      	beq.n	f6c <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
     f66:	9801      	ldr	r0, [sp, #4]
     f68:	f000 f998 	bl	129c <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     f6c:	bf00      	nop
     f6e:	b003      	add	sp, #12
     f70:	f85d fb04 	ldr.w	pc, [sp], #4

00000f74 <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
     f74:	b500      	push	{lr}
     f76:	b083      	sub	sp, #12
     f78:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     f7a:	9b01      	ldr	r3, [sp, #4]
     f7c:	2b00      	cmp	r3, #0
     f7e:	d002      	beq.n	f86 <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
     f80:	9801      	ldr	r0, [sp, #4]
     f82:	f000 f9a9 	bl	12d8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     f86:	bf00      	nop
     f88:	b003      	add	sp, #12
     f8a:	f85d fb04 	ldr.w	pc, [sp], #4

00000f8e <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
     f8e:	b500      	push	{lr}
     f90:	b083      	sub	sp, #12
     f92:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     f94:	9b01      	ldr	r3, [sp, #4]
     f96:	2b00      	cmp	r3, #0
     f98:	d002      	beq.n	fa0 <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
     f9a:	9801      	ldr	r0, [sp, #4]
     f9c:	f000 f9e6 	bl	136c <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     fa0:	bf00      	nop
     fa2:	b003      	add	sp, #12
     fa4:	f85d fb04 	ldr.w	pc, [sp], #4

00000fa8 <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
     fa8:	b500      	push	{lr}
     faa:	b083      	sub	sp, #12
     fac:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     fae:	9b01      	ldr	r3, [sp, #4]
     fb0:	2b00      	cmp	r3, #0
     fb2:	d002      	beq.n	fba <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
     fb4:	9801      	ldr	r0, [sp, #4]
     fb6:	f000 fa25 	bl	1404 <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     fba:	bf00      	nop
     fbc:	b003      	add	sp, #12
     fbe:	f85d fb04 	ldr.w	pc, [sp], #4

00000fc2 <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
     fc2:	b500      	push	{lr}
     fc4:	b083      	sub	sp, #12
     fc6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     fc8:	9b01      	ldr	r3, [sp, #4]
     fca:	2b00      	cmp	r3, #0
     fcc:	d002      	beq.n	fd4 <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
     fce:	9801      	ldr	r0, [sp, #4]
     fd0:	f000 fa2a 	bl	1428 <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     fd4:	bf00      	nop
     fd6:	b003      	add	sp, #12
     fd8:	f85d fb04 	ldr.w	pc, [sp], #4

00000fdc <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
     fdc:	b500      	push	{lr}
     fde:	b083      	sub	sp, #12
     fe0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     fe2:	9b01      	ldr	r3, [sp, #4]
     fe4:	2b00      	cmp	r3, #0
     fe6:	d002      	beq.n	fee <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
     fe8:	9801      	ldr	r0, [sp, #4]
     fea:	f000 fa3b 	bl	1464 <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
     fee:	bf00      	nop
     ff0:	b003      	add	sp, #12
     ff2:	f85d fb04 	ldr.w	pc, [sp], #4

00000ff6 <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
     ff6:	b500      	push	{lr}
     ff8:	b083      	sub	sp, #12
     ffa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
     ffc:	9b01      	ldr	r3, [sp, #4]
     ffe:	2b00      	cmp	r3, #0
    1000:	d002      	beq.n	1008 <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    1002:	9801      	ldr	r0, [sp, #4]
    1004:	f000 fa56 	bl	14b4 <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1008:	bf00      	nop
    100a:	b003      	add	sp, #12
    100c:	f85d fb04 	ldr.w	pc, [sp], #4

00001010 <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    1010:	b500      	push	{lr}
    1012:	b083      	sub	sp, #12
    1014:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1016:	9b01      	ldr	r3, [sp, #4]
    1018:	2b00      	cmp	r3, #0
    101a:	d002      	beq.n	1022 <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    101c:	9801      	ldr	r0, [sp, #4]
    101e:	f000 fa79 	bl	1514 <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    1022:	bf00      	nop
    1024:	b003      	add	sp, #12
    1026:	f85d fb04 	ldr.w	pc, [sp], #4

0000102a <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    102a:	b500      	push	{lr}
    102c:	b083      	sub	sp, #12
    102e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    1030:	9b01      	ldr	r3, [sp, #4]
    1032:	2b00      	cmp	r3, #0
    1034:	d002      	beq.n	103c <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    1036:	9801      	ldr	r0, [sp, #4]
    1038:	f000 fa8a 	bl	1550 <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    103c:	bf00      	nop
    103e:	b003      	add	sp, #12
    1040:	f85d fb04 	ldr.w	pc, [sp], #4

00001044 <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1044:	b084      	sub	sp, #16
    1046:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1048:	4b0b      	ldr	r3, [pc, #44]	; (1078 <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    104a:	795b      	ldrb	r3, [r3, #5]
    104c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    104e:	4b0b      	ldr	r3, [pc, #44]	; (107c <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    1050:	695b      	ldr	r3, [r3, #20]
    1052:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    1054:	9b02      	ldr	r3, [sp, #8]
    1056:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    105a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    105c:	9b03      	ldr	r3, [sp, #12]
    105e:	061b      	lsls	r3, r3, #24
    1060:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    1064:	9a02      	ldr	r2, [sp, #8]
    1066:	4313      	orrs	r3, r2
    1068:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    106a:	4a04      	ldr	r2, [pc, #16]	; (107c <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    106c:	9b02      	ldr	r3, [sp, #8]
    106e:	6153      	str	r3, [r2, #20]
}
    1070:	bf00      	nop
    1072:	b004      	add	sp, #16
    1074:	4770      	bx	lr
    1076:	bf00      	nop
    1078:	0000aa58 	.word	0x0000aa58
    107c:	40064000 	.word	0x40064000

00001080 <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1080:	b084      	sub	sp, #16
    1082:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1084:	9b01      	ldr	r3, [sp, #4]
    1086:	685b      	ldr	r3, [r3, #4]
    1088:	4a0b      	ldr	r2, [pc, #44]	; (10b8 <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    108a:	5cd3      	ldrb	r3, [r2, r3]
    108c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    108e:	4b0b      	ldr	r3, [pc, #44]	; (10bc <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    1090:	695b      	ldr	r3, [r3, #20]
    1092:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    1094:	9b02      	ldr	r3, [sp, #8]
    1096:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    109a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    109c:	9b03      	ldr	r3, [sp, #12]
    109e:	061b      	lsls	r3, r3, #24
    10a0:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    10a4:	9a02      	ldr	r2, [sp, #8]
    10a6:	4313      	orrs	r3, r2
    10a8:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    10aa:	4a04      	ldr	r2, [pc, #16]	; (10bc <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    10ac:	9b02      	ldr	r3, [sp, #8]
    10ae:	6153      	str	r3, [r2, #20]
}
    10b0:	bf00      	nop
    10b2:	b004      	add	sp, #16
    10b4:	4770      	bx	lr
    10b6:	bf00      	nop
    10b8:	0000aa58 	.word	0x0000aa58
    10bc:	40064000 	.word	0x40064000

000010c0 <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    10c0:	b084      	sub	sp, #16
    10c2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    10c4:	9b01      	ldr	r3, [sp, #4]
    10c6:	685b      	ldr	r3, [r3, #4]
    10c8:	4a0b      	ldr	r2, [pc, #44]	; (10f8 <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    10ca:	5cd3      	ldrb	r3, [r2, r3]
    10cc:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    10ce:	4b0b      	ldr	r3, [pc, #44]	; (10fc <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    10d0:	699b      	ldr	r3, [r3, #24]
    10d2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    10d4:	9b02      	ldr	r3, [sp, #8]
    10d6:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    10da:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    10dc:	9b03      	ldr	r3, [sp, #12]
    10de:	061b      	lsls	r3, r3, #24
    10e0:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    10e4:	9a02      	ldr	r2, [sp, #8]
    10e6:	4313      	orrs	r3, r2
    10e8:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    10ea:	4a04      	ldr	r2, [pc, #16]	; (10fc <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    10ec:	9b02      	ldr	r3, [sp, #8]
    10ee:	6193      	str	r3, [r2, #24]
}
    10f0:	bf00      	nop
    10f2:	b004      	add	sp, #16
    10f4:	4770      	bx	lr
    10f6:	bf00      	nop
    10f8:	0000aa58 	.word	0x0000aa58
    10fc:	40064000 	.word	0x40064000

00001100 <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1100:	b084      	sub	sp, #16
    1102:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1104:	4b0b      	ldr	r3, [pc, #44]	; (1134 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    1106:	795b      	ldrb	r3, [r3, #5]
    1108:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    110a:	4b0b      	ldr	r3, [pc, #44]	; (1138 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    110c:	69db      	ldr	r3, [r3, #28]
    110e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    1110:	9b02      	ldr	r3, [sp, #8]
    1112:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    1116:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    1118:	9b03      	ldr	r3, [sp, #12]
    111a:	061b      	lsls	r3, r3, #24
    111c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    1120:	9a02      	ldr	r2, [sp, #8]
    1122:	4313      	orrs	r3, r2
    1124:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    1126:	4a04      	ldr	r2, [pc, #16]	; (1138 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    1128:	9b02      	ldr	r3, [sp, #8]
    112a:	61d3      	str	r3, [r2, #28]
}
    112c:	bf00      	nop
    112e:	b004      	add	sp, #16
    1130:	4770      	bx	lr
    1132:	bf00      	nop
    1134:	0000aa58 	.word	0x0000aa58
    1138:	40064000 	.word	0x40064000

0000113c <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    113c:	b084      	sub	sp, #16
    113e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1140:	9b01      	ldr	r3, [sp, #4]
    1142:	685b      	ldr	r3, [r3, #4]
    1144:	4a0b      	ldr	r2, [pc, #44]	; (1174 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    1146:	5cd3      	ldrb	r3, [r2, r3]
    1148:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    114a:	4b0b      	ldr	r3, [pc, #44]	; (1178 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    114c:	69db      	ldr	r3, [r3, #28]
    114e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    1150:	9b02      	ldr	r3, [sp, #8]
    1152:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    1156:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    1158:	9b03      	ldr	r3, [sp, #12]
    115a:	061b      	lsls	r3, r3, #24
    115c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    1160:	9a02      	ldr	r2, [sp, #8]
    1162:	4313      	orrs	r3, r2
    1164:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    1166:	4a04      	ldr	r2, [pc, #16]	; (1178 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    1168:	9b02      	ldr	r3, [sp, #8]
    116a:	61d3      	str	r3, [r2, #28]
}
    116c:	bf00      	nop
    116e:	b004      	add	sp, #16
    1170:	4770      	bx	lr
    1172:	bf00      	nop
    1174:	0000aa58 	.word	0x0000aa58
    1178:	40064000 	.word	0x40064000

0000117c <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    117c:	b084      	sub	sp, #16
    117e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1180:	4b0a      	ldr	r3, [pc, #40]	; (11ac <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    1182:	7b9b      	ldrb	r3, [r3, #14]
    1184:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    1186:	4b0a      	ldr	r3, [pc, #40]	; (11b0 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    1188:	691b      	ldr	r3, [r3, #16]
    118a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    118c:	9b02      	ldr	r3, [sp, #8]
    118e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    1192:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    1194:	9b03      	ldr	r3, [sp, #12]
    1196:	011b      	lsls	r3, r3, #4
    1198:	9a02      	ldr	r2, [sp, #8]
    119a:	4313      	orrs	r3, r2
    119c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    119e:	4a04      	ldr	r2, [pc, #16]	; (11b0 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    11a0:	9b02      	ldr	r3, [sp, #8]
    11a2:	6113      	str	r3, [r2, #16]
}
    11a4:	bf00      	nop
    11a6:	b004      	add	sp, #16
    11a8:	4770      	bx	lr
    11aa:	bf00      	nop
    11ac:	0000aa00 	.word	0x0000aa00
    11b0:	40048000 	.word	0x40048000

000011b4 <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    11b4:	b084      	sub	sp, #16
    11b6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    11b8:	9b01      	ldr	r3, [sp, #4]
    11ba:	685b      	ldr	r3, [r3, #4]
    11bc:	4a0a      	ldr	r2, [pc, #40]	; (11e8 <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    11be:	5cd3      	ldrb	r3, [r2, r3]
    11c0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    11c2:	4b0a      	ldr	r3, [pc, #40]	; (11ec <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    11c4:	691b      	ldr	r3, [r3, #16]
    11c6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    11c8:	9b02      	ldr	r3, [sp, #8]
    11ca:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    11ce:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    11d0:	9b03      	ldr	r3, [sp, #12]
    11d2:	011b      	lsls	r3, r3, #4
    11d4:	9a02      	ldr	r2, [sp, #8]
    11d6:	4313      	orrs	r3, r2
    11d8:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    11da:	4a04      	ldr	r2, [pc, #16]	; (11ec <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    11dc:	9b02      	ldr	r3, [sp, #8]
    11de:	6113      	str	r3, [r2, #16]
}
    11e0:	bf00      	nop
    11e2:	b004      	add	sp, #16
    11e4:	4770      	bx	lr
    11e6:	bf00      	nop
    11e8:	0000aa00 	.word	0x0000aa00
    11ec:	40048000 	.word	0x40048000

000011f0 <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    11f0:	b084      	sub	sp, #16
    11f2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    11f4:	4b0a      	ldr	r3, [pc, #40]	; (1220 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    11f6:	785b      	ldrb	r3, [r3, #1]
    11f8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    11fa:	4b0a      	ldr	r3, [pc, #40]	; (1224 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    11fc:	691b      	ldr	r3, [r3, #16]
    11fe:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    1200:	9b02      	ldr	r3, [sp, #8]
    1202:	f023 030c 	bic.w	r3, r3, #12
    1206:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    1208:	9b03      	ldr	r3, [sp, #12]
    120a:	009b      	lsls	r3, r3, #2
    120c:	9a02      	ldr	r2, [sp, #8]
    120e:	4313      	orrs	r3, r2
    1210:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    1212:	4a04      	ldr	r2, [pc, #16]	; (1224 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    1214:	9b02      	ldr	r3, [sp, #8]
    1216:	6113      	str	r3, [r2, #16]
}
    1218:	bf00      	nop
    121a:	b004      	add	sp, #16
    121c:	4770      	bx	lr
    121e:	bf00      	nop
    1220:	0000aab8 	.word	0x0000aab8
    1224:	40048000 	.word	0x40048000

00001228 <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1228:	b084      	sub	sp, #16
    122a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    122c:	9b01      	ldr	r3, [sp, #4]
    122e:	685b      	ldr	r3, [r3, #4]
    1230:	4a0a      	ldr	r2, [pc, #40]	; (125c <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    1232:	5cd3      	ldrb	r3, [r2, r3]
    1234:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    1236:	4b0a      	ldr	r3, [pc, #40]	; (1260 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    1238:	691b      	ldr	r3, [r3, #16]
    123a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    123c:	9b02      	ldr	r3, [sp, #8]
    123e:	f023 030c 	bic.w	r3, r3, #12
    1242:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    1244:	9b03      	ldr	r3, [sp, #12]
    1246:	009b      	lsls	r3, r3, #2
    1248:	9a02      	ldr	r2, [sp, #8]
    124a:	4313      	orrs	r3, r2
    124c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    124e:	4a04      	ldr	r2, [pc, #16]	; (1260 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    1250:	9b02      	ldr	r3, [sp, #8]
    1252:	6113      	str	r3, [r2, #16]
}
    1254:	bf00      	nop
    1256:	b004      	add	sp, #16
    1258:	4770      	bx	lr
    125a:	bf00      	nop
    125c:	0000aab8 	.word	0x0000aab8
    1260:	40048000 	.word	0x40048000

00001264 <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1264:	b084      	sub	sp, #16
    1266:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1268:	4b0a      	ldr	r3, [pc, #40]	; (1294 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    126a:	795b      	ldrb	r3, [r3, #5]
    126c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    126e:	4b0a      	ldr	r3, [pc, #40]	; (1298 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    1270:	6a1b      	ldr	r3, [r3, #32]
    1272:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    1274:	9b02      	ldr	r3, [sp, #8]
    1276:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    127a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    127c:	9b03      	ldr	r3, [sp, #12]
    127e:	061b      	lsls	r3, r3, #24
    1280:	9a02      	ldr	r2, [sp, #8]
    1282:	4313      	orrs	r3, r2
    1284:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    1286:	4a04      	ldr	r2, [pc, #16]	; (1298 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    1288:	9b02      	ldr	r3, [sp, #8]
    128a:	6213      	str	r3, [r2, #32]
}
    128c:	bf00      	nop
    128e:	b004      	add	sp, #16
    1290:	4770      	bx	lr
    1292:	bf00      	nop
    1294:	0000aa58 	.word	0x0000aa58
    1298:	40064000 	.word	0x40064000

0000129c <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    129c:	b084      	sub	sp, #16
    129e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    12a0:	9b01      	ldr	r3, [sp, #4]
    12a2:	685b      	ldr	r3, [r3, #4]
    12a4:	4a0a      	ldr	r2, [pc, #40]	; (12d0 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    12a6:	5cd3      	ldrb	r3, [r2, r3]
    12a8:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    12aa:	4b0a      	ldr	r3, [pc, #40]	; (12d4 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    12ac:	6a1b      	ldr	r3, [r3, #32]
    12ae:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    12b0:	9b02      	ldr	r3, [sp, #8]
    12b2:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    12b6:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    12b8:	9b03      	ldr	r3, [sp, #12]
    12ba:	061b      	lsls	r3, r3, #24
    12bc:	9a02      	ldr	r2, [sp, #8]
    12be:	4313      	orrs	r3, r2
    12c0:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    12c2:	4a04      	ldr	r2, [pc, #16]	; (12d4 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    12c4:	9b02      	ldr	r3, [sp, #8]
    12c6:	6213      	str	r3, [r2, #32]
}
    12c8:	bf00      	nop
    12ca:	b004      	add	sp, #16
    12cc:	4770      	bx	lr
    12ce:	bf00      	nop
    12d0:	0000aa58 	.word	0x0000aa58
    12d4:	40064000 	.word	0x40064000

000012d8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    12d8:	b086      	sub	sp, #24
    12da:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    12dc:	4b20      	ldr	r3, [pc, #128]	; (1360 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    12de:	795b      	ldrb	r3, [r3, #5]
    12e0:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    12e2:	9b01      	ldr	r3, [sp, #4]
    12e4:	681a      	ldr	r2, [r3, #0]
    12e6:	491f      	ldr	r1, [pc, #124]	; (1364 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    12e8:	4613      	mov	r3, r2
    12ea:	00db      	lsls	r3, r3, #3
    12ec:	4413      	add	r3, r2
    12ee:	440b      	add	r3, r1
    12f0:	781b      	ldrb	r3, [r3, #0]
    12f2:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    12f4:	4b1c      	ldr	r3, [pc, #112]	; (1368 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    12f6:	68db      	ldr	r3, [r3, #12]
    12f8:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    12fa:	9b03      	ldr	r3, [sp, #12]
    12fc:	2b03      	cmp	r3, #3
    12fe:	d813      	bhi.n	1328 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    1300:	9b03      	ldr	r3, [sp, #12]
    1302:	005b      	lsls	r3, r3, #1
    1304:	3318      	adds	r3, #24
    1306:	2203      	movs	r2, #3
    1308:	fa02 f303 	lsl.w	r3, r2, r3
    130c:	43db      	mvns	r3, r3
    130e:	9a05      	ldr	r2, [sp, #20]
    1310:	4013      	ands	r3, r2
    1312:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    1314:	9b03      	ldr	r3, [sp, #12]
    1316:	005b      	lsls	r3, r3, #1
    1318:	3318      	adds	r3, #24
    131a:	9a04      	ldr	r2, [sp, #16]
    131c:	fa02 f303 	lsl.w	r3, r2, r3
    1320:	9a05      	ldr	r2, [sp, #20]
    1322:	4313      	orrs	r3, r2
    1324:	9305      	str	r3, [sp, #20]
    1326:	e014      	b.n	1352 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    1328:	9b03      	ldr	r3, [sp, #12]
    132a:	3b04      	subs	r3, #4
    132c:	005b      	lsls	r3, r3, #1
    132e:	3310      	adds	r3, #16
    1330:	2203      	movs	r2, #3
    1332:	fa02 f303 	lsl.w	r3, r2, r3
    1336:	43db      	mvns	r3, r3
    1338:	9a05      	ldr	r2, [sp, #20]
    133a:	4013      	ands	r3, r2
    133c:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    133e:	9b03      	ldr	r3, [sp, #12]
    1340:	3b04      	subs	r3, #4
    1342:	005b      	lsls	r3, r3, #1
    1344:	3310      	adds	r3, #16
    1346:	9a04      	ldr	r2, [sp, #16]
    1348:	fa02 f303 	lsl.w	r3, r2, r3
    134c:	9a05      	ldr	r2, [sp, #20]
    134e:	4313      	orrs	r3, r2
    1350:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    1352:	4a05      	ldr	r2, [pc, #20]	; (1368 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    1354:	9b05      	ldr	r3, [sp, #20]
    1356:	60d3      	str	r3, [r2, #12]
}
    1358:	bf00      	nop
    135a:	b006      	add	sp, #24
    135c:	4770      	bx	lr
    135e:	bf00      	nop
    1360:	0000aa00 	.word	0x0000aa00
    1364:	0000a6f0 	.word	0x0000a6f0
    1368:	40048000 	.word	0x40048000

0000136c <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    136c:	b086      	sub	sp, #24
    136e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1370:	9b01      	ldr	r3, [sp, #4]
    1372:	685b      	ldr	r3, [r3, #4]
    1374:	4a20      	ldr	r2, [pc, #128]	; (13f8 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    1376:	5cd3      	ldrb	r3, [r2, r3]
    1378:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    137a:	9b01      	ldr	r3, [sp, #4]
    137c:	681a      	ldr	r2, [r3, #0]
    137e:	491f      	ldr	r1, [pc, #124]	; (13fc <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    1380:	4613      	mov	r3, r2
    1382:	00db      	lsls	r3, r3, #3
    1384:	4413      	add	r3, r2
    1386:	440b      	add	r3, r1
    1388:	781b      	ldrb	r3, [r3, #0]
    138a:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    138c:	4b1c      	ldr	r3, [pc, #112]	; (1400 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    138e:	68db      	ldr	r3, [r3, #12]
    1390:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    1392:	9b03      	ldr	r3, [sp, #12]
    1394:	2b03      	cmp	r3, #3
    1396:	d813      	bhi.n	13c0 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    1398:	9b03      	ldr	r3, [sp, #12]
    139a:	005b      	lsls	r3, r3, #1
    139c:	3318      	adds	r3, #24
    139e:	2203      	movs	r2, #3
    13a0:	fa02 f303 	lsl.w	r3, r2, r3
    13a4:	43db      	mvns	r3, r3
    13a6:	9a05      	ldr	r2, [sp, #20]
    13a8:	4013      	ands	r3, r2
    13aa:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    13ac:	9b03      	ldr	r3, [sp, #12]
    13ae:	005b      	lsls	r3, r3, #1
    13b0:	3318      	adds	r3, #24
    13b2:	9a04      	ldr	r2, [sp, #16]
    13b4:	fa02 f303 	lsl.w	r3, r2, r3
    13b8:	9a05      	ldr	r2, [sp, #20]
    13ba:	4313      	orrs	r3, r2
    13bc:	9305      	str	r3, [sp, #20]
    13be:	e014      	b.n	13ea <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    13c0:	9b03      	ldr	r3, [sp, #12]
    13c2:	3b04      	subs	r3, #4
    13c4:	005b      	lsls	r3, r3, #1
    13c6:	3310      	adds	r3, #16
    13c8:	2203      	movs	r2, #3
    13ca:	fa02 f303 	lsl.w	r3, r2, r3
    13ce:	43db      	mvns	r3, r3
    13d0:	9a05      	ldr	r2, [sp, #20]
    13d2:	4013      	ands	r3, r2
    13d4:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    13d6:	9b03      	ldr	r3, [sp, #12]
    13d8:	3b04      	subs	r3, #4
    13da:	005b      	lsls	r3, r3, #1
    13dc:	3310      	adds	r3, #16
    13de:	9a04      	ldr	r2, [sp, #16]
    13e0:	fa02 f303 	lsl.w	r3, r2, r3
    13e4:	9a05      	ldr	r2, [sp, #20]
    13e6:	4313      	orrs	r3, r2
    13e8:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    13ea:	4a05      	ldr	r2, [pc, #20]	; (1400 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    13ec:	9b05      	ldr	r3, [sp, #20]
    13ee:	60d3      	str	r3, [r2, #12]
}
    13f0:	bf00      	nop
    13f2:	b006      	add	sp, #24
    13f4:	4770      	bx	lr
    13f6:	bf00      	nop
    13f8:	0000aa00 	.word	0x0000aa00
    13fc:	0000a6f0 	.word	0x0000a6f0
    1400:	40048000 	.word	0x40048000

00001404 <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1404:	b084      	sub	sp, #16
    1406:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    1408:	4b06      	ldr	r3, [pc, #24]	; (1424 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    140a:	685b      	ldr	r3, [r3, #4]
    140c:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    140e:	9b03      	ldr	r3, [sp, #12]
    1410:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    1414:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    1416:	4a03      	ldr	r2, [pc, #12]	; (1424 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    1418:	9b03      	ldr	r3, [sp, #12]
    141a:	6053      	str	r3, [r2, #4]
}
    141c:	bf00      	nop
    141e:	b004      	add	sp, #16
    1420:	4770      	bx	lr
    1422:	bf00      	nop
    1424:	40048000 	.word	0x40048000

00001428 <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1428:	b084      	sub	sp, #16
    142a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    142c:	9b01      	ldr	r3, [sp, #4]
    142e:	685b      	ldr	r3, [r3, #4]
    1430:	4a0a      	ldr	r2, [pc, #40]	; (145c <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    1432:	5cd3      	ldrb	r3, [r2, r3]
    1434:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    1436:	4b0a      	ldr	r3, [pc, #40]	; (1460 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    1438:	685b      	ldr	r3, [r3, #4]
    143a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    143c:	9b02      	ldr	r3, [sp, #8]
    143e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    1442:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    1444:	9b03      	ldr	r3, [sp, #12]
    1446:	011b      	lsls	r3, r3, #4
    1448:	9a02      	ldr	r2, [sp, #8]
    144a:	4313      	orrs	r3, r2
    144c:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    144e:	4a04      	ldr	r2, [pc, #16]	; (1460 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    1450:	9b02      	ldr	r3, [sp, #8]
    1452:	6053      	str	r3, [r2, #4]
}
    1454:	bf00      	nop
    1456:	b004      	add	sp, #16
    1458:	4770      	bx	lr
    145a:	bf00      	nop
    145c:	0000aa00 	.word	0x0000aa00
    1460:	40048000 	.word	0x40048000

00001464 <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1464:	b084      	sub	sp, #16
    1466:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    1468:	9b01      	ldr	r3, [sp, #4]
    146a:	681a      	ldr	r2, [r3, #0]
    146c:	490f      	ldr	r1, [pc, #60]	; (14ac <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    146e:	4613      	mov	r3, r2
    1470:	00db      	lsls	r3, r3, #3
    1472:	4413      	add	r3, r2
    1474:	440b      	add	r3, r1
    1476:	3304      	adds	r3, #4
    1478:	781b      	ldrb	r3, [r3, #0]
    147a:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    147c:	4a0c      	ldr	r2, [pc, #48]	; (14b0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    147e:	9b03      	ldr	r3, [sp, #12]
    1480:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1484:	490a      	ldr	r1, [pc, #40]	; (14b0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    1486:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    148a:	9b03      	ldr	r3, [sp, #12]
    148c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    1490:	4a07      	ldr	r2, [pc, #28]	; (14b0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    1492:	9b03      	ldr	r3, [sp, #12]
    1494:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1498:	4905      	ldr	r1, [pc, #20]	; (14b0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    149a:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    149e:	9b03      	ldr	r3, [sp, #12]
    14a0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    14a4:	bf00      	nop
    14a6:	b004      	add	sp, #16
    14a8:	4770      	bx	lr
    14aa:	bf00      	nop
    14ac:	0000a6f0 	.word	0x0000a6f0
    14b0:	40065000 	.word	0x40065000

000014b4 <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    14b4:	b086      	sub	sp, #24
    14b6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    14b8:	9b01      	ldr	r3, [sp, #4]
    14ba:	681a      	ldr	r2, [r3, #0]
    14bc:	4912      	ldr	r1, [pc, #72]	; (1508 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    14be:	4613      	mov	r3, r2
    14c0:	00db      	lsls	r3, r3, #3
    14c2:	4413      	add	r3, r2
    14c4:	440b      	add	r3, r1
    14c6:	3304      	adds	r3, #4
    14c8:	781b      	ldrb	r3, [r3, #0]
    14ca:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    14cc:	9b01      	ldr	r3, [sp, #4]
    14ce:	685b      	ldr	r3, [r3, #4]
    14d0:	4a0e      	ldr	r2, [pc, #56]	; (150c <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    14d2:	5cd3      	ldrb	r3, [r2, r3]
    14d4:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    14d6:	4a0e      	ldr	r2, [pc, #56]	; (1510 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    14d8:	9b05      	ldr	r3, [sp, #20]
    14da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    14de:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    14e0:	9b03      	ldr	r3, [sp, #12]
    14e2:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    14e6:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    14e8:	9b04      	ldr	r3, [sp, #16]
    14ea:	061b      	lsls	r3, r3, #24
    14ec:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    14f0:	9a03      	ldr	r2, [sp, #12]
    14f2:	4313      	orrs	r3, r2
    14f4:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    14f6:	4906      	ldr	r1, [pc, #24]	; (1510 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    14f8:	9b05      	ldr	r3, [sp, #20]
    14fa:	9a03      	ldr	r2, [sp, #12]
    14fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    1500:	bf00      	nop
    1502:	b006      	add	sp, #24
    1504:	4770      	bx	lr
    1506:	bf00      	nop
    1508:	0000a6f0 	.word	0x0000a6f0
    150c:	0000aa88 	.word	0x0000aa88
    1510:	40065000 	.word	0x40065000

00001514 <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1514:	b084      	sub	sp, #16
    1516:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1518:	4b0b      	ldr	r3, [pc, #44]	; (1548 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    151a:	7f1b      	ldrb	r3, [r3, #28]
    151c:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    151e:	4b0b      	ldr	r3, [pc, #44]	; (154c <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    1520:	685b      	ldr	r3, [r3, #4]
    1522:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    1524:	9b02      	ldr	r3, [sp, #8]
    1526:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    152a:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    152c:	9b03      	ldr	r3, [sp, #12]
    152e:	031b      	lsls	r3, r3, #12
    1530:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    1534:	9a02      	ldr	r2, [sp, #8]
    1536:	4313      	orrs	r3, r2
    1538:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    153a:	4a04      	ldr	r2, [pc, #16]	; (154c <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    153c:	9b02      	ldr	r3, [sp, #8]
    153e:	6053      	str	r3, [r2, #4]
}
    1540:	bf00      	nop
    1542:	b004      	add	sp, #16
    1544:	4770      	bx	lr
    1546:	bf00      	nop
    1548:	0000aa00 	.word	0x0000aa00
    154c:	40048000 	.word	0x40048000

00001550 <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    1550:	b084      	sub	sp, #16
    1552:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    1554:	9b01      	ldr	r3, [sp, #4]
    1556:	685b      	ldr	r3, [r3, #4]
    1558:	4a0b      	ldr	r2, [pc, #44]	; (1588 <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    155a:	5cd3      	ldrb	r3, [r2, r3]
    155c:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    155e:	4b0b      	ldr	r3, [pc, #44]	; (158c <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    1560:	685b      	ldr	r3, [r3, #4]
    1562:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    1564:	9b02      	ldr	r3, [sp, #8]
    1566:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    156a:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    156c:	9b03      	ldr	r3, [sp, #12]
    156e:	031b      	lsls	r3, r3, #12
    1570:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    1574:	9a02      	ldr	r2, [sp, #8]
    1576:	4313      	orrs	r3, r2
    1578:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    157a:	4a04      	ldr	r2, [pc, #16]	; (158c <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    157c:	9b02      	ldr	r3, [sp, #8]
    157e:	6053      	str	r3, [r2, #4]
}
    1580:	bf00      	nop
    1582:	b004      	add	sp, #16
    1584:	4770      	bx	lr
    1586:	bf00      	nop
    1588:	0000aa00 	.word	0x0000aa00
    158c:	40048000 	.word	0x40048000

00001590 <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    1590:	b500      	push	{lr}
    1592:	b085      	sub	sp, #20
    1594:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    1596:	2300      	movs	r3, #0
    1598:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    159c:	9b01      	ldr	r3, [sp, #4]
    159e:	2b00      	cmp	r3, #0
    15a0:	d037      	beq.n	1612 <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    15a2:	2300      	movs	r3, #0
    15a4:	9303      	str	r3, [sp, #12]
    15a6:	e02b      	b.n	1600 <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    15a8:	4b29      	ldr	r3, [pc, #164]	; (1650 <DisableSafeClock+0xc0>)
    15aa:	6819      	ldr	r1, [r3, #0]
    15ac:	9a03      	ldr	r2, [sp, #12]
    15ae:	4613      	mov	r3, r2
    15b0:	005b      	lsls	r3, r3, #1
    15b2:	4413      	add	r3, r2
    15b4:	009b      	lsls	r3, r3, #2
    15b6:	440b      	add	r3, r1
    15b8:	3314      	adds	r3, #20
    15ba:	681b      	ldr	r3, [r3, #0]
    15bc:	2b05      	cmp	r3, #5
    15be:	d11c      	bne.n	15fa <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    15c0:	2301      	movs	r3, #1
    15c2:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    15c6:	4b22      	ldr	r3, [pc, #136]	; (1650 <DisableSafeClock+0xc0>)
    15c8:	6819      	ldr	r1, [r3, #0]
    15ca:	9a03      	ldr	r2, [sp, #12]
    15cc:	4613      	mov	r3, r2
    15ce:	005b      	lsls	r3, r3, #1
    15d0:	4413      	add	r3, r2
    15d2:	009b      	lsls	r3, r3, #2
    15d4:	440b      	add	r3, r1
    15d6:	3318      	adds	r3, #24
    15d8:	881b      	ldrh	r3, [r3, #0]
    15da:	2b00      	cmp	r3, #0
    15dc:	d118      	bne.n	1610 <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    15de:	4b1d      	ldr	r3, [pc, #116]	; (1654 <DisableSafeClock+0xc4>)
    15e0:	791b      	ldrb	r3, [r3, #4]
    15e2:	4619      	mov	r1, r3
    15e4:	4a1c      	ldr	r2, [pc, #112]	; (1658 <DisableSafeClock+0xc8>)
    15e6:	460b      	mov	r3, r1
    15e8:	005b      	lsls	r3, r3, #1
    15ea:	440b      	add	r3, r1
    15ec:	009b      	lsls	r3, r3, #2
    15ee:	4413      	add	r3, r2
    15f0:	3308      	adds	r3, #8
    15f2:	681b      	ldr	r3, [r3, #0]
    15f4:	2005      	movs	r0, #5
    15f6:	4798      	blx	r3
                }
                break;
    15f8:	e00a      	b.n	1610 <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    15fa:	9b03      	ldr	r3, [sp, #12]
    15fc:	3301      	adds	r3, #1
    15fe:	9303      	str	r3, [sp, #12]
    1600:	4b13      	ldr	r3, [pc, #76]	; (1650 <DisableSafeClock+0xc0>)
    1602:	681b      	ldr	r3, [r3, #0]
    1604:	7a1b      	ldrb	r3, [r3, #8]
    1606:	461a      	mov	r2, r3
    1608:	9b03      	ldr	r3, [sp, #12]
    160a:	4293      	cmp	r3, r2
    160c:	d3cc      	bcc.n	15a8 <DisableSafeClock+0x18>
    160e:	e000      	b.n	1612 <DisableSafeClock+0x82>
                break;
    1610:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    1612:	f89d 300b 	ldrb.w	r3, [sp, #11]
    1616:	f083 0301 	eor.w	r3, r3, #1
    161a:	b2db      	uxtb	r3, r3
    161c:	2b00      	cmp	r3, #0
    161e:	d013      	beq.n	1648 <DisableSafeClock+0xb8>
    1620:	4b0e      	ldr	r3, [pc, #56]	; (165c <DisableSafeClock+0xcc>)
    1622:	781b      	ldrb	r3, [r3, #0]
    1624:	f083 0301 	eor.w	r3, r3, #1
    1628:	b2db      	uxtb	r3, r3
    162a:	2b00      	cmp	r3, #0
    162c:	d00c      	beq.n	1648 <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    162e:	4b09      	ldr	r3, [pc, #36]	; (1654 <DisableSafeClock+0xc4>)
    1630:	791b      	ldrb	r3, [r3, #4]
    1632:	4619      	mov	r1, r3
    1634:	4a08      	ldr	r2, [pc, #32]	; (1658 <DisableSafeClock+0xc8>)
    1636:	460b      	mov	r3, r1
    1638:	005b      	lsls	r3, r3, #1
    163a:	440b      	add	r3, r1
    163c:	009b      	lsls	r3, r3, #2
    163e:	4413      	add	r3, r2
    1640:	3308      	adds	r3, #8
    1642:	681b      	ldr	r3, [r3, #0]
    1644:	2005      	movs	r0, #5
    1646:	4798      	blx	r3
    }
}
    1648:	bf00      	nop
    164a:	b005      	add	sp, #20
    164c:	f85d fb04 	ldr.w	pc, [sp], #4
    1650:	1fff8b64 	.word	0x1fff8b64
    1654:	0000a680 	.word	0x0000a680
    1658:	0000accc 	.word	0x0000accc
    165c:	1fff8b10 	.word	0x1fff8b10

00001660 <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    1660:	4b06      	ldr	r3, [pc, #24]	; (167c <SetFircToResetValue_TrustedCall+0x1c>)
    1662:	2200      	movs	r2, #0
    1664:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    1668:	4b04      	ldr	r3, [pc, #16]	; (167c <SetFircToResetValue_TrustedCall+0x1c>)
    166a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    166e:	4a03      	ldr	r2, [pc, #12]	; (167c <SetFircToResetValue_TrustedCall+0x1c>)
    1670:	f043 0301 	orr.w	r3, r3, #1
    1674:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    1678:	bf00      	nop
    167a:	4770      	bx	lr
    167c:	40064000 	.word	0x40064000

00001680 <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    1680:	b084      	sub	sp, #16
    1682:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    1684:	2303      	movs	r3, #3
    1686:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    1688:	2300      	movs	r3, #0
    168a:	9302      	str	r3, [sp, #8]
    168c:	e028      	b.n	16e0 <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    168e:	9b01      	ldr	r3, [sp, #4]
    1690:	9a02      	ldr	r2, [sp, #8]
    1692:	320d      	adds	r2, #13
    1694:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    1698:	2b28      	cmp	r3, #40	; 0x28
    169a:	d10b      	bne.n	16b4 <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    169c:	9a01      	ldr	r2, [sp, #4]
    169e:	9b02      	ldr	r3, [sp, #8]
    16a0:	330d      	adds	r3, #13
    16a2:	00db      	lsls	r3, r3, #3
    16a4:	4413      	add	r3, r2
    16a6:	685b      	ldr	r3, [r3, #4]
    16a8:	4a2b      	ldr	r2, [pc, #172]	; (1758 <SetSimLpoclksRegister_TrustedCall+0xd8>)
    16aa:	5cd3      	ldrb	r3, [r2, r3]
    16ac:	011b      	lsls	r3, r3, #4
    16ae:	9a03      	ldr	r2, [sp, #12]
    16b0:	4313      	orrs	r3, r2
    16b2:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    16b4:	9b01      	ldr	r3, [sp, #4]
    16b6:	9a02      	ldr	r2, [sp, #8]
    16b8:	320d      	adds	r2, #13
    16ba:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    16be:	2b29      	cmp	r3, #41	; 0x29
    16c0:	d10b      	bne.n	16da <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    16c2:	9a01      	ldr	r2, [sp, #4]
    16c4:	9b02      	ldr	r3, [sp, #8]
    16c6:	330d      	adds	r3, #13
    16c8:	00db      	lsls	r3, r3, #3
    16ca:	4413      	add	r3, r2
    16cc:	685b      	ldr	r3, [r3, #4]
    16ce:	4a23      	ldr	r2, [pc, #140]	; (175c <SetSimLpoclksRegister_TrustedCall+0xdc>)
    16d0:	5cd3      	ldrb	r3, [r2, r3]
    16d2:	009b      	lsls	r3, r3, #2
    16d4:	9a03      	ldr	r2, [sp, #12]
    16d6:	4313      	orrs	r3, r2
    16d8:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    16da:	9b02      	ldr	r3, [sp, #8]
    16dc:	3301      	adds	r3, #1
    16de:	9302      	str	r3, [sp, #8]
    16e0:	9b01      	ldr	r3, [sp, #4]
    16e2:	7adb      	ldrb	r3, [r3, #11]
    16e4:	461a      	mov	r2, r3
    16e6:	9b02      	ldr	r3, [sp, #8]
    16e8:	4293      	cmp	r3, r2
    16ea:	d3d0      	bcc.n	168e <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    16ec:	2300      	movs	r3, #0
    16ee:	9302      	str	r3, [sp, #8]
    16f0:	e026      	b.n	1740 <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    16f2:	9a01      	ldr	r2, [sp, #4]
    16f4:	9b02      	ldr	r3, [sp, #8]
    16f6:	334e      	adds	r3, #78	; 0x4e
    16f8:	00db      	lsls	r3, r3, #3
    16fa:	4413      	add	r3, r2
    16fc:	685b      	ldr	r3, [r3, #4]
    16fe:	2b12      	cmp	r3, #18
    1700:	d109      	bne.n	1716 <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    1702:	9a01      	ldr	r2, [sp, #4]
    1704:	9b02      	ldr	r3, [sp, #8]
    1706:	334e      	adds	r3, #78	; 0x4e
    1708:	00db      	lsls	r3, r3, #3
    170a:	4413      	add	r3, r2
    170c:	891b      	ldrh	r3, [r3, #8]
    170e:	005b      	lsls	r3, r3, #1
    1710:	9a03      	ldr	r2, [sp, #12]
    1712:	4313      	orrs	r3, r2
    1714:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    1716:	9a01      	ldr	r2, [sp, #4]
    1718:	9b02      	ldr	r3, [sp, #8]
    171a:	334e      	adds	r3, #78	; 0x4e
    171c:	00db      	lsls	r3, r3, #3
    171e:	4413      	add	r3, r2
    1720:	685b      	ldr	r3, [r3, #4]
    1722:	2b13      	cmp	r3, #19
    1724:	d109      	bne.n	173a <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    1726:	9a01      	ldr	r2, [sp, #4]
    1728:	9b02      	ldr	r3, [sp, #8]
    172a:	334e      	adds	r3, #78	; 0x4e
    172c:	00db      	lsls	r3, r3, #3
    172e:	4413      	add	r3, r2
    1730:	891b      	ldrh	r3, [r3, #8]
    1732:	461a      	mov	r2, r3
    1734:	9b03      	ldr	r3, [sp, #12]
    1736:	4313      	orrs	r3, r2
    1738:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    173a:	9b02      	ldr	r3, [sp, #8]
    173c:	3301      	adds	r3, #1
    173e:	9302      	str	r3, [sp, #8]
    1740:	9b01      	ldr	r3, [sp, #4]
    1742:	7c1b      	ldrb	r3, [r3, #16]
    1744:	461a      	mov	r2, r3
    1746:	9b02      	ldr	r3, [sp, #8]
    1748:	4293      	cmp	r3, r2
    174a:	d3d2      	bcc.n	16f2 <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    174c:	4a04      	ldr	r2, [pc, #16]	; (1760 <SetSimLpoclksRegister_TrustedCall+0xe0>)
    174e:	9b03      	ldr	r3, [sp, #12]
    1750:	6113      	str	r3, [r2, #16]
}
    1752:	bf00      	nop
    1754:	b004      	add	sp, #16
    1756:	4770      	bx	lr
    1758:	0000aa00 	.word	0x0000aa00
    175c:	0000aab8 	.word	0x0000aab8
    1760:	40048000 	.word	0x40048000

00001764 <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    1764:	b500      	push	{lr}
    1766:	b089      	sub	sp, #36	; 0x24
    1768:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    176a:	2300      	movs	r3, #0
    176c:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    1770:	4a21      	ldr	r2, [pc, #132]	; (17f8 <Clock_Ip_SpecificPlatformInitClock+0x94>)
    1772:	9b01      	ldr	r3, [sp, #4]
    1774:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    1776:	4b21      	ldr	r3, [pc, #132]	; (17fc <Clock_Ip_SpecificPlatformInitClock+0x98>)
    1778:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    177c:	f003 0301 	and.w	r3, r3, #1
    1780:	2b00      	cmp	r3, #0
    1782:	d12e      	bne.n	17e2 <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    1784:	4b1e      	ldr	r3, [pc, #120]	; (1800 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    1786:	2200      	movs	r2, #0
    1788:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    178a:	f7ff ff69 	bl	1660 <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    178e:	aa03      	add	r2, sp, #12
    1790:	a904      	add	r1, sp, #16
    1792:	a805      	add	r0, sp, #20
    1794:	f24c 3350 	movw	r3, #50000	; 0xc350
    1798:	f001 fedc 	bl	3554 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    179c:	4b17      	ldr	r3, [pc, #92]	; (17fc <Clock_Ip_SpecificPlatformInitClock+0x98>)
    179e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    17a2:	0e1b      	lsrs	r3, r3, #24
    17a4:	f003 0301 	and.w	r3, r3, #1
    17a8:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    17aa:	9a03      	ldr	r2, [sp, #12]
    17ac:	a904      	add	r1, sp, #16
    17ae:	ab05      	add	r3, sp, #20
    17b0:	4618      	mov	r0, r3
    17b2:	f001 fee9 	bl	3588 <Clock_Ip_TimeoutExpired>
    17b6:	4603      	mov	r3, r0
    17b8:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    17bc:	9b06      	ldr	r3, [sp, #24]
    17be:	2b00      	cmp	r3, #0
    17c0:	d106      	bne.n	17d0 <Clock_Ip_SpecificPlatformInitClock+0x6c>
    17c2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    17c6:	f083 0301 	eor.w	r3, r3, #1
    17ca:	b2db      	uxtb	r3, r3
    17cc:	2b00      	cmp	r3, #0
    17ce:	d1e5      	bne.n	179c <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    17d0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    17d4:	2b00      	cmp	r3, #0
    17d6:	d007      	beq.n	17e8 <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    17d8:	2105      	movs	r1, #5
    17da:	2001      	movs	r0, #1
    17dc:	f001 feaa 	bl	3534 <Clock_Ip_ReportClockErrors>
    17e0:	e002      	b.n	17e8 <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    17e2:	4b07      	ldr	r3, [pc, #28]	; (1800 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    17e4:	2201      	movs	r2, #1
    17e6:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    17e8:	9801      	ldr	r0, [sp, #4]
    17ea:	f7ff ff49 	bl	1680 <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    17ee:	bf00      	nop
    17f0:	b009      	add	sp, #36	; 0x24
    17f2:	f85d fb04 	ldr.w	pc, [sp], #4
    17f6:	bf00      	nop
    17f8:	1fff8b64 	.word	0x1fff8b64
    17fc:	40064000 	.word	0x40064000
    1800:	1fff8b10 	.word	0x1fff8b10

00001804 <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    1804:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    1806:	2300      	movs	r3, #0
    1808:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    180a:	4b29      	ldr	r3, [pc, #164]	; (18b0 <getFircConfig+0xac>)
    180c:	681b      	ldr	r3, [r3, #0]
    180e:	2b00      	cmp	r3, #0
    1810:	d024      	beq.n	185c <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    1812:	2300      	movs	r3, #0
    1814:	9301      	str	r3, [sp, #4]
    1816:	e01a      	b.n	184e <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    1818:	4b25      	ldr	r3, [pc, #148]	; (18b0 <getFircConfig+0xac>)
    181a:	6819      	ldr	r1, [r3, #0]
    181c:	9a01      	ldr	r2, [sp, #4]
    181e:	4613      	mov	r3, r2
    1820:	005b      	lsls	r3, r3, #1
    1822:	4413      	add	r3, r2
    1824:	009b      	lsls	r3, r3, #2
    1826:	440b      	add	r3, r1
    1828:	3314      	adds	r3, #20
    182a:	681b      	ldr	r3, [r3, #0]
    182c:	2b05      	cmp	r3, #5
    182e:	d10b      	bne.n	1848 <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    1830:	4b1f      	ldr	r3, [pc, #124]	; (18b0 <getFircConfig+0xac>)
    1832:	6819      	ldr	r1, [r3, #0]
    1834:	9a01      	ldr	r2, [sp, #4]
    1836:	4613      	mov	r3, r2
    1838:	005b      	lsls	r3, r3, #1
    183a:	4413      	add	r3, r2
    183c:	009b      	lsls	r3, r3, #2
    183e:	3310      	adds	r3, #16
    1840:	440b      	add	r3, r1
    1842:	3304      	adds	r3, #4
    1844:	9300      	str	r3, [sp, #0]
                break;
    1846:	e009      	b.n	185c <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    1848:	9b01      	ldr	r3, [sp, #4]
    184a:	3301      	adds	r3, #1
    184c:	9301      	str	r3, [sp, #4]
    184e:	4b18      	ldr	r3, [pc, #96]	; (18b0 <getFircConfig+0xac>)
    1850:	681b      	ldr	r3, [r3, #0]
    1852:	7a1b      	ldrb	r3, [r3, #8]
    1854:	461a      	mov	r2, r3
    1856:	9b01      	ldr	r3, [sp, #4]
    1858:	4293      	cmp	r3, r2
    185a:	d3dd      	bcc.n	1818 <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    185c:	9b00      	ldr	r3, [sp, #0]
    185e:	2b00      	cmp	r3, #0
    1860:	d121      	bne.n	18a6 <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    1862:	4b14      	ldr	r3, [pc, #80]	; (18b4 <getFircConfig+0xb0>)
    1864:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    1866:	4b13      	ldr	r3, [pc, #76]	; (18b4 <getFircConfig+0xb0>)
    1868:	2205      	movs	r2, #5
    186a:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    186c:	4b12      	ldr	r3, [pc, #72]	; (18b8 <getFircConfig+0xb4>)
    186e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    1872:	b29b      	uxth	r3, r3
    1874:	f003 0301 	and.w	r3, r3, #1
    1878:	b29a      	uxth	r2, r3
    187a:	4b0e      	ldr	r3, [pc, #56]	; (18b4 <getFircConfig+0xb0>)
    187c:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    187e:	4b0e      	ldr	r3, [pc, #56]	; (18b8 <getFircConfig+0xb4>)
    1880:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    1884:	b2db      	uxtb	r3, r3
    1886:	f003 0303 	and.w	r3, r3, #3
    188a:	b2da      	uxtb	r2, r3
    188c:	4b09      	ldr	r3, [pc, #36]	; (18b4 <getFircConfig+0xb0>)
    188e:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    1890:	4b09      	ldr	r3, [pc, #36]	; (18b8 <getFircConfig+0xb4>)
    1892:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    1896:	b2db      	uxtb	r3, r3
    1898:	10db      	asrs	r3, r3, #3
    189a:	b2db      	uxtb	r3, r3
    189c:	f003 0301 	and.w	r3, r3, #1
    18a0:	b2da      	uxtb	r2, r3
    18a2:	4b04      	ldr	r3, [pc, #16]	; (18b4 <getFircConfig+0xb0>)
    18a4:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    18a6:	9b00      	ldr	r3, [sp, #0]
}
    18a8:	4618      	mov	r0, r3
    18aa:	b002      	add	sp, #8
    18ac:	4770      	bx	lr
    18ae:	bf00      	nop
    18b0:	1fff8b64 	.word	0x1fff8b64
    18b4:	1fff8bd0 	.word	0x1fff8bd0
    18b8:	40064000 	.word	0x40064000

000018bc <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    18bc:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    18be:	2300      	movs	r3, #0
    18c0:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    18c2:	4b20      	ldr	r3, [pc, #128]	; (1944 <getSoscConfig+0x88>)
    18c4:	681b      	ldr	r3, [r3, #0]
    18c6:	2b00      	cmp	r3, #0
    18c8:	d024      	beq.n	1914 <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    18ca:	2300      	movs	r3, #0
    18cc:	9301      	str	r3, [sp, #4]
    18ce:	e01a      	b.n	1906 <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    18d0:	4b1c      	ldr	r3, [pc, #112]	; (1944 <getSoscConfig+0x88>)
    18d2:	6819      	ldr	r1, [r3, #0]
    18d4:	9a01      	ldr	r2, [sp, #4]
    18d6:	4613      	mov	r3, r2
    18d8:	009b      	lsls	r3, r3, #2
    18da:	4413      	add	r3, r2
    18dc:	009b      	lsls	r3, r3, #2
    18de:	440b      	add	r3, r1
    18e0:	332c      	adds	r3, #44	; 0x2c
    18e2:	681b      	ldr	r3, [r3, #0]
    18e4:	2b08      	cmp	r3, #8
    18e6:	d10b      	bne.n	1900 <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    18e8:	4b16      	ldr	r3, [pc, #88]	; (1944 <getSoscConfig+0x88>)
    18ea:	6819      	ldr	r1, [r3, #0]
    18ec:	9a01      	ldr	r2, [sp, #4]
    18ee:	4613      	mov	r3, r2
    18f0:	009b      	lsls	r3, r3, #2
    18f2:	4413      	add	r3, r2
    18f4:	009b      	lsls	r3, r3, #2
    18f6:	3328      	adds	r3, #40	; 0x28
    18f8:	440b      	add	r3, r1
    18fa:	3304      	adds	r3, #4
    18fc:	9300      	str	r3, [sp, #0]
                break;
    18fe:	e009      	b.n	1914 <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    1900:	9b01      	ldr	r3, [sp, #4]
    1902:	3301      	adds	r3, #1
    1904:	9301      	str	r3, [sp, #4]
    1906:	4b0f      	ldr	r3, [pc, #60]	; (1944 <getSoscConfig+0x88>)
    1908:	681b      	ldr	r3, [r3, #0]
    190a:	7a5b      	ldrb	r3, [r3, #9]
    190c:	461a      	mov	r2, r3
    190e:	9b01      	ldr	r3, [sp, #4]
    1910:	4293      	cmp	r3, r2
    1912:	d3dd      	bcc.n	18d0 <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    1914:	9b00      	ldr	r3, [sp, #0]
    1916:	2b00      	cmp	r3, #0
    1918:	d110      	bne.n	193c <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    191a:	4b0b      	ldr	r3, [pc, #44]	; (1948 <getSoscConfig+0x8c>)
    191c:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    191e:	4b0a      	ldr	r3, [pc, #40]	; (1948 <getSoscConfig+0x8c>)
    1920:	2208      	movs	r2, #8
    1922:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    1924:	4b09      	ldr	r3, [pc, #36]	; (194c <getSoscConfig+0x90>)
    1926:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    192a:	b29b      	uxth	r3, r3
    192c:	f003 0301 	and.w	r3, r3, #1
    1930:	b29a      	uxth	r2, r3
    1932:	4b05      	ldr	r3, [pc, #20]	; (1948 <getSoscConfig+0x8c>)
    1934:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    1936:	4b04      	ldr	r3, [pc, #16]	; (1948 <getSoscConfig+0x8c>)
    1938:	4a05      	ldr	r2, [pc, #20]	; (1950 <getSoscConfig+0x94>)
    193a:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    193c:	9b00      	ldr	r3, [sp, #0]
}
    193e:	4618      	mov	r0, r3
    1940:	b002      	add	sp, #8
    1942:	4770      	bx	lr
    1944:	1fff8b64 	.word	0x1fff8b64
    1948:	1fff8bdc 	.word	0x1fff8bdc
    194c:	40064000 	.word	0x40064000
    1950:	02625a00 	.word	0x02625a00

00001954 <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    1954:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    1956:	2300      	movs	r3, #0
    1958:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    195a:	4b28      	ldr	r3, [pc, #160]	; (19fc <getSpllConfig+0xa8>)
    195c:	681b      	ldr	r3, [r3, #0]
    195e:	2b00      	cmp	r3, #0
    1960:	d023      	beq.n	19aa <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    1962:	2300      	movs	r3, #0
    1964:	9301      	str	r3, [sp, #4]
    1966:	e019      	b.n	199c <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    1968:	4b24      	ldr	r3, [pc, #144]	; (19fc <getSpllConfig+0xa8>)
    196a:	6819      	ldr	r1, [r3, #0]
    196c:	9a01      	ldr	r2, [sp, #4]
    196e:	4613      	mov	r3, r2
    1970:	009b      	lsls	r3, r3, #2
    1972:	4413      	add	r3, r2
    1974:	00db      	lsls	r3, r3, #3
    1976:	440b      	add	r3, r1
    1978:	3340      	adds	r3, #64	; 0x40
    197a:	681b      	ldr	r3, [r3, #0]
    197c:	2b09      	cmp	r3, #9
    197e:	d10a      	bne.n	1996 <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    1980:	4b1e      	ldr	r3, [pc, #120]	; (19fc <getSpllConfig+0xa8>)
    1982:	6819      	ldr	r1, [r3, #0]
    1984:	9a01      	ldr	r2, [sp, #4]
    1986:	4613      	mov	r3, r2
    1988:	009b      	lsls	r3, r3, #2
    198a:	4413      	add	r3, r2
    198c:	00db      	lsls	r3, r3, #3
    198e:	3340      	adds	r3, #64	; 0x40
    1990:	440b      	add	r3, r1
    1992:	9300      	str	r3, [sp, #0]
                break;
    1994:	e009      	b.n	19aa <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    1996:	9b01      	ldr	r3, [sp, #4]
    1998:	3301      	adds	r3, #1
    199a:	9301      	str	r3, [sp, #4]
    199c:	4b17      	ldr	r3, [pc, #92]	; (19fc <getSpllConfig+0xa8>)
    199e:	681b      	ldr	r3, [r3, #0]
    19a0:	7a9b      	ldrb	r3, [r3, #10]
    19a2:	461a      	mov	r2, r3
    19a4:	9b01      	ldr	r3, [sp, #4]
    19a6:	4293      	cmp	r3, r2
    19a8:	d3de      	bcc.n	1968 <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    19aa:	9b00      	ldr	r3, [sp, #0]
    19ac:	2b00      	cmp	r3, #0
    19ae:	d121      	bne.n	19f4 <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    19b0:	4b13      	ldr	r3, [pc, #76]	; (1a00 <getSpllConfig+0xac>)
    19b2:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    19b4:	4b12      	ldr	r3, [pc, #72]	; (1a00 <getSpllConfig+0xac>)
    19b6:	2209      	movs	r2, #9
    19b8:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    19ba:	4b12      	ldr	r3, [pc, #72]	; (1a04 <getSpllConfig+0xb0>)
    19bc:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    19c0:	b29b      	uxth	r3, r3
    19c2:	f003 0301 	and.w	r3, r3, #1
    19c6:	b29a      	uxth	r2, r3
    19c8:	4b0d      	ldr	r3, [pc, #52]	; (1a00 <getSpllConfig+0xac>)
    19ca:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    19cc:	4b0d      	ldr	r3, [pc, #52]	; (1a04 <getSpllConfig+0xb0>)
    19ce:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    19d2:	0a1b      	lsrs	r3, r3, #8
    19d4:	b2db      	uxtb	r3, r3
    19d6:	f003 0307 	and.w	r3, r3, #7
    19da:	b2da      	uxtb	r2, r3
    19dc:	4b08      	ldr	r3, [pc, #32]	; (1a00 <getSpllConfig+0xac>)
    19de:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    19e0:	4b08      	ldr	r3, [pc, #32]	; (1a04 <getSpllConfig+0xb0>)
    19e2:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    19e6:	0c1b      	lsrs	r3, r3, #16
    19e8:	b2db      	uxtb	r3, r3
    19ea:	f003 031f 	and.w	r3, r3, #31
    19ee:	b2da      	uxtb	r2, r3
    19f0:	4b03      	ldr	r3, [pc, #12]	; (1a00 <getSpllConfig+0xac>)
    19f2:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    19f4:	9b00      	ldr	r3, [sp, #0]
}
    19f6:	4618      	mov	r0, r3
    19f8:	b002      	add	sp, #8
    19fa:	4770      	bx	lr
    19fc:	1fff8b64 	.word	0x1fff8b64
    1a00:	1fff8bf0 	.word	0x1fff8bf0
    1a04:	40064000 	.word	0x40064000

00001a08 <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    1a08:	b086      	sub	sp, #24
    1a0a:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    1a0c:	2300      	movs	r3, #0
    1a0e:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    1a10:	9b01      	ldr	r3, [sp, #4]
    1a12:	2b1b      	cmp	r3, #27
    1a14:	d00f      	beq.n	1a36 <getSelectorConfig+0x2e>
    1a16:	9b01      	ldr	r3, [sp, #4]
    1a18:	2b1b      	cmp	r3, #27
    1a1a:	d80f      	bhi.n	1a3c <getSelectorConfig+0x34>
    1a1c:	9b01      	ldr	r3, [sp, #4]
    1a1e:	2b19      	cmp	r3, #25
    1a20:	d003      	beq.n	1a2a <getSelectorConfig+0x22>
    1a22:	9b01      	ldr	r3, [sp, #4]
    1a24:	2b1a      	cmp	r3, #26
    1a26:	d003      	beq.n	1a30 <getSelectorConfig+0x28>
    1a28:	e008      	b.n	1a3c <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    1a2a:	2300      	movs	r3, #0
    1a2c:	9304      	str	r3, [sp, #16]
            break;
    1a2e:	e008      	b.n	1a42 <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    1a30:	2301      	movs	r3, #1
    1a32:	9304      	str	r3, [sp, #16]
            break;
    1a34:	e005      	b.n	1a42 <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    1a36:	2302      	movs	r3, #2
    1a38:	9304      	str	r3, [sp, #16]
            break;
    1a3a:	e002      	b.n	1a42 <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    1a3c:	2300      	movs	r3, #0
    1a3e:	9304      	str	r3, [sp, #16]
            break;
    1a40:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    1a42:	4b36      	ldr	r3, [pc, #216]	; (1b1c <getSelectorConfig+0x114>)
    1a44:	681b      	ldr	r3, [r3, #0]
    1a46:	2b00      	cmp	r3, #0
    1a48:	d01d      	beq.n	1a86 <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    1a4a:	2300      	movs	r3, #0
    1a4c:	9303      	str	r3, [sp, #12]
    1a4e:	e013      	b.n	1a78 <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    1a50:	4b32      	ldr	r3, [pc, #200]	; (1b1c <getSelectorConfig+0x114>)
    1a52:	681b      	ldr	r3, [r3, #0]
    1a54:	9a03      	ldr	r2, [sp, #12]
    1a56:	320d      	adds	r2, #13
    1a58:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    1a5c:	9a01      	ldr	r2, [sp, #4]
    1a5e:	429a      	cmp	r2, r3
    1a60:	d107      	bne.n	1a72 <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    1a62:	4b2e      	ldr	r3, [pc, #184]	; (1b1c <getSelectorConfig+0x114>)
    1a64:	681a      	ldr	r2, [r3, #0]
    1a66:	9b03      	ldr	r3, [sp, #12]
    1a68:	330d      	adds	r3, #13
    1a6a:	00db      	lsls	r3, r3, #3
    1a6c:	4413      	add	r3, r2
    1a6e:	9305      	str	r3, [sp, #20]
                break;
    1a70:	e009      	b.n	1a86 <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    1a72:	9b03      	ldr	r3, [sp, #12]
    1a74:	3301      	adds	r3, #1
    1a76:	9303      	str	r3, [sp, #12]
    1a78:	4b28      	ldr	r3, [pc, #160]	; (1b1c <getSelectorConfig+0x114>)
    1a7a:	681b      	ldr	r3, [r3, #0]
    1a7c:	7adb      	ldrb	r3, [r3, #11]
    1a7e:	461a      	mov	r2, r3
    1a80:	9b03      	ldr	r3, [sp, #12]
    1a82:	4293      	cmp	r3, r2
    1a84:	d3e4      	bcc.n	1a50 <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    1a86:	9b05      	ldr	r3, [sp, #20]
    1a88:	2b00      	cmp	r3, #0
    1a8a:	d140      	bne.n	1b0e <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    1a8c:	9b04      	ldr	r3, [sp, #16]
    1a8e:	00db      	lsls	r3, r3, #3
    1a90:	4a23      	ldr	r2, [pc, #140]	; (1b20 <getSelectorConfig+0x118>)
    1a92:	4413      	add	r3, r2
    1a94:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    1a96:	4922      	ldr	r1, [pc, #136]	; (1b20 <getSelectorConfig+0x118>)
    1a98:	9b04      	ldr	r3, [sp, #16]
    1a9a:	9a01      	ldr	r2, [sp, #4]
    1a9c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    1aa0:	9b01      	ldr	r3, [sp, #4]
    1aa2:	2b1b      	cmp	r3, #27
    1aa4:	d025      	beq.n	1af2 <getSelectorConfig+0xea>
    1aa6:	9b01      	ldr	r3, [sp, #4]
    1aa8:	2b1b      	cmp	r3, #27
    1aaa:	d832      	bhi.n	1b12 <getSelectorConfig+0x10a>
    1aac:	9b01      	ldr	r3, [sp, #4]
    1aae:	2b19      	cmp	r3, #25
    1ab0:	d003      	beq.n	1aba <getSelectorConfig+0xb2>
    1ab2:	9b01      	ldr	r3, [sp, #4]
    1ab4:	2b1a      	cmp	r3, #26
    1ab6:	d00e      	beq.n	1ad6 <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    1ab8:	e02b      	b.n	1b12 <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    1aba:	4b1a      	ldr	r3, [pc, #104]	; (1b24 <getSelectorConfig+0x11c>)
    1abc:	695b      	ldr	r3, [r3, #20]
    1abe:	0e1b      	lsrs	r3, r3, #24
    1ac0:	f003 030f 	and.w	r3, r3, #15
    1ac4:	4a18      	ldr	r2, [pc, #96]	; (1b28 <getSelectorConfig+0x120>)
    1ac6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1aca:	4915      	ldr	r1, [pc, #84]	; (1b20 <getSelectorConfig+0x118>)
    1acc:	9b04      	ldr	r3, [sp, #16]
    1ace:	00db      	lsls	r3, r3, #3
    1ad0:	440b      	add	r3, r1
    1ad2:	605a      	str	r2, [r3, #4]
                break;
    1ad4:	e01e      	b.n	1b14 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    1ad6:	4b13      	ldr	r3, [pc, #76]	; (1b24 <getSelectorConfig+0x11c>)
    1ad8:	699b      	ldr	r3, [r3, #24]
    1ada:	0e1b      	lsrs	r3, r3, #24
    1adc:	f003 030f 	and.w	r3, r3, #15
    1ae0:	4a11      	ldr	r2, [pc, #68]	; (1b28 <getSelectorConfig+0x120>)
    1ae2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1ae6:	490e      	ldr	r1, [pc, #56]	; (1b20 <getSelectorConfig+0x118>)
    1ae8:	9b04      	ldr	r3, [sp, #16]
    1aea:	00db      	lsls	r3, r3, #3
    1aec:	440b      	add	r3, r1
    1aee:	605a      	str	r2, [r3, #4]
                break;
    1af0:	e010      	b.n	1b14 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    1af2:	4b0c      	ldr	r3, [pc, #48]	; (1b24 <getSelectorConfig+0x11c>)
    1af4:	69db      	ldr	r3, [r3, #28]
    1af6:	0e1b      	lsrs	r3, r3, #24
    1af8:	f003 030f 	and.w	r3, r3, #15
    1afc:	4a0a      	ldr	r2, [pc, #40]	; (1b28 <getSelectorConfig+0x120>)
    1afe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    1b02:	4907      	ldr	r1, [pc, #28]	; (1b20 <getSelectorConfig+0x118>)
    1b04:	9b04      	ldr	r3, [sp, #16]
    1b06:	00db      	lsls	r3, r3, #3
    1b08:	440b      	add	r3, r1
    1b0a:	605a      	str	r2, [r3, #4]
                break;
    1b0c:	e002      	b.n	1b14 <getSelectorConfig+0x10c>
        }
    }
    1b0e:	bf00      	nop
    1b10:	e000      	b.n	1b14 <getSelectorConfig+0x10c>
                break;
    1b12:	bf00      	nop

    return ReturnValue;
    1b14:	9b05      	ldr	r3, [sp, #20]
}
    1b16:	4618      	mov	r0, r3
    1b18:	b006      	add	sp, #24
    1b1a:	4770      	bx	lr
    1b1c:	1fff8b64 	.word	0x1fff8b64
    1b20:	1fff8c18 	.word	0x1fff8c18
    1b24:	40064000 	.word	0x40064000
    1b28:	0000ac00 	.word	0x0000ac00

00001b2c <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    1b2c:	b086      	sub	sp, #24
    1b2e:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    1b30:	2300      	movs	r3, #0
    1b32:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    1b34:	2300      	movs	r3, #0
    1b36:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    1b38:	9b01      	ldr	r3, [sp, #4]
    1b3a:	2b1f      	cmp	r3, #31
    1b3c:	d00f      	beq.n	1b5e <getCoreDividerConfig+0x32>
    1b3e:	9b01      	ldr	r3, [sp, #4]
    1b40:	2b1f      	cmp	r3, #31
    1b42:	d80f      	bhi.n	1b64 <getCoreDividerConfig+0x38>
    1b44:	9b01      	ldr	r3, [sp, #4]
    1b46:	2b1d      	cmp	r3, #29
    1b48:	d003      	beq.n	1b52 <getCoreDividerConfig+0x26>
    1b4a:	9b01      	ldr	r3, [sp, #4]
    1b4c:	2b1e      	cmp	r3, #30
    1b4e:	d003      	beq.n	1b58 <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    1b50:	e008      	b.n	1b64 <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    1b52:	2300      	movs	r3, #0
    1b54:	9304      	str	r3, [sp, #16]
            break;
    1b56:	e006      	b.n	1b66 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    1b58:	2301      	movs	r3, #1
    1b5a:	9304      	str	r3, [sp, #16]
            break;
    1b5c:	e003      	b.n	1b66 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    1b5e:	2302      	movs	r3, #2
    1b60:	9304      	str	r3, [sp, #16]
            break;
    1b62:	e000      	b.n	1b66 <getCoreDividerConfig+0x3a>
                break;
    1b64:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    1b66:	4b41      	ldr	r3, [pc, #260]	; (1c6c <getCoreDividerConfig+0x140>)
    1b68:	681b      	ldr	r3, [r3, #0]
    1b6a:	2b00      	cmp	r3, #0
    1b6c:	d026      	beq.n	1bbc <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    1b6e:	2300      	movs	r3, #0
    1b70:	9303      	str	r3, [sp, #12]
    1b72:	e01c      	b.n	1bae <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    1b74:	4b3d      	ldr	r3, [pc, #244]	; (1c6c <getCoreDividerConfig+0x140>)
    1b76:	6819      	ldr	r1, [r3, #0]
    1b78:	9a03      	ldr	r2, [sp, #12]
    1b7a:	4613      	mov	r3, r2
    1b7c:	005b      	lsls	r3, r3, #1
    1b7e:	4413      	add	r3, r2
    1b80:	009b      	lsls	r3, r3, #2
    1b82:	440b      	add	r3, r1
    1b84:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    1b88:	681b      	ldr	r3, [r3, #0]
    1b8a:	9a01      	ldr	r2, [sp, #4]
    1b8c:	429a      	cmp	r2, r3
    1b8e:	d10b      	bne.n	1ba8 <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    1b90:	4b36      	ldr	r3, [pc, #216]	; (1c6c <getCoreDividerConfig+0x140>)
    1b92:	6819      	ldr	r1, [r3, #0]
    1b94:	9a03      	ldr	r2, [sp, #12]
    1b96:	4613      	mov	r3, r2
    1b98:	005b      	lsls	r3, r3, #1
    1b9a:	4413      	add	r3, r2
    1b9c:	009b      	lsls	r3, r3, #2
    1b9e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    1ba2:	440b      	add	r3, r1
    1ba4:	9305      	str	r3, [sp, #20]
                break;
    1ba6:	e009      	b.n	1bbc <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    1ba8:	9b03      	ldr	r3, [sp, #12]
    1baa:	3301      	adds	r3, #1
    1bac:	9303      	str	r3, [sp, #12]
    1bae:	4b2f      	ldr	r3, [pc, #188]	; (1c6c <getCoreDividerConfig+0x140>)
    1bb0:	681b      	ldr	r3, [r3, #0]
    1bb2:	7b1b      	ldrb	r3, [r3, #12]
    1bb4:	461a      	mov	r2, r3
    1bb6:	9b03      	ldr	r3, [sp, #12]
    1bb8:	4293      	cmp	r3, r2
    1bba:	d3db      	bcc.n	1b74 <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    1bbc:	9b05      	ldr	r3, [sp, #20]
    1bbe:	2b00      	cmp	r3, #0
    1bc0:	d14d      	bne.n	1c5e <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    1bc2:	9a04      	ldr	r2, [sp, #16]
    1bc4:	4613      	mov	r3, r2
    1bc6:	005b      	lsls	r3, r3, #1
    1bc8:	4413      	add	r3, r2
    1bca:	009b      	lsls	r3, r3, #2
    1bcc:	4a28      	ldr	r2, [pc, #160]	; (1c70 <getCoreDividerConfig+0x144>)
    1bce:	4413      	add	r3, r2
    1bd0:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    1bd2:	4927      	ldr	r1, [pc, #156]	; (1c70 <getCoreDividerConfig+0x144>)
    1bd4:	9a04      	ldr	r2, [sp, #16]
    1bd6:	4613      	mov	r3, r2
    1bd8:	005b      	lsls	r3, r3, #1
    1bda:	4413      	add	r3, r2
    1bdc:	009b      	lsls	r3, r3, #2
    1bde:	440b      	add	r3, r1
    1be0:	9a01      	ldr	r2, [sp, #4]
    1be2:	601a      	str	r2, [r3, #0]
        switch(Name)
    1be4:	9b01      	ldr	r3, [sp, #4]
    1be6:	2b1f      	cmp	r3, #31
    1be8:	d029      	beq.n	1c3e <getCoreDividerConfig+0x112>
    1bea:	9b01      	ldr	r3, [sp, #4]
    1bec:	2b1f      	cmp	r3, #31
    1bee:	d838      	bhi.n	1c62 <getCoreDividerConfig+0x136>
    1bf0:	9b01      	ldr	r3, [sp, #4]
    1bf2:	2b1d      	cmp	r3, #29
    1bf4:	d003      	beq.n	1bfe <getCoreDividerConfig+0xd2>
    1bf6:	9b01      	ldr	r3, [sp, #4]
    1bf8:	2b1e      	cmp	r3, #30
    1bfa:	d010      	beq.n	1c1e <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    1bfc:	e031      	b.n	1c62 <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    1bfe:	4b1d      	ldr	r3, [pc, #116]	; (1c74 <getCoreDividerConfig+0x148>)
    1c00:	695b      	ldr	r3, [r3, #20]
    1c02:	0c1b      	lsrs	r3, r3, #16
    1c04:	f003 030f 	and.w	r3, r3, #15
    1c08:	1c59      	adds	r1, r3, #1
    1c0a:	4819      	ldr	r0, [pc, #100]	; (1c70 <getCoreDividerConfig+0x144>)
    1c0c:	9a04      	ldr	r2, [sp, #16]
    1c0e:	4613      	mov	r3, r2
    1c10:	005b      	lsls	r3, r3, #1
    1c12:	4413      	add	r3, r2
    1c14:	009b      	lsls	r3, r3, #2
    1c16:	4403      	add	r3, r0
    1c18:	3304      	adds	r3, #4
    1c1a:	6019      	str	r1, [r3, #0]
                break;
    1c1c:	e022      	b.n	1c64 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    1c1e:	4b15      	ldr	r3, [pc, #84]	; (1c74 <getCoreDividerConfig+0x148>)
    1c20:	699b      	ldr	r3, [r3, #24]
    1c22:	0c1b      	lsrs	r3, r3, #16
    1c24:	f003 030f 	and.w	r3, r3, #15
    1c28:	1c59      	adds	r1, r3, #1
    1c2a:	4811      	ldr	r0, [pc, #68]	; (1c70 <getCoreDividerConfig+0x144>)
    1c2c:	9a04      	ldr	r2, [sp, #16]
    1c2e:	4613      	mov	r3, r2
    1c30:	005b      	lsls	r3, r3, #1
    1c32:	4413      	add	r3, r2
    1c34:	009b      	lsls	r3, r3, #2
    1c36:	4403      	add	r3, r0
    1c38:	3304      	adds	r3, #4
    1c3a:	6019      	str	r1, [r3, #0]
                break;
    1c3c:	e012      	b.n	1c64 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    1c3e:	4b0d      	ldr	r3, [pc, #52]	; (1c74 <getCoreDividerConfig+0x148>)
    1c40:	69db      	ldr	r3, [r3, #28]
    1c42:	0c1b      	lsrs	r3, r3, #16
    1c44:	f003 030f 	and.w	r3, r3, #15
    1c48:	1c59      	adds	r1, r3, #1
    1c4a:	4809      	ldr	r0, [pc, #36]	; (1c70 <getCoreDividerConfig+0x144>)
    1c4c:	9a04      	ldr	r2, [sp, #16]
    1c4e:	4613      	mov	r3, r2
    1c50:	005b      	lsls	r3, r3, #1
    1c52:	4413      	add	r3, r2
    1c54:	009b      	lsls	r3, r3, #2
    1c56:	4403      	add	r3, r0
    1c58:	3304      	adds	r3, #4
    1c5a:	6019      	str	r1, [r3, #0]
                break;
    1c5c:	e002      	b.n	1c64 <getCoreDividerConfig+0x138>
        }
    }
    1c5e:	bf00      	nop
    1c60:	e000      	b.n	1c64 <getCoreDividerConfig+0x138>
                break;
    1c62:	bf00      	nop

    return ReturnValue;
    1c64:	9b05      	ldr	r3, [sp, #20]
}
    1c66:	4618      	mov	r0, r3
    1c68:	b006      	add	sp, #24
    1c6a:	4770      	bx	lr
    1c6c:	1fff8b64 	.word	0x1fff8b64
    1c70:	1fff8c30 	.word	0x1fff8c30
    1c74:	40064000 	.word	0x40064000

00001c78 <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    1c78:	b086      	sub	sp, #24
    1c7a:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    1c7c:	2300      	movs	r3, #0
    1c7e:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    1c80:	2300      	movs	r3, #0
    1c82:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    1c84:	9b01      	ldr	r3, [sp, #4]
    1c86:	2b23      	cmp	r3, #35	; 0x23
    1c88:	d00f      	beq.n	1caa <getBusDividerConfig+0x32>
    1c8a:	9b01      	ldr	r3, [sp, #4]
    1c8c:	2b23      	cmp	r3, #35	; 0x23
    1c8e:	d80f      	bhi.n	1cb0 <getBusDividerConfig+0x38>
    1c90:	9b01      	ldr	r3, [sp, #4]
    1c92:	2b21      	cmp	r3, #33	; 0x21
    1c94:	d003      	beq.n	1c9e <getBusDividerConfig+0x26>
    1c96:	9b01      	ldr	r3, [sp, #4]
    1c98:	2b22      	cmp	r3, #34	; 0x22
    1c9a:	d003      	beq.n	1ca4 <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    1c9c:	e008      	b.n	1cb0 <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    1c9e:	2300      	movs	r3, #0
    1ca0:	9304      	str	r3, [sp, #16]
            break;
    1ca2:	e006      	b.n	1cb2 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    1ca4:	2301      	movs	r3, #1
    1ca6:	9304      	str	r3, [sp, #16]
            break;
    1ca8:	e003      	b.n	1cb2 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    1caa:	2302      	movs	r3, #2
    1cac:	9304      	str	r3, [sp, #16]
            break;
    1cae:	e000      	b.n	1cb2 <getBusDividerConfig+0x3a>
                break;
    1cb0:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    1cb2:	4b41      	ldr	r3, [pc, #260]	; (1db8 <getBusDividerConfig+0x140>)
    1cb4:	681b      	ldr	r3, [r3, #0]
    1cb6:	2b00      	cmp	r3, #0
    1cb8:	d026      	beq.n	1d08 <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    1cba:	2300      	movs	r3, #0
    1cbc:	9303      	str	r3, [sp, #12]
    1cbe:	e01c      	b.n	1cfa <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    1cc0:	4b3d      	ldr	r3, [pc, #244]	; (1db8 <getBusDividerConfig+0x140>)
    1cc2:	6819      	ldr	r1, [r3, #0]
    1cc4:	9a03      	ldr	r2, [sp, #12]
    1cc6:	4613      	mov	r3, r2
    1cc8:	005b      	lsls	r3, r3, #1
    1cca:	4413      	add	r3, r2
    1ccc:	009b      	lsls	r3, r3, #2
    1cce:	440b      	add	r3, r1
    1cd0:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    1cd4:	681b      	ldr	r3, [r3, #0]
    1cd6:	9a01      	ldr	r2, [sp, #4]
    1cd8:	429a      	cmp	r2, r3
    1cda:	d10b      	bne.n	1cf4 <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    1cdc:	4b36      	ldr	r3, [pc, #216]	; (1db8 <getBusDividerConfig+0x140>)
    1cde:	6819      	ldr	r1, [r3, #0]
    1ce0:	9a03      	ldr	r2, [sp, #12]
    1ce2:	4613      	mov	r3, r2
    1ce4:	005b      	lsls	r3, r3, #1
    1ce6:	4413      	add	r3, r2
    1ce8:	009b      	lsls	r3, r3, #2
    1cea:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    1cee:	440b      	add	r3, r1
    1cf0:	9305      	str	r3, [sp, #20]
                break;
    1cf2:	e009      	b.n	1d08 <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    1cf4:	9b03      	ldr	r3, [sp, #12]
    1cf6:	3301      	adds	r3, #1
    1cf8:	9303      	str	r3, [sp, #12]
    1cfa:	4b2f      	ldr	r3, [pc, #188]	; (1db8 <getBusDividerConfig+0x140>)
    1cfc:	681b      	ldr	r3, [r3, #0]
    1cfe:	7b1b      	ldrb	r3, [r3, #12]
    1d00:	461a      	mov	r2, r3
    1d02:	9b03      	ldr	r3, [sp, #12]
    1d04:	4293      	cmp	r3, r2
    1d06:	d3db      	bcc.n	1cc0 <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    1d08:	9b05      	ldr	r3, [sp, #20]
    1d0a:	2b00      	cmp	r3, #0
    1d0c:	d14d      	bne.n	1daa <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    1d0e:	9a04      	ldr	r2, [sp, #16]
    1d10:	4613      	mov	r3, r2
    1d12:	005b      	lsls	r3, r3, #1
    1d14:	4413      	add	r3, r2
    1d16:	009b      	lsls	r3, r3, #2
    1d18:	4a28      	ldr	r2, [pc, #160]	; (1dbc <getBusDividerConfig+0x144>)
    1d1a:	4413      	add	r3, r2
    1d1c:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    1d1e:	4927      	ldr	r1, [pc, #156]	; (1dbc <getBusDividerConfig+0x144>)
    1d20:	9a04      	ldr	r2, [sp, #16]
    1d22:	4613      	mov	r3, r2
    1d24:	005b      	lsls	r3, r3, #1
    1d26:	4413      	add	r3, r2
    1d28:	009b      	lsls	r3, r3, #2
    1d2a:	440b      	add	r3, r1
    1d2c:	9a01      	ldr	r2, [sp, #4]
    1d2e:	601a      	str	r2, [r3, #0]
        switch(Name)
    1d30:	9b01      	ldr	r3, [sp, #4]
    1d32:	2b23      	cmp	r3, #35	; 0x23
    1d34:	d029      	beq.n	1d8a <getBusDividerConfig+0x112>
    1d36:	9b01      	ldr	r3, [sp, #4]
    1d38:	2b23      	cmp	r3, #35	; 0x23
    1d3a:	d838      	bhi.n	1dae <getBusDividerConfig+0x136>
    1d3c:	9b01      	ldr	r3, [sp, #4]
    1d3e:	2b21      	cmp	r3, #33	; 0x21
    1d40:	d003      	beq.n	1d4a <getBusDividerConfig+0xd2>
    1d42:	9b01      	ldr	r3, [sp, #4]
    1d44:	2b22      	cmp	r3, #34	; 0x22
    1d46:	d010      	beq.n	1d6a <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    1d48:	e031      	b.n	1dae <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    1d4a:	4b1d      	ldr	r3, [pc, #116]	; (1dc0 <getBusDividerConfig+0x148>)
    1d4c:	695b      	ldr	r3, [r3, #20]
    1d4e:	091b      	lsrs	r3, r3, #4
    1d50:	f003 030f 	and.w	r3, r3, #15
    1d54:	1c59      	adds	r1, r3, #1
    1d56:	4819      	ldr	r0, [pc, #100]	; (1dbc <getBusDividerConfig+0x144>)
    1d58:	9a04      	ldr	r2, [sp, #16]
    1d5a:	4613      	mov	r3, r2
    1d5c:	005b      	lsls	r3, r3, #1
    1d5e:	4413      	add	r3, r2
    1d60:	009b      	lsls	r3, r3, #2
    1d62:	4403      	add	r3, r0
    1d64:	3304      	adds	r3, #4
    1d66:	6019      	str	r1, [r3, #0]
                break;
    1d68:	e022      	b.n	1db0 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    1d6a:	4b15      	ldr	r3, [pc, #84]	; (1dc0 <getBusDividerConfig+0x148>)
    1d6c:	699b      	ldr	r3, [r3, #24]
    1d6e:	091b      	lsrs	r3, r3, #4
    1d70:	f003 030f 	and.w	r3, r3, #15
    1d74:	1c59      	adds	r1, r3, #1
    1d76:	4811      	ldr	r0, [pc, #68]	; (1dbc <getBusDividerConfig+0x144>)
    1d78:	9a04      	ldr	r2, [sp, #16]
    1d7a:	4613      	mov	r3, r2
    1d7c:	005b      	lsls	r3, r3, #1
    1d7e:	4413      	add	r3, r2
    1d80:	009b      	lsls	r3, r3, #2
    1d82:	4403      	add	r3, r0
    1d84:	3304      	adds	r3, #4
    1d86:	6019      	str	r1, [r3, #0]
                break;
    1d88:	e012      	b.n	1db0 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    1d8a:	4b0d      	ldr	r3, [pc, #52]	; (1dc0 <getBusDividerConfig+0x148>)
    1d8c:	69db      	ldr	r3, [r3, #28]
    1d8e:	091b      	lsrs	r3, r3, #4
    1d90:	f003 030f 	and.w	r3, r3, #15
    1d94:	1c59      	adds	r1, r3, #1
    1d96:	4809      	ldr	r0, [pc, #36]	; (1dbc <getBusDividerConfig+0x144>)
    1d98:	9a04      	ldr	r2, [sp, #16]
    1d9a:	4613      	mov	r3, r2
    1d9c:	005b      	lsls	r3, r3, #1
    1d9e:	4413      	add	r3, r2
    1da0:	009b      	lsls	r3, r3, #2
    1da2:	4403      	add	r3, r0
    1da4:	3304      	adds	r3, #4
    1da6:	6019      	str	r1, [r3, #0]
                break;
    1da8:	e002      	b.n	1db0 <getBusDividerConfig+0x138>
        }
    }
    1daa:	bf00      	nop
    1dac:	e000      	b.n	1db0 <getBusDividerConfig+0x138>
                break;
    1dae:	bf00      	nop

    return ReturnValue;
    1db0:	9b05      	ldr	r3, [sp, #20]
}
    1db2:	4618      	mov	r0, r3
    1db4:	b006      	add	sp, #24
    1db6:	4770      	bx	lr
    1db8:	1fff8b64 	.word	0x1fff8b64
    1dbc:	1fff8c54 	.word	0x1fff8c54
    1dc0:	40064000 	.word	0x40064000

00001dc4 <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    1dc4:	b086      	sub	sp, #24
    1dc6:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    1dc8:	2300      	movs	r3, #0
    1dca:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    1dcc:	2300      	movs	r3, #0
    1dce:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    1dd0:	9b01      	ldr	r3, [sp, #4]
    1dd2:	2b27      	cmp	r3, #39	; 0x27
    1dd4:	d00f      	beq.n	1df6 <getSlowDividerConfig+0x32>
    1dd6:	9b01      	ldr	r3, [sp, #4]
    1dd8:	2b27      	cmp	r3, #39	; 0x27
    1dda:	d80f      	bhi.n	1dfc <getSlowDividerConfig+0x38>
    1ddc:	9b01      	ldr	r3, [sp, #4]
    1dde:	2b25      	cmp	r3, #37	; 0x25
    1de0:	d003      	beq.n	1dea <getSlowDividerConfig+0x26>
    1de2:	9b01      	ldr	r3, [sp, #4]
    1de4:	2b26      	cmp	r3, #38	; 0x26
    1de6:	d003      	beq.n	1df0 <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    1de8:	e008      	b.n	1dfc <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    1dea:	2300      	movs	r3, #0
    1dec:	9304      	str	r3, [sp, #16]
            break;
    1dee:	e006      	b.n	1dfe <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    1df0:	2301      	movs	r3, #1
    1df2:	9304      	str	r3, [sp, #16]
            break;
    1df4:	e003      	b.n	1dfe <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    1df6:	2302      	movs	r3, #2
    1df8:	9304      	str	r3, [sp, #16]
            break;
    1dfa:	e000      	b.n	1dfe <getSlowDividerConfig+0x3a>
                break;
    1dfc:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    1dfe:	4b40      	ldr	r3, [pc, #256]	; (1f00 <getSlowDividerConfig+0x13c>)
    1e00:	681b      	ldr	r3, [r3, #0]
    1e02:	2b00      	cmp	r3, #0
    1e04:	d026      	beq.n	1e54 <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    1e06:	2300      	movs	r3, #0
    1e08:	9303      	str	r3, [sp, #12]
    1e0a:	e01c      	b.n	1e46 <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    1e0c:	4b3c      	ldr	r3, [pc, #240]	; (1f00 <getSlowDividerConfig+0x13c>)
    1e0e:	6819      	ldr	r1, [r3, #0]
    1e10:	9a03      	ldr	r2, [sp, #12]
    1e12:	4613      	mov	r3, r2
    1e14:	005b      	lsls	r3, r3, #1
    1e16:	4413      	add	r3, r2
    1e18:	009b      	lsls	r3, r3, #2
    1e1a:	440b      	add	r3, r1
    1e1c:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    1e20:	681b      	ldr	r3, [r3, #0]
    1e22:	9a01      	ldr	r2, [sp, #4]
    1e24:	429a      	cmp	r2, r3
    1e26:	d10b      	bne.n	1e40 <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    1e28:	4b35      	ldr	r3, [pc, #212]	; (1f00 <getSlowDividerConfig+0x13c>)
    1e2a:	6819      	ldr	r1, [r3, #0]
    1e2c:	9a03      	ldr	r2, [sp, #12]
    1e2e:	4613      	mov	r3, r2
    1e30:	005b      	lsls	r3, r3, #1
    1e32:	4413      	add	r3, r2
    1e34:	009b      	lsls	r3, r3, #2
    1e36:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    1e3a:	440b      	add	r3, r1
    1e3c:	9305      	str	r3, [sp, #20]
                break;
    1e3e:	e009      	b.n	1e54 <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    1e40:	9b03      	ldr	r3, [sp, #12]
    1e42:	3301      	adds	r3, #1
    1e44:	9303      	str	r3, [sp, #12]
    1e46:	4b2e      	ldr	r3, [pc, #184]	; (1f00 <getSlowDividerConfig+0x13c>)
    1e48:	681b      	ldr	r3, [r3, #0]
    1e4a:	7b1b      	ldrb	r3, [r3, #12]
    1e4c:	461a      	mov	r2, r3
    1e4e:	9b03      	ldr	r3, [sp, #12]
    1e50:	4293      	cmp	r3, r2
    1e52:	d3db      	bcc.n	1e0c <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    1e54:	9b05      	ldr	r3, [sp, #20]
    1e56:	2b00      	cmp	r3, #0
    1e58:	d14a      	bne.n	1ef0 <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    1e5a:	9a04      	ldr	r2, [sp, #16]
    1e5c:	4613      	mov	r3, r2
    1e5e:	005b      	lsls	r3, r3, #1
    1e60:	4413      	add	r3, r2
    1e62:	009b      	lsls	r3, r3, #2
    1e64:	4a27      	ldr	r2, [pc, #156]	; (1f04 <getSlowDividerConfig+0x140>)
    1e66:	4413      	add	r3, r2
    1e68:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    1e6a:	4926      	ldr	r1, [pc, #152]	; (1f04 <getSlowDividerConfig+0x140>)
    1e6c:	9a04      	ldr	r2, [sp, #16]
    1e6e:	4613      	mov	r3, r2
    1e70:	005b      	lsls	r3, r3, #1
    1e72:	4413      	add	r3, r2
    1e74:	009b      	lsls	r3, r3, #2
    1e76:	440b      	add	r3, r1
    1e78:	9a01      	ldr	r2, [sp, #4]
    1e7a:	601a      	str	r2, [r3, #0]
        switch(Name)
    1e7c:	9b01      	ldr	r3, [sp, #4]
    1e7e:	2b27      	cmp	r3, #39	; 0x27
    1e80:	d027      	beq.n	1ed2 <getSlowDividerConfig+0x10e>
    1e82:	9b01      	ldr	r3, [sp, #4]
    1e84:	2b27      	cmp	r3, #39	; 0x27
    1e86:	d835      	bhi.n	1ef4 <getSlowDividerConfig+0x130>
    1e88:	9b01      	ldr	r3, [sp, #4]
    1e8a:	2b25      	cmp	r3, #37	; 0x25
    1e8c:	d003      	beq.n	1e96 <getSlowDividerConfig+0xd2>
    1e8e:	9b01      	ldr	r3, [sp, #4]
    1e90:	2b26      	cmp	r3, #38	; 0x26
    1e92:	d00f      	beq.n	1eb4 <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    1e94:	e02e      	b.n	1ef4 <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    1e96:	4b1c      	ldr	r3, [pc, #112]	; (1f08 <getSlowDividerConfig+0x144>)
    1e98:	695b      	ldr	r3, [r3, #20]
    1e9a:	f003 030f 	and.w	r3, r3, #15
    1e9e:	1c59      	adds	r1, r3, #1
    1ea0:	4818      	ldr	r0, [pc, #96]	; (1f04 <getSlowDividerConfig+0x140>)
    1ea2:	9a04      	ldr	r2, [sp, #16]
    1ea4:	4613      	mov	r3, r2
    1ea6:	005b      	lsls	r3, r3, #1
    1ea8:	4413      	add	r3, r2
    1eaa:	009b      	lsls	r3, r3, #2
    1eac:	4403      	add	r3, r0
    1eae:	3304      	adds	r3, #4
    1eb0:	6019      	str	r1, [r3, #0]
                break;
    1eb2:	e020      	b.n	1ef6 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    1eb4:	4b14      	ldr	r3, [pc, #80]	; (1f08 <getSlowDividerConfig+0x144>)
    1eb6:	699b      	ldr	r3, [r3, #24]
    1eb8:	f003 030f 	and.w	r3, r3, #15
    1ebc:	1c59      	adds	r1, r3, #1
    1ebe:	4811      	ldr	r0, [pc, #68]	; (1f04 <getSlowDividerConfig+0x140>)
    1ec0:	9a04      	ldr	r2, [sp, #16]
    1ec2:	4613      	mov	r3, r2
    1ec4:	005b      	lsls	r3, r3, #1
    1ec6:	4413      	add	r3, r2
    1ec8:	009b      	lsls	r3, r3, #2
    1eca:	4403      	add	r3, r0
    1ecc:	3304      	adds	r3, #4
    1ece:	6019      	str	r1, [r3, #0]
                break;
    1ed0:	e011      	b.n	1ef6 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    1ed2:	4b0d      	ldr	r3, [pc, #52]	; (1f08 <getSlowDividerConfig+0x144>)
    1ed4:	69db      	ldr	r3, [r3, #28]
    1ed6:	f003 030f 	and.w	r3, r3, #15
    1eda:	1c59      	adds	r1, r3, #1
    1edc:	4809      	ldr	r0, [pc, #36]	; (1f04 <getSlowDividerConfig+0x140>)
    1ede:	9a04      	ldr	r2, [sp, #16]
    1ee0:	4613      	mov	r3, r2
    1ee2:	005b      	lsls	r3, r3, #1
    1ee4:	4413      	add	r3, r2
    1ee6:	009b      	lsls	r3, r3, #2
    1ee8:	4403      	add	r3, r0
    1eea:	3304      	adds	r3, #4
    1eec:	6019      	str	r1, [r3, #0]
                break;
    1eee:	e002      	b.n	1ef6 <getSlowDividerConfig+0x132>
        }
    }
    1ef0:	bf00      	nop
    1ef2:	e000      	b.n	1ef6 <getSlowDividerConfig+0x132>
                break;
    1ef4:	bf00      	nop

    return ReturnValue;
    1ef6:	9b05      	ldr	r3, [sp, #20]
}
    1ef8:	4618      	mov	r0, r3
    1efa:	b006      	add	sp, #24
    1efc:	4770      	bx	lr
    1efe:	bf00      	nop
    1f00:	1fff8b64 	.word	0x1fff8b64
    1f04:	1fff8c78 	.word	0x1fff8c78
    1f08:	40064000 	.word	0x40064000

00001f0c <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    1f0c:	b500      	push	{lr}
    1f0e:	b083      	sub	sp, #12
    1f10:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    1f12:	4b64      	ldr	r3, [pc, #400]	; (20a4 <Clock_Ip_ClockInitializeObjects+0x198>)
    1f14:	781b      	ldrb	r3, [r3, #0]
    1f16:	f083 0301 	eor.w	r3, r3, #1
    1f1a:	b2db      	uxtb	r3, r3
    1f1c:	2b00      	cmp	r3, #0
    1f1e:	d05b      	beq.n	1fd8 <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    1f20:	4b60      	ldr	r3, [pc, #384]	; (20a4 <Clock_Ip_ClockInitializeObjects+0x198>)
    1f22:	2201      	movs	r2, #1
    1f24:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    1f26:	4b60      	ldr	r3, [pc, #384]	; (20a8 <Clock_Ip_ClockInitializeObjects+0x19c>)
    1f28:	785b      	ldrb	r3, [r3, #1]
    1f2a:	461a      	mov	r2, r3
    1f2c:	4613      	mov	r3, r2
    1f2e:	009b      	lsls	r3, r3, #2
    1f30:	4413      	add	r3, r2
    1f32:	009b      	lsls	r3, r3, #2
    1f34:	4a5d      	ldr	r2, [pc, #372]	; (20ac <Clock_Ip_ClockInitializeObjects+0x1a0>)
    1f36:	4413      	add	r3, r2
    1f38:	4a5d      	ldr	r2, [pc, #372]	; (20b0 <Clock_Ip_ClockInitializeObjects+0x1a4>)
    1f3a:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    1f3c:	4b5d      	ldr	r3, [pc, #372]	; (20b4 <Clock_Ip_ClockInitializeObjects+0x1a8>)
    1f3e:	785b      	ldrb	r3, [r3, #1]
    1f40:	461a      	mov	r2, r3
    1f42:	4613      	mov	r3, r2
    1f44:	009b      	lsls	r3, r3, #2
    1f46:	4413      	add	r3, r2
    1f48:	009b      	lsls	r3, r3, #2
    1f4a:	4a5b      	ldr	r2, [pc, #364]	; (20b8 <Clock_Ip_ClockInitializeObjects+0x1ac>)
    1f4c:	4413      	add	r3, r2
    1f4e:	4a5b      	ldr	r2, [pc, #364]	; (20bc <Clock_Ip_ClockInitializeObjects+0x1b0>)
    1f50:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    1f52:	4b5b      	ldr	r3, [pc, #364]	; (20c0 <Clock_Ip_ClockInitializeObjects+0x1b4>)
    1f54:	791b      	ldrb	r3, [r3, #4]
    1f56:	461a      	mov	r2, r3
    1f58:	4613      	mov	r3, r2
    1f5a:	005b      	lsls	r3, r3, #1
    1f5c:	4413      	add	r3, r2
    1f5e:	009b      	lsls	r3, r3, #2
    1f60:	4a58      	ldr	r2, [pc, #352]	; (20c4 <Clock_Ip_ClockInitializeObjects+0x1b8>)
    1f62:	4413      	add	r3, r2
    1f64:	4a58      	ldr	r2, [pc, #352]	; (20c8 <Clock_Ip_ClockInitializeObjects+0x1bc>)
    1f66:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    1f68:	4b58      	ldr	r3, [pc, #352]	; (20cc <Clock_Ip_ClockInitializeObjects+0x1c0>)
    1f6a:	795b      	ldrb	r3, [r3, #5]
    1f6c:	00db      	lsls	r3, r3, #3
    1f6e:	4a58      	ldr	r2, [pc, #352]	; (20d0 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    1f70:	4413      	add	r3, r2
    1f72:	4a58      	ldr	r2, [pc, #352]	; (20d4 <Clock_Ip_ClockInitializeObjects+0x1c8>)
    1f74:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    1f76:	4b55      	ldr	r3, [pc, #340]	; (20cc <Clock_Ip_ClockInitializeObjects+0x1c0>)
    1f78:	79db      	ldrb	r3, [r3, #7]
    1f7a:	00db      	lsls	r3, r3, #3
    1f7c:	4a54      	ldr	r2, [pc, #336]	; (20d0 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    1f7e:	4413      	add	r3, r2
    1f80:	4a55      	ldr	r2, [pc, #340]	; (20d8 <Clock_Ip_ClockInitializeObjects+0x1cc>)
    1f82:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    1f84:	4b55      	ldr	r3, [pc, #340]	; (20dc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    1f86:	799b      	ldrb	r3, [r3, #6]
    1f88:	009b      	lsls	r3, r3, #2
    1f8a:	4a55      	ldr	r2, [pc, #340]	; (20e0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    1f8c:	4413      	add	r3, r2
    1f8e:	4a55      	ldr	r2, [pc, #340]	; (20e4 <Clock_Ip_ClockInitializeObjects+0x1d8>)
    1f90:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    1f92:	4b52      	ldr	r3, [pc, #328]	; (20dc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    1f94:	7a1b      	ldrb	r3, [r3, #8]
    1f96:	009b      	lsls	r3, r3, #2
    1f98:	4a51      	ldr	r2, [pc, #324]	; (20e0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    1f9a:	4413      	add	r3, r2
    1f9c:	4a52      	ldr	r2, [pc, #328]	; (20e8 <Clock_Ip_ClockInitializeObjects+0x1dc>)
    1f9e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    1fa0:	4b4e      	ldr	r3, [pc, #312]	; (20dc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    1fa2:	7a5b      	ldrb	r3, [r3, #9]
    1fa4:	009b      	lsls	r3, r3, #2
    1fa6:	4a4e      	ldr	r2, [pc, #312]	; (20e0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    1fa8:	4413      	add	r3, r2
    1faa:	4a50      	ldr	r2, [pc, #320]	; (20ec <Clock_Ip_ClockInitializeObjects+0x1e0>)
    1fac:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    1fae:	4b4b      	ldr	r3, [pc, #300]	; (20dc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    1fb0:	7adb      	ldrb	r3, [r3, #11]
    1fb2:	009b      	lsls	r3, r3, #2
    1fb4:	4a4a      	ldr	r2, [pc, #296]	; (20e0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    1fb6:	4413      	add	r3, r2
    1fb8:	4a4d      	ldr	r2, [pc, #308]	; (20f0 <Clock_Ip_ClockInitializeObjects+0x1e4>)
    1fba:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    1fbc:	4b47      	ldr	r3, [pc, #284]	; (20dc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    1fbe:	7b1b      	ldrb	r3, [r3, #12]
    1fc0:	009b      	lsls	r3, r3, #2
    1fc2:	4a47      	ldr	r2, [pc, #284]	; (20e0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    1fc4:	4413      	add	r3, r2
    1fc6:	4a4b      	ldr	r2, [pc, #300]	; (20f4 <Clock_Ip_ClockInitializeObjects+0x1e8>)
    1fc8:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    1fca:	4b44      	ldr	r3, [pc, #272]	; (20dc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    1fcc:	7b9b      	ldrb	r3, [r3, #14]
    1fce:	009b      	lsls	r3, r3, #2
    1fd0:	4a43      	ldr	r2, [pc, #268]	; (20e0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    1fd2:	4413      	add	r3, r2
    1fd4:	4a48      	ldr	r2, [pc, #288]	; (20f8 <Clock_Ip_ClockInitializeObjects+0x1ec>)
    1fd6:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    1fd8:	4b48      	ldr	r3, [pc, #288]	; (20fc <Clock_Ip_ClockInitializeObjects+0x1f0>)
    1fda:	781b      	ldrb	r3, [r3, #0]
    1fdc:	2b00      	cmp	r3, #0
    1fde:	d002      	beq.n	1fe6 <Clock_Ip_ClockInitializeObjects+0xda>
    1fe0:	9b01      	ldr	r3, [sp, #4]
    1fe2:	2b00      	cmp	r3, #0
    1fe4:	d003      	beq.n	1fee <Clock_Ip_ClockInitializeObjects+0xe2>
    1fe6:	4b46      	ldr	r3, [pc, #280]	; (2100 <Clock_Ip_ClockInitializeObjects+0x1f4>)
    1fe8:	781b      	ldrb	r3, [r3, #0]
    1fea:	2b00      	cmp	r3, #0
    1fec:	d056      	beq.n	209c <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    1fee:	f7ff fc09 	bl	1804 <getFircConfig>
    1ff2:	4603      	mov	r3, r0
    1ff4:	4a43      	ldr	r2, [pc, #268]	; (2104 <Clock_Ip_ClockInitializeObjects+0x1f8>)
    1ff6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    1ff8:	f7ff fc60 	bl	18bc <getSoscConfig>
    1ffc:	4603      	mov	r3, r0
    1ffe:	4a42      	ldr	r2, [pc, #264]	; (2108 <Clock_Ip_ClockInitializeObjects+0x1fc>)
    2000:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    2002:	f7ff fca7 	bl	1954 <getSpllConfig>
    2006:	4603      	mov	r3, r0
    2008:	4a40      	ldr	r2, [pc, #256]	; (210c <Clock_Ip_ClockInitializeObjects+0x200>)
    200a:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    200c:	2019      	movs	r0, #25
    200e:	f7ff fcfb 	bl	1a08 <getSelectorConfig>
    2012:	4603      	mov	r3, r0
    2014:	4a3e      	ldr	r2, [pc, #248]	; (2110 <Clock_Ip_ClockInitializeObjects+0x204>)
    2016:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    2018:	201a      	movs	r0, #26
    201a:	f7ff fcf5 	bl	1a08 <getSelectorConfig>
    201e:	4603      	mov	r3, r0
    2020:	4a3c      	ldr	r2, [pc, #240]	; (2114 <Clock_Ip_ClockInitializeObjects+0x208>)
    2022:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    2024:	201b      	movs	r0, #27
    2026:	f7ff fcef 	bl	1a08 <getSelectorConfig>
    202a:	4603      	mov	r3, r0
    202c:	4a3a      	ldr	r2, [pc, #232]	; (2118 <Clock_Ip_ClockInitializeObjects+0x20c>)
    202e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    2030:	201d      	movs	r0, #29
    2032:	f7ff fd7b 	bl	1b2c <getCoreDividerConfig>
    2036:	4603      	mov	r3, r0
    2038:	4a38      	ldr	r2, [pc, #224]	; (211c <Clock_Ip_ClockInitializeObjects+0x210>)
    203a:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    203c:	201e      	movs	r0, #30
    203e:	f7ff fd75 	bl	1b2c <getCoreDividerConfig>
    2042:	4603      	mov	r3, r0
    2044:	4a36      	ldr	r2, [pc, #216]	; (2120 <Clock_Ip_ClockInitializeObjects+0x214>)
    2046:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    2048:	201f      	movs	r0, #31
    204a:	f7ff fd6f 	bl	1b2c <getCoreDividerConfig>
    204e:	4603      	mov	r3, r0
    2050:	4a34      	ldr	r2, [pc, #208]	; (2124 <Clock_Ip_ClockInitializeObjects+0x218>)
    2052:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    2054:	2021      	movs	r0, #33	; 0x21
    2056:	f7ff fe0f 	bl	1c78 <getBusDividerConfig>
    205a:	4603      	mov	r3, r0
    205c:	4a32      	ldr	r2, [pc, #200]	; (2128 <Clock_Ip_ClockInitializeObjects+0x21c>)
    205e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    2060:	2022      	movs	r0, #34	; 0x22
    2062:	f7ff fe09 	bl	1c78 <getBusDividerConfig>
    2066:	4603      	mov	r3, r0
    2068:	4a30      	ldr	r2, [pc, #192]	; (212c <Clock_Ip_ClockInitializeObjects+0x220>)
    206a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    206c:	2023      	movs	r0, #35	; 0x23
    206e:	f7ff fe03 	bl	1c78 <getBusDividerConfig>
    2072:	4603      	mov	r3, r0
    2074:	4a2e      	ldr	r2, [pc, #184]	; (2130 <Clock_Ip_ClockInitializeObjects+0x224>)
    2076:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    2078:	2025      	movs	r0, #37	; 0x25
    207a:	f7ff fea3 	bl	1dc4 <getSlowDividerConfig>
    207e:	4603      	mov	r3, r0
    2080:	4a2c      	ldr	r2, [pc, #176]	; (2134 <Clock_Ip_ClockInitializeObjects+0x228>)
    2082:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    2084:	2026      	movs	r0, #38	; 0x26
    2086:	f7ff fe9d 	bl	1dc4 <getSlowDividerConfig>
    208a:	4603      	mov	r3, r0
    208c:	4a2a      	ldr	r2, [pc, #168]	; (2138 <Clock_Ip_ClockInitializeObjects+0x22c>)
    208e:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    2090:	2027      	movs	r0, #39	; 0x27
    2092:	f7ff fe97 	bl	1dc4 <getSlowDividerConfig>
    2096:	4603      	mov	r3, r0
    2098:	4a28      	ldr	r2, [pc, #160]	; (213c <Clock_Ip_ClockInitializeObjects+0x230>)
    209a:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    209c:	bf00      	nop
    209e:	b003      	add	sp, #12
    20a0:	f85d fb04 	ldr.w	pc, [sp], #4
    20a4:	1fff8c9c 	.word	0x1fff8c9c
    20a8:	0000a6b0 	.word	0x0000a6b0
    20ac:	0000ad58 	.word	0x0000ad58
    20b0:	1fff8b68 	.word	0x1fff8b68
    20b4:	0000a670 	.word	0x0000a670
    20b8:	0000ac58 	.word	0x0000ac58
    20bc:	1fff8b6c 	.word	0x1fff8b6c
    20c0:	0000a680 	.word	0x0000a680
    20c4:	0000accc 	.word	0x0000accc
    20c8:	1fff8b70 	.word	0x1fff8b70
    20cc:	0000a6c0 	.word	0x0000a6c0
    20d0:	0000a5f8 	.word	0x0000a5f8
    20d4:	1fff8b74 	.word	0x1fff8b74
    20d8:	1fff8bb0 	.word	0x1fff8bb0
    20dc:	0000a650 	.word	0x0000a650
    20e0:	0000ad18 	.word	0x0000ad18
    20e4:	1fff8b78 	.word	0x1fff8b78
    20e8:	1fff8bb4 	.word	0x1fff8bb4
    20ec:	1fff8b7c 	.word	0x1fff8b7c
    20f0:	1fff8bb8 	.word	0x1fff8bb8
    20f4:	1fff8b80 	.word	0x1fff8b80
    20f8:	1fff8bbc 	.word	0x1fff8bbc
    20fc:	1fff8b11 	.word	0x1fff8b11
    2100:	1fff8b18 	.word	0x1fff8b18
    2104:	1fff8b84 	.word	0x1fff8b84
    2108:	1fff8b88 	.word	0x1fff8b88
    210c:	1fff8b8c 	.word	0x1fff8b8c
    2110:	1fff8b90 	.word	0x1fff8b90
    2114:	1fff8b94 	.word	0x1fff8b94
    2118:	1fff8bc0 	.word	0x1fff8bc0
    211c:	1fff8b98 	.word	0x1fff8b98
    2120:	1fff8b9c 	.word	0x1fff8b9c
    2124:	1fff8bc4 	.word	0x1fff8bc4
    2128:	1fff8ba0 	.word	0x1fff8ba0
    212c:	1fff8ba4 	.word	0x1fff8ba4
    2130:	1fff8bc8 	.word	0x1fff8bc8
    2134:	1fff8ba8 	.word	0x1fff8ba8
    2138:	1fff8bac 	.word	0x1fff8bac
    213c:	1fff8bcc 	.word	0x1fff8bcc

00002140 <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    2140:	b500      	push	{lr}
    2142:	b083      	sub	sp, #12
    2144:	9001      	str	r0, [sp, #4]
    2146:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    2148:	9b01      	ldr	r3, [sp, #4]
    214a:	2b03      	cmp	r3, #3
    214c:	f000 8090 	beq.w	2270 <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    2150:	9b01      	ldr	r3, [sp, #4]
    2152:	2b03      	cmp	r3, #3
    2154:	f200 80d3 	bhi.w	22fe <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    2158:	9b01      	ldr	r3, [sp, #4]
    215a:	2b00      	cmp	r3, #0
    215c:	d040      	beq.n	21e0 <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    215e:	9b01      	ldr	r3, [sp, #4]
    2160:	3b01      	subs	r3, #1
    2162:	2b01      	cmp	r3, #1
    2164:	f200 80cb 	bhi.w	22fe <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    2168:	9b00      	ldr	r3, [sp, #0]
    216a:	2b00      	cmp	r3, #0
    216c:	f040 80c9 	bne.w	2302 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    2170:	4b68      	ldr	r3, [pc, #416]	; (2314 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    2172:	2200      	movs	r2, #0
    2174:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    2176:	4b68      	ldr	r3, [pc, #416]	; (2318 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    2178:	681b      	ldr	r3, [r3, #0]
    217a:	685b      	ldr	r3, [r3, #4]
    217c:	4a67      	ldr	r2, [pc, #412]	; (231c <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    217e:	6812      	ldr	r2, [r2, #0]
    2180:	4610      	mov	r0, r2
    2182:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    2184:	4b66      	ldr	r3, [pc, #408]	; (2320 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    2186:	681b      	ldr	r3, [r3, #0]
    2188:	681b      	ldr	r3, [r3, #0]
    218a:	4a66      	ldr	r2, [pc, #408]	; (2324 <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    218c:	6812      	ldr	r2, [r2, #0]
    218e:	4610      	mov	r0, r2
    2190:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    2192:	4b65      	ldr	r3, [pc, #404]	; (2328 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    2194:	681b      	ldr	r3, [r3, #0]
    2196:	681b      	ldr	r3, [r3, #0]
    2198:	4a64      	ldr	r2, [pc, #400]	; (232c <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    219a:	6812      	ldr	r2, [r2, #0]
    219c:	4610      	mov	r0, r2
    219e:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    21a0:	4b63      	ldr	r3, [pc, #396]	; (2330 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    21a2:	681b      	ldr	r3, [r3, #0]
    21a4:	681b      	ldr	r3, [r3, #0]
    21a6:	4a63      	ldr	r2, [pc, #396]	; (2334 <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    21a8:	6812      	ldr	r2, [r2, #0]
    21aa:	4610      	mov	r0, r2
    21ac:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    21ae:	4b62      	ldr	r3, [pc, #392]	; (2338 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    21b0:	681b      	ldr	r3, [r3, #0]
    21b2:	691b      	ldr	r3, [r3, #16]
    21b4:	4a61      	ldr	r2, [pc, #388]	; (233c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    21b6:	6812      	ldr	r2, [r2, #0]
    21b8:	6812      	ldr	r2, [r2, #0]
    21ba:	4610      	mov	r0, r2
    21bc:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    21be:	4b60      	ldr	r3, [pc, #384]	; (2340 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    21c0:	681b      	ldr	r3, [r3, #0]
    21c2:	68db      	ldr	r3, [r3, #12]
    21c4:	4a5f      	ldr	r2, [pc, #380]	; (2344 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    21c6:	6812      	ldr	r2, [r2, #0]
    21c8:	6812      	ldr	r2, [r2, #0]
    21ca:	4610      	mov	r0, r2
    21cc:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    21ce:	4b5e      	ldr	r3, [pc, #376]	; (2348 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    21d0:	681b      	ldr	r3, [r3, #0]
    21d2:	689b      	ldr	r3, [r3, #8]
    21d4:	4a5d      	ldr	r2, [pc, #372]	; (234c <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    21d6:	6812      	ldr	r2, [r2, #0]
    21d8:	6812      	ldr	r2, [r2, #0]
    21da:	4610      	mov	r0, r2
    21dc:	4798      	blx	r3
            }
        }
        break;
    21de:	e090      	b.n	2302 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    21e0:	9b00      	ldr	r3, [sp, #0]
    21e2:	2b02      	cmp	r3, #2
    21e4:	f040 808f 	bne.w	2306 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    21e8:	4b4a      	ldr	r3, [pc, #296]	; (2314 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    21ea:	2201      	movs	r2, #1
    21ec:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    21ee:	4b56      	ldr	r3, [pc, #344]	; (2348 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    21f0:	681b      	ldr	r3, [r3, #0]
    21f2:	685b      	ldr	r3, [r3, #4]
    21f4:	4a55      	ldr	r2, [pc, #340]	; (234c <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    21f6:	6812      	ldr	r2, [r2, #0]
    21f8:	4610      	mov	r0, r2
    21fa:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    21fc:	4b50      	ldr	r3, [pc, #320]	; (2340 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    21fe:	681b      	ldr	r3, [r3, #0]
    2200:	691b      	ldr	r3, [r3, #16]
    2202:	4a50      	ldr	r2, [pc, #320]	; (2344 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    2204:	6812      	ldr	r2, [r2, #0]
    2206:	4610      	mov	r0, r2
    2208:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    220a:	4b4d      	ldr	r3, [pc, #308]	; (2340 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    220c:	681b      	ldr	r3, [r3, #0]
    220e:	689b      	ldr	r3, [r3, #8]
    2210:	4a4c      	ldr	r2, [pc, #304]	; (2344 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    2212:	6812      	ldr	r2, [r2, #0]
    2214:	4610      	mov	r0, r2
    2216:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    2218:	4b47      	ldr	r3, [pc, #284]	; (2338 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    221a:	681b      	ldr	r3, [r3, #0]
    221c:	68db      	ldr	r3, [r3, #12]
    221e:	4a47      	ldr	r2, [pc, #284]	; (233c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    2220:	6812      	ldr	r2, [r2, #0]
    2222:	4610      	mov	r0, r2
    2224:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    2226:	4b44      	ldr	r3, [pc, #272]	; (2338 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    2228:	681b      	ldr	r3, [r3, #0]
    222a:	689b      	ldr	r3, [r3, #8]
    222c:	4a43      	ldr	r2, [pc, #268]	; (233c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    222e:	6812      	ldr	r2, [r2, #0]
    2230:	6812      	ldr	r2, [r2, #0]
    2232:	4610      	mov	r0, r2
    2234:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    2236:	4b38      	ldr	r3, [pc, #224]	; (2318 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    2238:	681b      	ldr	r3, [r3, #0]
    223a:	685b      	ldr	r3, [r3, #4]
    223c:	4a44      	ldr	r2, [pc, #272]	; (2350 <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    223e:	6812      	ldr	r2, [r2, #0]
    2240:	4610      	mov	r0, r2
    2242:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    2244:	4b36      	ldr	r3, [pc, #216]	; (2320 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    2246:	681b      	ldr	r3, [r3, #0]
    2248:	681b      	ldr	r3, [r3, #0]
    224a:	4a42      	ldr	r2, [pc, #264]	; (2354 <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    224c:	6812      	ldr	r2, [r2, #0]
    224e:	4610      	mov	r0, r2
    2250:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    2252:	4b35      	ldr	r3, [pc, #212]	; (2328 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    2254:	681b      	ldr	r3, [r3, #0]
    2256:	681b      	ldr	r3, [r3, #0]
    2258:	4a3f      	ldr	r2, [pc, #252]	; (2358 <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    225a:	6812      	ldr	r2, [r2, #0]
    225c:	4610      	mov	r0, r2
    225e:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    2260:	4b33      	ldr	r3, [pc, #204]	; (2330 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    2262:	681b      	ldr	r3, [r3, #0]
    2264:	681b      	ldr	r3, [r3, #0]
    2266:	4a3d      	ldr	r2, [pc, #244]	; (235c <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    2268:	6812      	ldr	r2, [r2, #0]
    226a:	4610      	mov	r0, r2
    226c:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    226e:	e04a      	b.n	2306 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    2270:	9b00      	ldr	r3, [sp, #0]
    2272:	2b02      	cmp	r3, #2
    2274:	d149      	bne.n	230a <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    2276:	4b27      	ldr	r3, [pc, #156]	; (2314 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    2278:	2201      	movs	r2, #1
    227a:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    227c:	4b32      	ldr	r3, [pc, #200]	; (2348 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    227e:	681b      	ldr	r3, [r3, #0]
    2280:	685b      	ldr	r3, [r3, #4]
    2282:	4a32      	ldr	r2, [pc, #200]	; (234c <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    2284:	6812      	ldr	r2, [r2, #0]
    2286:	4610      	mov	r0, r2
    2288:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    228a:	4b2d      	ldr	r3, [pc, #180]	; (2340 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    228c:	681b      	ldr	r3, [r3, #0]
    228e:	691b      	ldr	r3, [r3, #16]
    2290:	4a2c      	ldr	r2, [pc, #176]	; (2344 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    2292:	6812      	ldr	r2, [r2, #0]
    2294:	4610      	mov	r0, r2
    2296:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    2298:	4b29      	ldr	r3, [pc, #164]	; (2340 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    229a:	681b      	ldr	r3, [r3, #0]
    229c:	689b      	ldr	r3, [r3, #8]
    229e:	4a29      	ldr	r2, [pc, #164]	; (2344 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    22a0:	6812      	ldr	r2, [r2, #0]
    22a2:	4610      	mov	r0, r2
    22a4:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    22a6:	4b24      	ldr	r3, [pc, #144]	; (2338 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    22a8:	681b      	ldr	r3, [r3, #0]
    22aa:	68db      	ldr	r3, [r3, #12]
    22ac:	4a23      	ldr	r2, [pc, #140]	; (233c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    22ae:	6812      	ldr	r2, [r2, #0]
    22b0:	4610      	mov	r0, r2
    22b2:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    22b4:	4b20      	ldr	r3, [pc, #128]	; (2338 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    22b6:	681b      	ldr	r3, [r3, #0]
    22b8:	689b      	ldr	r3, [r3, #8]
    22ba:	4a20      	ldr	r2, [pc, #128]	; (233c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    22bc:	6812      	ldr	r2, [r2, #0]
    22be:	6812      	ldr	r2, [r2, #0]
    22c0:	4610      	mov	r0, r2
    22c2:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    22c4:	4b26      	ldr	r3, [pc, #152]	; (2360 <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    22c6:	681b      	ldr	r3, [r3, #0]
    22c8:	685b      	ldr	r3, [r3, #4]
    22ca:	4a26      	ldr	r2, [pc, #152]	; (2364 <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    22cc:	6812      	ldr	r2, [r2, #0]
    22ce:	4610      	mov	r0, r2
    22d0:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    22d2:	4b25      	ldr	r3, [pc, #148]	; (2368 <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    22d4:	681b      	ldr	r3, [r3, #0]
    22d6:	681b      	ldr	r3, [r3, #0]
    22d8:	4a24      	ldr	r2, [pc, #144]	; (236c <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    22da:	6812      	ldr	r2, [r2, #0]
    22dc:	4610      	mov	r0, r2
    22de:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    22e0:	4b23      	ldr	r3, [pc, #140]	; (2370 <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    22e2:	681b      	ldr	r3, [r3, #0]
    22e4:	681b      	ldr	r3, [r3, #0]
    22e6:	4a23      	ldr	r2, [pc, #140]	; (2374 <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    22e8:	6812      	ldr	r2, [r2, #0]
    22ea:	4610      	mov	r0, r2
    22ec:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    22ee:	4b22      	ldr	r3, [pc, #136]	; (2378 <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    22f0:	681b      	ldr	r3, [r3, #0]
    22f2:	681b      	ldr	r3, [r3, #0]
    22f4:	4a21      	ldr	r2, [pc, #132]	; (237c <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    22f6:	6812      	ldr	r2, [r2, #0]
    22f8:	4610      	mov	r0, r2
    22fa:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    22fc:	e005      	b.n	230a <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    22fe:	bf00      	nop
    2300:	e004      	b.n	230c <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    2302:	bf00      	nop
    2304:	e002      	b.n	230c <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    2306:	bf00      	nop
    2308:	e000      	b.n	230c <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    230a:	bf00      	nop
    }

}
    230c:	bf00      	nop
    230e:	b003      	add	sp, #12
    2310:	f85d fb04 	ldr.w	pc, [sp], #4
    2314:	1fff8b11 	.word	0x1fff8b11
    2318:	1fff8b74 	.word	0x1fff8b74
    231c:	1fff8b94 	.word	0x1fff8b94
    2320:	1fff8b78 	.word	0x1fff8b78
    2324:	1fff8b9c 	.word	0x1fff8b9c
    2328:	1fff8b7c 	.word	0x1fff8b7c
    232c:	1fff8ba4 	.word	0x1fff8ba4
    2330:	1fff8b80 	.word	0x1fff8b80
    2334:	1fff8bac 	.word	0x1fff8bac
    2338:	1fff8b68 	.word	0x1fff8b68
    233c:	1fff8b8c 	.word	0x1fff8b8c
    2340:	1fff8b6c 	.word	0x1fff8b6c
    2344:	1fff8b88 	.word	0x1fff8b88
    2348:	1fff8b70 	.word	0x1fff8b70
    234c:	1fff8b84 	.word	0x1fff8b84
    2350:	1fff8b90 	.word	0x1fff8b90
    2354:	1fff8b98 	.word	0x1fff8b98
    2358:	1fff8ba0 	.word	0x1fff8ba0
    235c:	1fff8ba8 	.word	0x1fff8ba8
    2360:	1fff8bb0 	.word	0x1fff8bb0
    2364:	1fff8bc0 	.word	0x1fff8bc0
    2368:	1fff8bb4 	.word	0x1fff8bb4
    236c:	1fff8bc4 	.word	0x1fff8bc4
    2370:	1fff8bb8 	.word	0x1fff8bb8
    2374:	1fff8bc8 	.word	0x1fff8bc8
    2378:	1fff8bbc 	.word	0x1fff8bbc
    237c:	1fff8bcc 	.word	0x1fff8bcc

00002380 <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    2380:	b500      	push	{lr}
    2382:	b083      	sub	sp, #12
    2384:	9001      	str	r0, [sp, #4]
    2386:	9100      	str	r1, [sp, #0]
    switch(Command)
    2388:	9b00      	ldr	r3, [sp, #0]
    238a:	2b04      	cmp	r3, #4
    238c:	d010      	beq.n	23b0 <Clock_Ip_Command+0x30>
    238e:	9b00      	ldr	r3, [sp, #0]
    2390:	2b04      	cmp	r3, #4
    2392:	d811      	bhi.n	23b8 <Clock_Ip_Command+0x38>
    2394:	9b00      	ldr	r3, [sp, #0]
    2396:	2b01      	cmp	r3, #1
    2398:	d006      	beq.n	23a8 <Clock_Ip_Command+0x28>
    239a:	9b00      	ldr	r3, [sp, #0]
    239c:	2b02      	cmp	r3, #2
    239e:	d10b      	bne.n	23b8 <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    23a0:	9801      	ldr	r0, [sp, #4]
    23a2:	f7ff fdb3 	bl	1f0c <Clock_Ip_ClockInitializeObjects>
            break;
    23a6:	e008      	b.n	23ba <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    23a8:	9801      	ldr	r0, [sp, #4]
    23aa:	f7ff f9db 	bl	1764 <Clock_Ip_SpecificPlatformInitClock>
            break;
    23ae:	e004      	b.n	23ba <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    23b0:	9801      	ldr	r0, [sp, #4]
    23b2:	f7ff f8ed 	bl	1590 <DisableSafeClock>
            break;
    23b6:	e000      	b.n	23ba <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    23b8:	bf00      	nop
    }
}
    23ba:	bf00      	nop
    23bc:	b003      	add	sp, #12
    23be:	f85d fb04 	ldr.w	pc, [sp], #4
    23c2:	bf00      	nop

000023c4 <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    23c4:	b500      	push	{lr}
    23c6:	b085      	sub	sp, #20
    23c8:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    23ca:	9b01      	ldr	r3, [sp, #4]
    23cc:	685b      	ldr	r3, [r3, #4]
    23ce:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    23d0:	9802      	ldr	r0, [sp, #8]
    23d2:	f002 fb71 	bl	4ab8 <Power_Ip_SMC_ModeCheckEntry>
    23d6:	4603      	mov	r3, r0
    23d8:	2b00      	cmp	r3, #0
    23da:	d002      	beq.n	23e2 <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    23dc:	2301      	movs	r3, #1
    23de:	9303      	str	r3, [sp, #12]
    23e0:	e003      	b.n	23ea <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    23e2:	9801      	ldr	r0, [sp, #4]
    23e4:	f002 fb9a 	bl	4b1c <Power_Ip_SMC_ModeConfig>
    23e8:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    23ea:	9b03      	ldr	r3, [sp, #12]
    23ec:	2b01      	cmp	r3, #1
    23ee:	d103      	bne.n	23f8 <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    23f0:	21ff      	movs	r1, #255	; 0xff
    23f2:	2003      	movs	r0, #3
    23f4:	f002 fafc 	bl	49f0 <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    23f8:	bf00      	nop
    23fa:	b005      	add	sp, #20
    23fc:	f85d fb04 	ldr.w	pc, [sp], #4

00002400 <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    2400:	b084      	sub	sp, #16
    2402:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    2404:	230c      	movs	r3, #12
    2406:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    2408:	4a08      	ldr	r2, [pc, #32]	; (242c <Power_Ip_ConvertIntergeToResetType+0x2c>)
    240a:	9b01      	ldr	r3, [sp, #4]
    240c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2410:	2b0e      	cmp	r3, #14
    2412:	d805      	bhi.n	2420 <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    2414:	4a05      	ldr	r2, [pc, #20]	; (242c <Power_Ip_ConvertIntergeToResetType+0x2c>)
    2416:	9b01      	ldr	r3, [sp, #4]
    2418:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    241c:	9303      	str	r3, [sp, #12]
    241e:	e001      	b.n	2424 <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    2420:	230c      	movs	r3, #12
    2422:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    2424:	9b03      	ldr	r3, [sp, #12]
}
    2426:	4618      	mov	r0, r3
    2428:	b004      	add	sp, #16
    242a:	4770      	bx	lr
    242c:	0000ac1c 	.word	0x0000ac1c

00002430 <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    2430:	b500      	push	{lr}
    2432:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    2434:	f001 f8de 	bl	35f4 <Power_Ip_RCM_GetResetReason>
    2438:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    243a:	9801      	ldr	r0, [sp, #4]
    243c:	f7ff ffe0 	bl	2400 <Power_Ip_ConvertIntergeToResetType>
    2440:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    2442:	9b00      	ldr	r3, [sp, #0]
}
    2444:	4618      	mov	r0, r3
    2446:	b003      	add	sp, #12
    2448:	f85d fb04 	ldr.w	pc, [sp], #4

0000244c <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    244c:	b500      	push	{lr}
    244e:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    2450:	f001 f928 	bl	36a4 <Power_Ip_RCM_GetResetRawValue>
    2454:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    2456:	9b01      	ldr	r3, [sp, #4]
}
    2458:	4618      	mov	r0, r3
    245a:	b003      	add	sp, #12
    245c:	f85d fb04 	ldr.w	pc, [sp], #4

00002460 <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    2460:	b500      	push	{lr}
    2462:	b083      	sub	sp, #12
    2464:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    2466:	9b01      	ldr	r3, [sp, #4]
    2468:	681b      	ldr	r3, [r3, #0]
    246a:	4618      	mov	r0, r3
    246c:	f001 f8ac 	bl	35c8 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    2470:	9b01      	ldr	r3, [sp, #4]
    2472:	685b      	ldr	r3, [r3, #4]
    2474:	4618      	mov	r0, r3
    2476:	f001 ffc3 	bl	4400 <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    247a:	9b01      	ldr	r3, [sp, #4]
    247c:	689b      	ldr	r3, [r3, #8]
    247e:	4618      	mov	r0, r3
    2480:	f002 fb0c 	bl	4a9c <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    2484:	bf00      	nop
    2486:	b003      	add	sp, #12
    2488:	f85d fb04 	ldr.w	pc, [sp], #4

0000248c <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    248c:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    248e:	f001 fbaf 	bl	3bf0 <Power_Ip_CM4_DisableSleepOnExit>
}
    2492:	bf00      	nop
    2494:	bd08      	pop	{r3, pc}

00002496 <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    2496:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    2498:	f001 fbbe 	bl	3c18 <Power_Ip_CM4_EnableSleepOnExit>
}
    249c:	bf00      	nop
    249e:	bd08      	pop	{r3, pc}

000024a0 <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    24a0:	b082      	sub	sp, #8
    24a2:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    24a4:	4a02      	ldr	r2, [pc, #8]	; (24b0 <Power_Ip_InstallNotificationsCallback+0x10>)
    24a6:	9b01      	ldr	r3, [sp, #4]
    24a8:	6013      	str	r3, [r2, #0]
}
    24aa:	bf00      	nop
    24ac:	b002      	add	sp, #8
    24ae:	4770      	bx	lr
    24b0:	1fff8b14 	.word	0x1fff8b14

000024b4 <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    24b4:	b082      	sub	sp, #8
    24b6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    24b8:	bf00      	nop
    24ba:	b002      	add	sp, #8
    24bc:	4770      	bx	lr

000024be <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    24be:	b082      	sub	sp, #8
    24c0:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    24c2:	bf00      	nop
    24c4:	b002      	add	sp, #8
    24c6:	4770      	bx	lr

000024c8 <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    24c8:	b500      	push	{lr}
    24ca:	b083      	sub	sp, #12
    24cc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    24ce:	9b01      	ldr	r3, [sp, #4]
    24d0:	2b00      	cmp	r3, #0
    24d2:	d002      	beq.n	24da <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    24d4:	9801      	ldr	r0, [sp, #4]
    24d6:	f000 f86a 	bl	25ae <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    24da:	bf00      	nop
    24dc:	b003      	add	sp, #12
    24de:	f85d fb04 	ldr.w	pc, [sp], #4

000024e2 <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    24e2:	b500      	push	{lr}
    24e4:	b083      	sub	sp, #12
    24e6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    24e8:	9b01      	ldr	r3, [sp, #4]
    24ea:	2b00      	cmp	r3, #0
    24ec:	d002      	beq.n	24f4 <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    24ee:	9801      	ldr	r0, [sp, #4]
    24f0:	f000 f884 	bl	25fc <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    24f4:	bf00      	nop
    24f6:	b003      	add	sp, #12
    24f8:	f85d fb04 	ldr.w	pc, [sp], #4

000024fc <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    24fc:	b500      	push	{lr}
    24fe:	b089      	sub	sp, #36	; 0x24
    2500:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    2502:	2300      	movs	r3, #0
    2504:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    2508:	9b01      	ldr	r3, [sp, #4]
    250a:	2b00      	cmp	r3, #0
    250c:	d031      	beq.n	2572 <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    250e:	4b1b      	ldr	r3, [pc, #108]	; (257c <Clock_Ip_CompleteSOSC+0x80>)
    2510:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2514:	f003 0301 	and.w	r3, r3, #1
    2518:	2b00      	cmp	r3, #0
    251a:	d02a      	beq.n	2572 <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    251c:	aa03      	add	r2, sp, #12
    251e:	a904      	add	r1, sp, #16
    2520:	a805      	add	r0, sp, #20
    2522:	f24c 3350 	movw	r3, #50000	; 0xc350
    2526:	f001 f815 	bl	3554 <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    252a:	4b14      	ldr	r3, [pc, #80]	; (257c <Clock_Ip_CompleteSOSC+0x80>)
    252c:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2530:	0e1b      	lsrs	r3, r3, #24
    2532:	f003 0301 	and.w	r3, r3, #1
    2536:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    2538:	9a03      	ldr	r2, [sp, #12]
    253a:	a904      	add	r1, sp, #16
    253c:	ab05      	add	r3, sp, #20
    253e:	4618      	mov	r0, r3
    2540:	f001 f822 	bl	3588 <Clock_Ip_TimeoutExpired>
    2544:	4603      	mov	r3, r0
    2546:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    254a:	9b06      	ldr	r3, [sp, #24]
    254c:	2b00      	cmp	r3, #0
    254e:	d106      	bne.n	255e <Clock_Ip_CompleteSOSC+0x62>
    2550:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2554:	f083 0301 	eor.w	r3, r3, #1
    2558:	b2db      	uxtb	r3, r3
    255a:	2b00      	cmp	r3, #0
    255c:	d1e5      	bne.n	252a <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    255e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    2562:	2b00      	cmp	r3, #0
    2564:	d005      	beq.n	2572 <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    2566:	9b01      	ldr	r3, [sp, #4]
    2568:	681b      	ldr	r3, [r3, #0]
    256a:	4619      	mov	r1, r3
    256c:	2001      	movs	r0, #1
    256e:	f000 ffe1 	bl	3534 <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    2572:	bf00      	nop
    2574:	b009      	add	sp, #36	; 0x24
    2576:	f85d fb04 	ldr.w	pc, [sp], #4
    257a:	bf00      	nop
    257c:	40064000 	.word	0x40064000

00002580 <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    2580:	b500      	push	{lr}
    2582:	b083      	sub	sp, #12
    2584:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    2586:	9801      	ldr	r0, [sp, #4]
    2588:	f000 f8c0 	bl	270c <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    258c:	bf00      	nop
    258e:	b003      	add	sp, #12
    2590:	f85d fb04 	ldr.w	pc, [sp], #4

00002594 <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    2594:	b500      	push	{lr}
    2596:	b083      	sub	sp, #12
    2598:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    259a:	9b01      	ldr	r3, [sp, #4]
    259c:	2b00      	cmp	r3, #0
    259e:	d002      	beq.n	25a6 <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    25a0:	9801      	ldr	r0, [sp, #4]
    25a2:	f000 f8c3 	bl	272c <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    25a6:	bf00      	nop
    25a8:	b003      	add	sp, #12
    25aa:	f85d fb04 	ldr.w	pc, [sp], #4

000025ae <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    25ae:	b082      	sub	sp, #8
    25b0:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    25b2:	4b11      	ldr	r3, [pc, #68]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25b4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    25b8:	4a0f      	ldr	r2, [pc, #60]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25ba:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    25be:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    25c2:	4b0d      	ldr	r3, [pc, #52]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25c4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    25c8:	4a0b      	ldr	r2, [pc, #44]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25ca:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    25ce:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    25d2:	4b09      	ldr	r3, [pc, #36]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25d4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    25d8:	4a07      	ldr	r2, [pc, #28]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25da:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    25de:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    25e2:	4b05      	ldr	r3, [pc, #20]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25e4:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    25e8:	4a03      	ldr	r2, [pc, #12]	; (25f8 <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    25ea:	f023 0301 	bic.w	r3, r3, #1
    25ee:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    25f2:	bf00      	nop
    25f4:	b002      	add	sp, #8
    25f6:	4770      	bx	lr
    25f8:	40064000 	.word	0x40064000

000025fc <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    25fc:	b082      	sub	sp, #8
    25fe:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    2600:	9b01      	ldr	r3, [sp, #4]
    2602:	891b      	ldrh	r3, [r3, #8]
    2604:	2b01      	cmp	r3, #1
    2606:	d174      	bne.n	26f2 <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    2608:	9b01      	ldr	r3, [sp, #4]
    260a:	7bdb      	ldrb	r3, [r3, #15]
    260c:	2b00      	cmp	r3, #0
    260e:	d002      	beq.n	2616 <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    2610:	2b01      	cmp	r3, #1
    2612:	d009      	beq.n	2628 <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    2614:	e011      	b.n	263a <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    2616:	4b39      	ldr	r3, [pc, #228]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2618:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    261c:	4a37      	ldr	r2, [pc, #220]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    261e:	f023 0308 	bic.w	r3, r3, #8
    2622:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2626:	e008      	b.n	263a <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    2628:	4b34      	ldr	r3, [pc, #208]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    262a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    262e:	4a33      	ldr	r2, [pc, #204]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2630:	f043 0308 	orr.w	r3, r3, #8
    2634:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    2638:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    263a:	4b30      	ldr	r3, [pc, #192]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    263c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2640:	4a2e      	ldr	r2, [pc, #184]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2642:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    2646:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    264a:	9b01      	ldr	r3, [sp, #4]
    264c:	685b      	ldr	r3, [r3, #4]
    264e:	4a2c      	ldr	r2, [pc, #176]	; (2700 <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    2650:	4293      	cmp	r3, r2
    2652:	d90d      	bls.n	2670 <Clock_Ip_SetSOSC_TrustedCall+0x74>
    2654:	9b01      	ldr	r3, [sp, #4]
    2656:	685b      	ldr	r3, [r3, #4]
    2658:	4a2a      	ldr	r2, [pc, #168]	; (2704 <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    265a:	4293      	cmp	r3, r2
    265c:	d208      	bcs.n	2670 <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    265e:	4b27      	ldr	r3, [pc, #156]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2660:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2664:	4a25      	ldr	r2, [pc, #148]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2666:	f043 0320 	orr.w	r3, r3, #32
    266a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    266e:	e007      	b.n	2680 <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    2670:	4b22      	ldr	r3, [pc, #136]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2672:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    2676:	4a21      	ldr	r2, [pc, #132]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2678:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    267c:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    2680:	9b01      	ldr	r3, [sp, #4]
    2682:	7b1b      	ldrb	r3, [r3, #12]
    2684:	2b00      	cmp	r3, #0
    2686:	d108      	bne.n	269a <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    2688:	4b1c      	ldr	r3, [pc, #112]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    268a:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    268e:	4a1b      	ldr	r2, [pc, #108]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    2690:	f043 0304 	orr.w	r3, r3, #4
    2694:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    2698:	e007      	b.n	26aa <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    269a:	4b18      	ldr	r3, [pc, #96]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    269c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    26a0:	4a16      	ldr	r2, [pc, #88]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    26a2:	f023 0304 	bic.w	r3, r3, #4
    26a6:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    26aa:	9b01      	ldr	r3, [sp, #4]
    26ac:	7c1b      	ldrb	r3, [r3, #16]
    26ae:	2b02      	cmp	r3, #2
    26b0:	d011      	beq.n	26d6 <Clock_Ip_SetSOSC_TrustedCall+0xda>
    26b2:	2b02      	cmp	r3, #2
    26b4:	dc14      	bgt.n	26e0 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    26b6:	2b00      	cmp	r3, #0
    26b8:	d002      	beq.n	26c0 <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    26ba:	2b01      	cmp	r3, #1
    26bc:	d005      	beq.n	26ca <Clock_Ip_SetSOSC_TrustedCall+0xce>
    26be:	e00f      	b.n	26e0 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    26c0:	4b0e      	ldr	r3, [pc, #56]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    26c2:	2201      	movs	r2, #1
    26c4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    26c8:	e014      	b.n	26f4 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    26ca:	4b0c      	ldr	r3, [pc, #48]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    26cc:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    26d0:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    26d4:	e00e      	b.n	26f4 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    26d6:	4b09      	ldr	r3, [pc, #36]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    26d8:	4a0b      	ldr	r2, [pc, #44]	; (2708 <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    26da:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    26de:	e009      	b.n	26f4 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    26e0:	4b06      	ldr	r3, [pc, #24]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    26e2:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    26e6:	4a05      	ldr	r2, [pc, #20]	; (26fc <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    26e8:	f043 0301 	orr.w	r3, r3, #1
    26ec:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    26f0:	e000      	b.n	26f4 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    26f2:	bf00      	nop
}
    26f4:	bf00      	nop
    26f6:	b002      	add	sp, #8
    26f8:	4770      	bx	lr
    26fa:	bf00      	nop
    26fc:	40064000 	.word	0x40064000
    2700:	003d08ff 	.word	0x003d08ff
    2704:	007a1200 	.word	0x007a1200
    2708:	00030001 	.word	0x00030001

0000270c <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    270c:	b082      	sub	sp, #8
    270e:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    2710:	4b05      	ldr	r3, [pc, #20]	; (2728 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    2712:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    2716:	4a04      	ldr	r2, [pc, #16]	; (2728 <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    2718:	f023 0301 	bic.w	r3, r3, #1
    271c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    2720:	bf00      	nop
    2722:	b002      	add	sp, #8
    2724:	4770      	bx	lr
    2726:	bf00      	nop
    2728:	40064000 	.word	0x40064000

0000272c <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    272c:	b082      	sub	sp, #8
    272e:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    2730:	9b01      	ldr	r3, [sp, #4]
    2732:	891b      	ldrh	r3, [r3, #8]
    2734:	2b01      	cmp	r3, #1
    2736:	d107      	bne.n	2748 <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    2738:	4b05      	ldr	r3, [pc, #20]	; (2750 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    273a:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    273e:	4a04      	ldr	r2, [pc, #16]	; (2750 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    2740:	f043 0301 	orr.w	r3, r3, #1
    2744:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    2748:	bf00      	nop
    274a:	b002      	add	sp, #8
    274c:	4770      	bx	lr
    274e:	bf00      	nop
    2750:	40064000 	.word	0x40064000

00002754 <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
    2754:	b082      	sub	sp, #8
    2756:	9001      	str	r0, [sp, #4]
    2758:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
    275a:	bf00      	nop
    275c:	b002      	add	sp, #8
    275e:	4770      	bx	lr

00002760 <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
    2760:	b500      	push	{lr}
    2762:	b085      	sub	sp, #20
    2764:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
    2766:	4b24      	ldr	r3, [pc, #144]	; (27f8 <Clock_Ip_UpdateDriverContext+0x98>)
    2768:	2201      	movs	r2, #1
    276a:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    276c:	4b23      	ldr	r3, [pc, #140]	; (27fc <Clock_Ip_UpdateDriverContext+0x9c>)
    276e:	681b      	ldr	r3, [r3, #0]
    2770:	2102      	movs	r1, #2
    2772:	4618      	mov	r0, r3
    2774:	f7ff fe04 	bl	2380 <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    2778:	2300      	movs	r3, #0
    277a:	f88d 300f 	strb.w	r3, [sp, #15]
    277e:	e015      	b.n	27ac <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
    2780:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2784:	9a01      	ldr	r2, [sp, #4]
    2786:	334a      	adds	r3, #74	; 0x4a
    2788:	00db      	lsls	r3, r3, #3
    278a:	4413      	add	r3, r2
    278c:	6858      	ldr	r0, [r3, #4]
    278e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2792:	9a01      	ldr	r2, [sp, #4]
    2794:	334a      	adds	r3, #74	; 0x4a
    2796:	00db      	lsls	r3, r3, #3
    2798:	4413      	add	r3, r2
    279a:	689b      	ldr	r3, [r3, #8]
    279c:	4619      	mov	r1, r3
    279e:	f001 f869 	bl	3874 <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    27a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    27a6:	3301      	adds	r3, #1
    27a8:	f88d 300f 	strb.w	r3, [sp, #15]
    27ac:	9b01      	ldr	r3, [sp, #4]
    27ae:	7bdb      	ldrb	r3, [r3, #15]
    27b0:	f89d 200f 	ldrb.w	r2, [sp, #15]
    27b4:	429a      	cmp	r2, r3
    27b6:	d3e3      	bcc.n	2780 <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
    27b8:	f000 f824 	bl	2804 <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    27bc:	2301      	movs	r3, #1
    27be:	f88d 300f 	strb.w	r3, [sp, #15]
    27c2:	e00e      	b.n	27e2 <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
    27c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
    27c8:	9b01      	ldr	r3, [sp, #4]
    27ca:	327e      	adds	r2, #126	; 0x7e
    27cc:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    27d0:	490b      	ldr	r1, [pc, #44]	; (2800 <Clock_Ip_UpdateDriverContext+0xa0>)
    27d2:	f89d 200f 	ldrb.w	r2, [sp, #15]
    27d6:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    27d8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    27dc:	3301      	adds	r3, #1
    27de:	f88d 300f 	strb.w	r3, [sp, #15]
    27e2:	9b01      	ldr	r3, [sp, #4]
    27e4:	7cdb      	ldrb	r3, [r3, #19]
    27e6:	f89d 200f 	ldrb.w	r2, [sp, #15]
    27ea:	429a      	cmp	r2, r3
    27ec:	d3ea      	bcc.n	27c4 <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
    27ee:	bf00      	nop
    27f0:	bf00      	nop
    27f2:	b005      	add	sp, #20
    27f4:	f85d fb04 	ldr.w	pc, [sp], #4
    27f8:	1fff8b18 	.word	0x1fff8b18
    27fc:	1fff8ca0 	.word	0x1fff8ca0
    2800:	1fff8cac 	.word	0x1fff8cac

00002804 <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
    2804:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
    2806:	4b23      	ldr	r3, [pc, #140]	; (2894 <Clock_Ip_CallEmptyCallbacks+0x90>)
    2808:	781b      	ldrb	r3, [r3, #0]
    280a:	f083 0301 	eor.w	r3, r3, #1
    280e:	b2db      	uxtb	r3, r3
    2810:	2b00      	cmp	r3, #0
    2812:	d03d      	beq.n	2890 <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
    2814:	4b1f      	ldr	r3, [pc, #124]	; (2894 <Clock_Ip_CallEmptyCallbacks+0x90>)
    2816:	2201      	movs	r2, #1
    2818:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    281a:	4b1f      	ldr	r3, [pc, #124]	; (2898 <Clock_Ip_CallEmptyCallbacks+0x94>)
    281c:	685b      	ldr	r3, [r3, #4]
    281e:	2100      	movs	r1, #0
    2820:	2000      	movs	r0, #0
    2822:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
    2824:	4b1c      	ldr	r3, [pc, #112]	; (2898 <Clock_Ip_CallEmptyCallbacks+0x94>)
    2826:	689b      	ldr	r3, [r3, #8]
    2828:	2057      	movs	r0, #87	; 0x57
    282a:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    282c:	4b1b      	ldr	r3, [pc, #108]	; (289c <Clock_Ip_CallEmptyCallbacks+0x98>)
    282e:	681b      	ldr	r3, [r3, #0]
    2830:	2000      	movs	r0, #0
    2832:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
    2834:	4b1a      	ldr	r3, [pc, #104]	; (28a0 <Clock_Ip_CallEmptyCallbacks+0x9c>)
    2836:	681b      	ldr	r3, [r3, #0]
    2838:	2000      	movs	r0, #0
    283a:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
    283c:	4b19      	ldr	r3, [pc, #100]	; (28a4 <Clock_Ip_CallEmptyCallbacks+0xa0>)
    283e:	681b      	ldr	r3, [r3, #0]
    2840:	2000      	movs	r0, #0
    2842:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2844:	4b18      	ldr	r3, [pc, #96]	; (28a8 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    2846:	685b      	ldr	r3, [r3, #4]
    2848:	2000      	movs	r0, #0
    284a:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    284c:	4b16      	ldr	r3, [pc, #88]	; (28a8 <Clock_Ip_CallEmptyCallbacks+0xa4>)
    284e:	689b      	ldr	r3, [r3, #8]
    2850:	2057      	movs	r0, #87	; 0x57
    2852:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2854:	4b15      	ldr	r3, [pc, #84]	; (28ac <Clock_Ip_CallEmptyCallbacks+0xa8>)
    2856:	681b      	ldr	r3, [r3, #0]
    2858:	2000      	movs	r0, #0
    285a:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
    285c:	4b13      	ldr	r3, [pc, #76]	; (28ac <Clock_Ip_CallEmptyCallbacks+0xa8>)
    285e:	685b      	ldr	r3, [r3, #4]
    2860:	2100      	movs	r1, #0
    2862:	2057      	movs	r0, #87	; 0x57
    2864:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2866:	4b12      	ldr	r3, [pc, #72]	; (28b0 <Clock_Ip_CallEmptyCallbacks+0xac>)
    2868:	681b      	ldr	r3, [r3, #0]
    286a:	2000      	movs	r0, #0
    286c:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    286e:	4b11      	ldr	r3, [pc, #68]	; (28b4 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    2870:	685b      	ldr	r3, [r3, #4]
    2872:	2000      	movs	r0, #0
    2874:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    2876:	4b0f      	ldr	r3, [pc, #60]	; (28b4 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    2878:	689b      	ldr	r3, [r3, #8]
    287a:	2057      	movs	r0, #87	; 0x57
    287c:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    287e:	4b0e      	ldr	r3, [pc, #56]	; (28b8 <Clock_Ip_CallEmptyCallbacks+0xb4>)
    2880:	685b      	ldr	r3, [r3, #4]
    2882:	2000      	movs	r0, #0
    2884:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    2886:	4b0d      	ldr	r3, [pc, #52]	; (28bc <Clock_Ip_CallEmptyCallbacks+0xb8>)
    2888:	681b      	ldr	r3, [r3, #0]
    288a:	2100      	movs	r1, #0
    288c:	2000      	movs	r0, #0
    288e:	4798      	blx	r3
    }
}
    2890:	bf00      	nop
    2892:	bd08      	pop	{r3, pc}
    2894:	1fff8ca4 	.word	0x1fff8ca4
    2898:	0000ad08 	.word	0x0000ad08
    289c:	0000ad18 	.word	0x0000ad18
    28a0:	0000acc4 	.word	0x0000acc4
    28a4:	0000ac58 	.word	0x0000ac58
    28a8:	0000acb8 	.word	0x0000acb8
    28ac:	0000ac80 	.word	0x0000ac80
    28b0:	0000accc 	.word	0x0000accc
    28b4:	0000ad58 	.word	0x0000ad58
    28b8:	0000a5f8 	.word	0x0000a5f8
    28bc:	0000ad54 	.word	0x0000ad54

000028c0 <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
    28c0:	b500      	push	{lr}
    28c2:	b085      	sub	sp, #20
    28c4:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    28c6:	9b01      	ldr	r3, [sp, #4]
    28c8:	7adb      	ldrb	r3, [r3, #11]
    28ca:	9303      	str	r3, [sp, #12]
    28cc:	e01f      	b.n	290e <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    28ce:	9b03      	ldr	r3, [sp, #12]
    28d0:	1e5a      	subs	r2, r3, #1
    28d2:	9b01      	ldr	r3, [sp, #4]
    28d4:	320d      	adds	r2, #13
    28d6:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    28da:	495a      	ldr	r1, [pc, #360]	; (2a44 <Clock_Ip_ResetClockConfiguration+0x184>)
    28dc:	4613      	mov	r3, r2
    28de:	00db      	lsls	r3, r3, #3
    28e0:	4413      	add	r3, r2
    28e2:	440b      	add	r3, r1
    28e4:	3301      	adds	r3, #1
    28e6:	781b      	ldrb	r3, [r3, #0]
    28e8:	461a      	mov	r2, r3
    28ea:	4b57      	ldr	r3, [pc, #348]	; (2a48 <Clock_Ip_ResetClockConfiguration+0x188>)
    28ec:	5c9b      	ldrb	r3, [r3, r2]
    28ee:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
    28f0:	4a56      	ldr	r2, [pc, #344]	; (2a4c <Clock_Ip_ResetClockConfiguration+0x18c>)
    28f2:	9b02      	ldr	r3, [sp, #8]
    28f4:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    28f8:	9a03      	ldr	r2, [sp, #12]
    28fa:	3a01      	subs	r2, #1
    28fc:	320d      	adds	r2, #13
    28fe:	00d2      	lsls	r2, r2, #3
    2900:	9901      	ldr	r1, [sp, #4]
    2902:	440a      	add	r2, r1
    2904:	4610      	mov	r0, r2
    2906:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    2908:	9b03      	ldr	r3, [sp, #12]
    290a:	3b01      	subs	r3, #1
    290c:	9303      	str	r3, [sp, #12]
    290e:	9b03      	ldr	r3, [sp, #12]
    2910:	2b00      	cmp	r3, #0
    2912:	d1dc      	bne.n	28ce <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    2914:	9b01      	ldr	r3, [sp, #4]
    2916:	7b9b      	ldrb	r3, [r3, #14]
    2918:	9303      	str	r3, [sp, #12]
    291a:	e026      	b.n	296a <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    291c:	9b03      	ldr	r3, [sp, #12]
    291e:	3b01      	subs	r3, #1
    2920:	9a01      	ldr	r2, [sp, #4]
    2922:	3324      	adds	r3, #36	; 0x24
    2924:	011b      	lsls	r3, r3, #4
    2926:	4413      	add	r3, r2
    2928:	3304      	adds	r3, #4
    292a:	681a      	ldr	r2, [r3, #0]
    292c:	4945      	ldr	r1, [pc, #276]	; (2a44 <Clock_Ip_ResetClockConfiguration+0x184>)
    292e:	4613      	mov	r3, r2
    2930:	00db      	lsls	r3, r3, #3
    2932:	4413      	add	r3, r2
    2934:	440b      	add	r3, r1
    2936:	3301      	adds	r3, #1
    2938:	781b      	ldrb	r3, [r3, #0]
    293a:	461a      	mov	r2, r3
    293c:	4b44      	ldr	r3, [pc, #272]	; (2a50 <Clock_Ip_ResetClockConfiguration+0x190>)
    293e:	5c9b      	ldrb	r3, [r3, r2]
    2940:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    2942:	4944      	ldr	r1, [pc, #272]	; (2a54 <Clock_Ip_ResetClockConfiguration+0x194>)
    2944:	9a02      	ldr	r2, [sp, #8]
    2946:	4613      	mov	r3, r2
    2948:	005b      	lsls	r3, r3, #1
    294a:	4413      	add	r3, r2
    294c:	009b      	lsls	r3, r3, #2
    294e:	440b      	add	r3, r1
    2950:	681b      	ldr	r3, [r3, #0]
    2952:	9a03      	ldr	r2, [sp, #12]
    2954:	3a01      	subs	r2, #1
    2956:	3224      	adds	r2, #36	; 0x24
    2958:	0112      	lsls	r2, r2, #4
    295a:	9901      	ldr	r1, [sp, #4]
    295c:	440a      	add	r2, r1
    295e:	3204      	adds	r2, #4
    2960:	4610      	mov	r0, r2
    2962:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    2964:	9b03      	ldr	r3, [sp, #12]
    2966:	3b01      	subs	r3, #1
    2968:	9303      	str	r3, [sp, #12]
    296a:	9b03      	ldr	r3, [sp, #12]
    296c:	2b00      	cmp	r3, #0
    296e:	d1d5      	bne.n	291c <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    2970:	9b01      	ldr	r3, [sp, #4]
    2972:	7a9b      	ldrb	r3, [r3, #10]
    2974:	9303      	str	r3, [sp, #12]
    2976:	e02a      	b.n	29ce <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2978:	9b03      	ldr	r3, [sp, #12]
    297a:	1e5a      	subs	r2, r3, #1
    297c:	9901      	ldr	r1, [sp, #4]
    297e:	4613      	mov	r3, r2
    2980:	009b      	lsls	r3, r3, #2
    2982:	4413      	add	r3, r2
    2984:	00db      	lsls	r3, r3, #3
    2986:	440b      	add	r3, r1
    2988:	3340      	adds	r3, #64	; 0x40
    298a:	681a      	ldr	r2, [r3, #0]
    298c:	492d      	ldr	r1, [pc, #180]	; (2a44 <Clock_Ip_ResetClockConfiguration+0x184>)
    298e:	4613      	mov	r3, r2
    2990:	00db      	lsls	r3, r3, #3
    2992:	4413      	add	r3, r2
    2994:	440b      	add	r3, r1
    2996:	3301      	adds	r3, #1
    2998:	781b      	ldrb	r3, [r3, #0]
    299a:	461a      	mov	r2, r3
    299c:	4b2e      	ldr	r3, [pc, #184]	; (2a58 <Clock_Ip_ResetClockConfiguration+0x198>)
    299e:	5c9b      	ldrb	r3, [r3, r2]
    29a0:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    29a2:	492e      	ldr	r1, [pc, #184]	; (2a5c <Clock_Ip_ResetClockConfiguration+0x19c>)
    29a4:	9a02      	ldr	r2, [sp, #8]
    29a6:	4613      	mov	r3, r2
    29a8:	009b      	lsls	r3, r3, #2
    29aa:	4413      	add	r3, r2
    29ac:	009b      	lsls	r3, r3, #2
    29ae:	440b      	add	r3, r1
    29b0:	6819      	ldr	r1, [r3, #0]
    29b2:	9b03      	ldr	r3, [sp, #12]
    29b4:	1e5a      	subs	r2, r3, #1
    29b6:	4613      	mov	r3, r2
    29b8:	009b      	lsls	r3, r3, #2
    29ba:	4413      	add	r3, r2
    29bc:	00db      	lsls	r3, r3, #3
    29be:	3340      	adds	r3, #64	; 0x40
    29c0:	9a01      	ldr	r2, [sp, #4]
    29c2:	4413      	add	r3, r2
    29c4:	4618      	mov	r0, r3
    29c6:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    29c8:	9b03      	ldr	r3, [sp, #12]
    29ca:	3b01      	subs	r3, #1
    29cc:	9303      	str	r3, [sp, #12]
    29ce:	9b03      	ldr	r3, [sp, #12]
    29d0:	2b00      	cmp	r3, #0
    29d2:	d1d1      	bne.n	2978 <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    29d4:	9b01      	ldr	r3, [sp, #4]
    29d6:	7a5b      	ldrb	r3, [r3, #9]
    29d8:	9303      	str	r3, [sp, #12]
    29da:	e02b      	b.n	2a34 <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    29dc:	9b03      	ldr	r3, [sp, #12]
    29de:	1e5a      	subs	r2, r3, #1
    29e0:	9901      	ldr	r1, [sp, #4]
    29e2:	4613      	mov	r3, r2
    29e4:	009b      	lsls	r3, r3, #2
    29e6:	4413      	add	r3, r2
    29e8:	009b      	lsls	r3, r3, #2
    29ea:	440b      	add	r3, r1
    29ec:	332c      	adds	r3, #44	; 0x2c
    29ee:	681a      	ldr	r2, [r3, #0]
    29f0:	4914      	ldr	r1, [pc, #80]	; (2a44 <Clock_Ip_ResetClockConfiguration+0x184>)
    29f2:	4613      	mov	r3, r2
    29f4:	00db      	lsls	r3, r3, #3
    29f6:	4413      	add	r3, r2
    29f8:	440b      	add	r3, r1
    29fa:	3301      	adds	r3, #1
    29fc:	781b      	ldrb	r3, [r3, #0]
    29fe:	461a      	mov	r2, r3
    2a00:	4b17      	ldr	r3, [pc, #92]	; (2a60 <Clock_Ip_ResetClockConfiguration+0x1a0>)
    2a02:	5c9b      	ldrb	r3, [r3, r2]
    2a04:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    2a06:	4917      	ldr	r1, [pc, #92]	; (2a64 <Clock_Ip_ResetClockConfiguration+0x1a4>)
    2a08:	9a02      	ldr	r2, [sp, #8]
    2a0a:	4613      	mov	r3, r2
    2a0c:	009b      	lsls	r3, r3, #2
    2a0e:	4413      	add	r3, r2
    2a10:	009b      	lsls	r3, r3, #2
    2a12:	440b      	add	r3, r1
    2a14:	6819      	ldr	r1, [r3, #0]
    2a16:	9b03      	ldr	r3, [sp, #12]
    2a18:	1e5a      	subs	r2, r3, #1
    2a1a:	4613      	mov	r3, r2
    2a1c:	009b      	lsls	r3, r3, #2
    2a1e:	4413      	add	r3, r2
    2a20:	009b      	lsls	r3, r3, #2
    2a22:	3328      	adds	r3, #40	; 0x28
    2a24:	9a01      	ldr	r2, [sp, #4]
    2a26:	4413      	add	r3, r2
    2a28:	3304      	adds	r3, #4
    2a2a:	4618      	mov	r0, r3
    2a2c:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    2a2e:	9b03      	ldr	r3, [sp, #12]
    2a30:	3b01      	subs	r3, #1
    2a32:	9303      	str	r3, [sp, #12]
    2a34:	9b03      	ldr	r3, [sp, #12]
    2a36:	2b00      	cmp	r3, #0
    2a38:	d1d0      	bne.n	29dc <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    2a3a:	bf00      	nop
    2a3c:	bf00      	nop
    2a3e:	b005      	add	sp, #20
    2a40:	f85d fb04 	ldr.w	pc, [sp], #4
    2a44:	0000a6f0 	.word	0x0000a6f0
    2a48:	0000a6c0 	.word	0x0000a6c0
    2a4c:	0000a5f8 	.word	0x0000a5f8
    2a50:	0000a6a0 	.word	0x0000a6a0
    2a54:	0000acb8 	.word	0x0000acb8
    2a58:	0000a6b0 	.word	0x0000a6b0
    2a5c:	0000ad58 	.word	0x0000ad58
    2a60:	0000a670 	.word	0x0000a670
    2a64:	0000ac58 	.word	0x0000ac58

00002a68 <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    2a68:	b500      	push	{lr}
    2a6a:	b085      	sub	sp, #20
    2a6c:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    2a6e:	2301      	movs	r3, #1
    2a70:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    2a72:	9801      	ldr	r0, [sp, #4]
    2a74:	f000 f818 	bl	2aa8 <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    2a78:	4b0a      	ldr	r3, [pc, #40]	; (2aa4 <Clock_Ip_Init+0x3c>)
    2a7a:	781b      	ldrb	r3, [r3, #0]
    2a7c:	2b00      	cmp	r3, #0
    2a7e:	d00a      	beq.n	2a96 <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    2a80:	f000 fb74 	bl	316c <Clock_Ip_GetPllStatus>
    2a84:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    2a86:	9b02      	ldr	r3, [sp, #8]
    2a88:	2b00      	cmp	r3, #0
    2a8a:	d106      	bne.n	2a9a <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    2a8c:	f000 fbf2 	bl	3274 <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    2a90:	2300      	movs	r3, #0
    2a92:	9303      	str	r3, [sp, #12]
    2a94:	e001      	b.n	2a9a <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    2a96:	2300      	movs	r3, #0
    2a98:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    2a9a:	9b03      	ldr	r3, [sp, #12]
}
    2a9c:	4618      	mov	r0, r3
    2a9e:	b005      	add	sp, #20
    2aa0:	f85d fb04 	ldr.w	pc, [sp], #4
    2aa4:	1fff8ca8 	.word	0x1fff8ca8

00002aa8 <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    2aa8:	b510      	push	{r4, lr}
    2aaa:	b084      	sub	sp, #16
    2aac:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    2aae:	4a9f      	ldr	r2, [pc, #636]	; (2d2c <Clock_Ip_InitClock+0x284>)
    2ab0:	9b01      	ldr	r3, [sp, #4]
    2ab2:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    2ab4:	2101      	movs	r1, #1
    2ab6:	9801      	ldr	r0, [sp, #4]
    2ab8:	f7ff fc62 	bl	2380 <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    2abc:	4b9b      	ldr	r3, [pc, #620]	; (2d2c <Clock_Ip_InitClock+0x284>)
    2abe:	681b      	ldr	r3, [r3, #0]
    2ac0:	2b00      	cmp	r3, #0
    2ac2:	d030      	beq.n	2b26 <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    2ac4:	2300      	movs	r3, #0
    2ac6:	9303      	str	r3, [sp, #12]
    2ac8:	e027      	b.n	2b1a <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2aca:	9901      	ldr	r1, [sp, #4]
    2acc:	9a03      	ldr	r2, [sp, #12]
    2ace:	4613      	mov	r3, r2
    2ad0:	009b      	lsls	r3, r3, #2
    2ad2:	4413      	add	r3, r2
    2ad4:	009b      	lsls	r3, r3, #2
    2ad6:	440b      	add	r3, r1
    2ad8:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2adc:	681a      	ldr	r2, [r3, #0]
    2ade:	4994      	ldr	r1, [pc, #592]	; (2d30 <Clock_Ip_InitClock+0x288>)
    2ae0:	4613      	mov	r3, r2
    2ae2:	00db      	lsls	r3, r3, #3
    2ae4:	4413      	add	r3, r2
    2ae6:	440b      	add	r3, r1
    2ae8:	3301      	adds	r3, #1
    2aea:	781b      	ldrb	r3, [r3, #0]
    2aec:	461a      	mov	r2, r3
    2aee:	4b91      	ldr	r3, [pc, #580]	; (2d34 <Clock_Ip_InitClock+0x28c>)
    2af0:	5c9b      	ldrb	r3, [r3, r2]
    2af2:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    2af4:	4a90      	ldr	r2, [pc, #576]	; (2d38 <Clock_Ip_InitClock+0x290>)
    2af6:	9b02      	ldr	r3, [sp, #8]
    2af8:	011b      	lsls	r3, r3, #4
    2afa:	4413      	add	r3, r2
    2afc:	6819      	ldr	r1, [r3, #0]
    2afe:	9a03      	ldr	r2, [sp, #12]
    2b00:	4613      	mov	r3, r2
    2b02:	009b      	lsls	r3, r3, #2
    2b04:	4413      	add	r3, r2
    2b06:	009b      	lsls	r3, r3, #2
    2b08:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2b0c:	9a01      	ldr	r2, [sp, #4]
    2b0e:	4413      	add	r3, r2
    2b10:	4618      	mov	r0, r3
    2b12:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    2b14:	9b03      	ldr	r3, [sp, #12]
    2b16:	3301      	adds	r3, #1
    2b18:	9303      	str	r3, [sp, #12]
    2b1a:	9b01      	ldr	r3, [sp, #4]
    2b1c:	7c9b      	ldrb	r3, [r3, #18]
    2b1e:	461a      	mov	r2, r3
    2b20:	9b03      	ldr	r3, [sp, #12]
    2b22:	4293      	cmp	r3, r2
    2b24:	d3d1      	bcc.n	2aca <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    2b26:	9801      	ldr	r0, [sp, #4]
    2b28:	f7ff feca 	bl	28c0 <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    2b2c:	2300      	movs	r3, #0
    2b2e:	9303      	str	r3, [sp, #12]
    2b30:	e029      	b.n	2b86 <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    2b32:	9901      	ldr	r1, [sp, #4]
    2b34:	9a03      	ldr	r2, [sp, #12]
    2b36:	4613      	mov	r3, r2
    2b38:	005b      	lsls	r3, r3, #1
    2b3a:	4413      	add	r3, r2
    2b3c:	009b      	lsls	r3, r3, #2
    2b3e:	440b      	add	r3, r1
    2b40:	3314      	adds	r3, #20
    2b42:	681a      	ldr	r2, [r3, #0]
    2b44:	497a      	ldr	r1, [pc, #488]	; (2d30 <Clock_Ip_InitClock+0x288>)
    2b46:	4613      	mov	r3, r2
    2b48:	00db      	lsls	r3, r3, #3
    2b4a:	4413      	add	r3, r2
    2b4c:	440b      	add	r3, r1
    2b4e:	3301      	adds	r3, #1
    2b50:	781b      	ldrb	r3, [r3, #0]
    2b52:	461a      	mov	r2, r3
    2b54:	4b79      	ldr	r3, [pc, #484]	; (2d3c <Clock_Ip_InitClock+0x294>)
    2b56:	5c9b      	ldrb	r3, [r3, r2]
    2b58:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    2b5a:	4979      	ldr	r1, [pc, #484]	; (2d40 <Clock_Ip_InitClock+0x298>)
    2b5c:	9a02      	ldr	r2, [sp, #8]
    2b5e:	4613      	mov	r3, r2
    2b60:	005b      	lsls	r3, r3, #1
    2b62:	4413      	add	r3, r2
    2b64:	009b      	lsls	r3, r3, #2
    2b66:	440b      	add	r3, r1
    2b68:	6819      	ldr	r1, [r3, #0]
    2b6a:	9a03      	ldr	r2, [sp, #12]
    2b6c:	4613      	mov	r3, r2
    2b6e:	005b      	lsls	r3, r3, #1
    2b70:	4413      	add	r3, r2
    2b72:	009b      	lsls	r3, r3, #2
    2b74:	3310      	adds	r3, #16
    2b76:	9a01      	ldr	r2, [sp, #4]
    2b78:	4413      	add	r3, r2
    2b7a:	3304      	adds	r3, #4
    2b7c:	4618      	mov	r0, r3
    2b7e:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    2b80:	9b03      	ldr	r3, [sp, #12]
    2b82:	3301      	adds	r3, #1
    2b84:	9303      	str	r3, [sp, #12]
    2b86:	9b01      	ldr	r3, [sp, #4]
    2b88:	7a1b      	ldrb	r3, [r3, #8]
    2b8a:	461a      	mov	r2, r3
    2b8c:	9b03      	ldr	r3, [sp, #12]
    2b8e:	4293      	cmp	r3, r2
    2b90:	d3cf      	bcc.n	2b32 <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    2b92:	2300      	movs	r3, #0
    2b94:	9303      	str	r3, [sp, #12]
    2b96:	e02a      	b.n	2bee <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    2b98:	9901      	ldr	r1, [sp, #4]
    2b9a:	9a03      	ldr	r2, [sp, #12]
    2b9c:	4613      	mov	r3, r2
    2b9e:	009b      	lsls	r3, r3, #2
    2ba0:	4413      	add	r3, r2
    2ba2:	009b      	lsls	r3, r3, #2
    2ba4:	440b      	add	r3, r1
    2ba6:	332c      	adds	r3, #44	; 0x2c
    2ba8:	681a      	ldr	r2, [r3, #0]
    2baa:	4961      	ldr	r1, [pc, #388]	; (2d30 <Clock_Ip_InitClock+0x288>)
    2bac:	4613      	mov	r3, r2
    2bae:	00db      	lsls	r3, r3, #3
    2bb0:	4413      	add	r3, r2
    2bb2:	440b      	add	r3, r1
    2bb4:	3301      	adds	r3, #1
    2bb6:	781b      	ldrb	r3, [r3, #0]
    2bb8:	461a      	mov	r2, r3
    2bba:	4b62      	ldr	r3, [pc, #392]	; (2d44 <Clock_Ip_InitClock+0x29c>)
    2bbc:	5c9b      	ldrb	r3, [r3, r2]
    2bbe:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    2bc0:	4961      	ldr	r1, [pc, #388]	; (2d48 <Clock_Ip_InitClock+0x2a0>)
    2bc2:	9a02      	ldr	r2, [sp, #8]
    2bc4:	4613      	mov	r3, r2
    2bc6:	009b      	lsls	r3, r3, #2
    2bc8:	4413      	add	r3, r2
    2bca:	009b      	lsls	r3, r3, #2
    2bcc:	440b      	add	r3, r1
    2bce:	3304      	adds	r3, #4
    2bd0:	6819      	ldr	r1, [r3, #0]
    2bd2:	9a03      	ldr	r2, [sp, #12]
    2bd4:	4613      	mov	r3, r2
    2bd6:	009b      	lsls	r3, r3, #2
    2bd8:	4413      	add	r3, r2
    2bda:	009b      	lsls	r3, r3, #2
    2bdc:	3328      	adds	r3, #40	; 0x28
    2bde:	9a01      	ldr	r2, [sp, #4]
    2be0:	4413      	add	r3, r2
    2be2:	3304      	adds	r3, #4
    2be4:	4618      	mov	r0, r3
    2be6:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    2be8:	9b03      	ldr	r3, [sp, #12]
    2bea:	3301      	adds	r3, #1
    2bec:	9303      	str	r3, [sp, #12]
    2bee:	9b01      	ldr	r3, [sp, #4]
    2bf0:	7a5b      	ldrb	r3, [r3, #9]
    2bf2:	461a      	mov	r2, r3
    2bf4:	9b03      	ldr	r3, [sp, #12]
    2bf6:	4293      	cmp	r3, r2
    2bf8:	d3ce      	bcc.n	2b98 <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    2bfa:	9801      	ldr	r0, [sp, #4]
    2bfc:	f7ff fdb0 	bl	2760 <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    2c00:	2300      	movs	r3, #0
    2c02:	9303      	str	r3, [sp, #12]
    2c04:	e028      	b.n	2c58 <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    2c06:	9901      	ldr	r1, [sp, #4]
    2c08:	9a03      	ldr	r2, [sp, #12]
    2c0a:	4613      	mov	r3, r2
    2c0c:	009b      	lsls	r3, r3, #2
    2c0e:	4413      	add	r3, r2
    2c10:	009b      	lsls	r3, r3, #2
    2c12:	440b      	add	r3, r1
    2c14:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    2c18:	681a      	ldr	r2, [r3, #0]
    2c1a:	4945      	ldr	r1, [pc, #276]	; (2d30 <Clock_Ip_InitClock+0x288>)
    2c1c:	4613      	mov	r3, r2
    2c1e:	00db      	lsls	r3, r3, #3
    2c20:	4413      	add	r3, r2
    2c22:	440b      	add	r3, r1
    2c24:	3301      	adds	r3, #1
    2c26:	781b      	ldrb	r3, [r3, #0]
    2c28:	461a      	mov	r2, r3
    2c2a:	4b48      	ldr	r3, [pc, #288]	; (2d4c <Clock_Ip_InitClock+0x2a4>)
    2c2c:	5c9b      	ldrb	r3, [r3, r2]
    2c2e:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    2c30:	4a47      	ldr	r2, [pc, #284]	; (2d50 <Clock_Ip_InitClock+0x2a8>)
    2c32:	9b02      	ldr	r3, [sp, #8]
    2c34:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    2c38:	9a03      	ldr	r2, [sp, #12]
    2c3a:	4613      	mov	r3, r2
    2c3c:	009b      	lsls	r3, r3, #2
    2c3e:	4413      	add	r3, r2
    2c40:	009b      	lsls	r3, r3, #2
    2c42:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    2c46:	9a01      	ldr	r2, [sp, #4]
    2c48:	4413      	add	r3, r2
    2c4a:	3304      	adds	r3, #4
    2c4c:	9903      	ldr	r1, [sp, #12]
    2c4e:	4618      	mov	r0, r3
    2c50:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    2c52:	9b03      	ldr	r3, [sp, #12]
    2c54:	3301      	adds	r3, #1
    2c56:	9303      	str	r3, [sp, #12]
    2c58:	9b01      	ldr	r3, [sp, #4]
    2c5a:	7c5b      	ldrb	r3, [r3, #17]
    2c5c:	461a      	mov	r2, r3
    2c5e:	9b03      	ldr	r3, [sp, #12]
    2c60:	4293      	cmp	r3, r2
    2c62:	d3d0      	bcc.n	2c06 <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2c64:	2300      	movs	r3, #0
    2c66:	9303      	str	r3, [sp, #12]
    2c68:	e026      	b.n	2cb8 <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    2c6a:	9901      	ldr	r1, [sp, #4]
    2c6c:	9a03      	ldr	r2, [sp, #12]
    2c6e:	4613      	mov	r3, r2
    2c70:	005b      	lsls	r3, r3, #1
    2c72:	4413      	add	r3, r2
    2c74:	009b      	lsls	r3, r3, #2
    2c76:	440b      	add	r3, r1
    2c78:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2c7c:	681a      	ldr	r2, [r3, #0]
    2c7e:	492c      	ldr	r1, [pc, #176]	; (2d30 <Clock_Ip_InitClock+0x288>)
    2c80:	4613      	mov	r3, r2
    2c82:	00db      	lsls	r3, r3, #3
    2c84:	4413      	add	r3, r2
    2c86:	440b      	add	r3, r1
    2c88:	3301      	adds	r3, #1
    2c8a:	781b      	ldrb	r3, [r3, #0]
    2c8c:	461a      	mov	r2, r3
    2c8e:	4b31      	ldr	r3, [pc, #196]	; (2d54 <Clock_Ip_InitClock+0x2ac>)
    2c90:	5c9b      	ldrb	r3, [r3, r2]
    2c92:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    2c94:	4a30      	ldr	r2, [pc, #192]	; (2d58 <Clock_Ip_InitClock+0x2b0>)
    2c96:	9b02      	ldr	r3, [sp, #8]
    2c98:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    2c9c:	9a03      	ldr	r2, [sp, #12]
    2c9e:	4613      	mov	r3, r2
    2ca0:	005b      	lsls	r3, r3, #1
    2ca2:	4413      	add	r3, r2
    2ca4:	009b      	lsls	r3, r3, #2
    2ca6:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2caa:	9a01      	ldr	r2, [sp, #4]
    2cac:	4413      	add	r3, r2
    2cae:	4618      	mov	r0, r3
    2cb0:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2cb2:	9b03      	ldr	r3, [sp, #12]
    2cb4:	3301      	adds	r3, #1
    2cb6:	9303      	str	r3, [sp, #12]
    2cb8:	9b01      	ldr	r3, [sp, #4]
    2cba:	7b5b      	ldrb	r3, [r3, #13]
    2cbc:	461a      	mov	r2, r3
    2cbe:	9b03      	ldr	r3, [sp, #12]
    2cc0:	4293      	cmp	r3, r2
    2cc2:	d3d2      	bcc.n	2c6a <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    2cc4:	2300      	movs	r3, #0
    2cc6:	9303      	str	r3, [sp, #12]
    2cc8:	e026      	b.n	2d18 <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    2cca:	9901      	ldr	r1, [sp, #4]
    2ccc:	9a03      	ldr	r2, [sp, #12]
    2cce:	4613      	mov	r3, r2
    2cd0:	005b      	lsls	r3, r3, #1
    2cd2:	4413      	add	r3, r2
    2cd4:	009b      	lsls	r3, r3, #2
    2cd6:	440b      	add	r3, r1
    2cd8:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    2cdc:	681a      	ldr	r2, [r3, #0]
    2cde:	4914      	ldr	r1, [pc, #80]	; (2d30 <Clock_Ip_InitClock+0x288>)
    2ce0:	4613      	mov	r3, r2
    2ce2:	00db      	lsls	r3, r3, #3
    2ce4:	4413      	add	r3, r2
    2ce6:	440b      	add	r3, r1
    2ce8:	3301      	adds	r3, #1
    2cea:	781b      	ldrb	r3, [r3, #0]
    2cec:	461a      	mov	r2, r3
    2cee:	4b1b      	ldr	r3, [pc, #108]	; (2d5c <Clock_Ip_InitClock+0x2b4>)
    2cf0:	5c9b      	ldrb	r3, [r3, r2]
    2cf2:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    2cf4:	4a1a      	ldr	r2, [pc, #104]	; (2d60 <Clock_Ip_InitClock+0x2b8>)
    2cf6:	9b02      	ldr	r3, [sp, #8]
    2cf8:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    2cfc:	9a03      	ldr	r2, [sp, #12]
    2cfe:	4613      	mov	r3, r2
    2d00:	005b      	lsls	r3, r3, #1
    2d02:	4413      	add	r3, r2
    2d04:	009b      	lsls	r3, r3, #2
    2d06:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    2d0a:	9a01      	ldr	r2, [sp, #4]
    2d0c:	4413      	add	r3, r2
    2d0e:	4618      	mov	r0, r3
    2d10:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    2d12:	9b03      	ldr	r3, [sp, #12]
    2d14:	3301      	adds	r3, #1
    2d16:	9303      	str	r3, [sp, #12]
    2d18:	9b01      	ldr	r3, [sp, #4]
    2d1a:	7b1b      	ldrb	r3, [r3, #12]
    2d1c:	461a      	mov	r2, r3
    2d1e:	9b03      	ldr	r3, [sp, #12]
    2d20:	4293      	cmp	r3, r2
    2d22:	d3d2      	bcc.n	2cca <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2d24:	2300      	movs	r3, #0
    2d26:	9303      	str	r3, [sp, #12]
    2d28:	e044      	b.n	2db4 <Clock_Ip_InitClock+0x30c>
    2d2a:	bf00      	nop
    2d2c:	1fff8ca0 	.word	0x1fff8ca0
    2d30:	0000a6f0 	.word	0x0000a6f0
    2d34:	0000a6e0 	.word	0x0000a6e0
    2d38:	0000ad08 	.word	0x0000ad08
    2d3c:	0000a680 	.word	0x0000a680
    2d40:	0000accc 	.word	0x0000accc
    2d44:	0000a670 	.word	0x0000a670
    2d48:	0000ac58 	.word	0x0000ac58
    2d4c:	0000a6d0 	.word	0x0000a6d0
    2d50:	0000ad54 	.word	0x0000ad54
    2d54:	0000a660 	.word	0x0000a660
    2d58:	0000acc4 	.word	0x0000acc4
    2d5c:	0000a650 	.word	0x0000a650
    2d60:	0000ad18 	.word	0x0000ad18
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    2d64:	9901      	ldr	r1, [sp, #4]
    2d66:	9a03      	ldr	r2, [sp, #12]
    2d68:	4613      	mov	r3, r2
    2d6a:	005b      	lsls	r3, r3, #1
    2d6c:	4413      	add	r3, r2
    2d6e:	009b      	lsls	r3, r3, #2
    2d70:	440b      	add	r3, r1
    2d72:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2d76:	681a      	ldr	r2, [r3, #0]
    2d78:	49ac      	ldr	r1, [pc, #688]	; (302c <Clock_Ip_InitClock+0x584>)
    2d7a:	4613      	mov	r3, r2
    2d7c:	00db      	lsls	r3, r3, #3
    2d7e:	4413      	add	r3, r2
    2d80:	440b      	add	r3, r1
    2d82:	3301      	adds	r3, #1
    2d84:	781b      	ldrb	r3, [r3, #0]
    2d86:	461a      	mov	r2, r3
    2d88:	4ba9      	ldr	r3, [pc, #676]	; (3030 <Clock_Ip_InitClock+0x588>)
    2d8a:	5c9b      	ldrb	r3, [r3, r2]
    2d8c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    2d8e:	4aa9      	ldr	r2, [pc, #676]	; (3034 <Clock_Ip_InitClock+0x58c>)
    2d90:	9b02      	ldr	r3, [sp, #8]
    2d92:	00db      	lsls	r3, r3, #3
    2d94:	4413      	add	r3, r2
    2d96:	6859      	ldr	r1, [r3, #4]
    2d98:	9a03      	ldr	r2, [sp, #12]
    2d9a:	4613      	mov	r3, r2
    2d9c:	005b      	lsls	r3, r3, #1
    2d9e:	4413      	add	r3, r2
    2da0:	009b      	lsls	r3, r3, #2
    2da2:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2da6:	9a01      	ldr	r2, [sp, #4]
    2da8:	4413      	add	r3, r2
    2daa:	4618      	mov	r0, r3
    2dac:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2dae:	9b03      	ldr	r3, [sp, #12]
    2db0:	3301      	adds	r3, #1
    2db2:	9303      	str	r3, [sp, #12]
    2db4:	9b01      	ldr	r3, [sp, #4]
    2db6:	7b5b      	ldrb	r3, [r3, #13]
    2db8:	461a      	mov	r2, r3
    2dba:	9b03      	ldr	r3, [sp, #12]
    2dbc:	4293      	cmp	r3, r2
    2dbe:	d3d1      	bcc.n	2d64 <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    2dc0:	2300      	movs	r3, #0
    2dc2:	9303      	str	r3, [sp, #12]
    2dc4:	e029      	b.n	2e1a <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    2dc6:	9901      	ldr	r1, [sp, #4]
    2dc8:	9a03      	ldr	r2, [sp, #12]
    2dca:	4613      	mov	r3, r2
    2dcc:	009b      	lsls	r3, r3, #2
    2dce:	4413      	add	r3, r2
    2dd0:	00db      	lsls	r3, r3, #3
    2dd2:	440b      	add	r3, r1
    2dd4:	3340      	adds	r3, #64	; 0x40
    2dd6:	681a      	ldr	r2, [r3, #0]
    2dd8:	4994      	ldr	r1, [pc, #592]	; (302c <Clock_Ip_InitClock+0x584>)
    2dda:	4613      	mov	r3, r2
    2ddc:	00db      	lsls	r3, r3, #3
    2dde:	4413      	add	r3, r2
    2de0:	440b      	add	r3, r1
    2de2:	3301      	adds	r3, #1
    2de4:	781b      	ldrb	r3, [r3, #0]
    2de6:	461a      	mov	r2, r3
    2de8:	4b93      	ldr	r3, [pc, #588]	; (3038 <Clock_Ip_InitClock+0x590>)
    2dea:	5c9b      	ldrb	r3, [r3, r2]
    2dec:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    2dee:	4993      	ldr	r1, [pc, #588]	; (303c <Clock_Ip_InitClock+0x594>)
    2df0:	9a02      	ldr	r2, [sp, #8]
    2df2:	4613      	mov	r3, r2
    2df4:	009b      	lsls	r3, r3, #2
    2df6:	4413      	add	r3, r2
    2df8:	009b      	lsls	r3, r3, #2
    2dfa:	440b      	add	r3, r1
    2dfc:	3304      	adds	r3, #4
    2dfe:	6819      	ldr	r1, [r3, #0]
    2e00:	9a03      	ldr	r2, [sp, #12]
    2e02:	4613      	mov	r3, r2
    2e04:	009b      	lsls	r3, r3, #2
    2e06:	4413      	add	r3, r2
    2e08:	00db      	lsls	r3, r3, #3
    2e0a:	3340      	adds	r3, #64	; 0x40
    2e0c:	9a01      	ldr	r2, [sp, #4]
    2e0e:	4413      	add	r3, r2
    2e10:	4618      	mov	r0, r3
    2e12:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    2e14:	9b03      	ldr	r3, [sp, #12]
    2e16:	3301      	adds	r3, #1
    2e18:	9303      	str	r3, [sp, #12]
    2e1a:	9b01      	ldr	r3, [sp, #4]
    2e1c:	7a9b      	ldrb	r3, [r3, #10]
    2e1e:	461a      	mov	r2, r3
    2e20:	9b03      	ldr	r3, [sp, #12]
    2e22:	4293      	cmp	r3, r2
    2e24:	d3cf      	bcc.n	2dc6 <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    2e26:	2300      	movs	r3, #0
    2e28:	9303      	str	r3, [sp, #12]
    2e2a:	e029      	b.n	2e80 <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2e2c:	9901      	ldr	r1, [sp, #4]
    2e2e:	9a03      	ldr	r2, [sp, #12]
    2e30:	4613      	mov	r3, r2
    2e32:	009b      	lsls	r3, r3, #2
    2e34:	4413      	add	r3, r2
    2e36:	009b      	lsls	r3, r3, #2
    2e38:	440b      	add	r3, r1
    2e3a:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2e3e:	681a      	ldr	r2, [r3, #0]
    2e40:	497a      	ldr	r1, [pc, #488]	; (302c <Clock_Ip_InitClock+0x584>)
    2e42:	4613      	mov	r3, r2
    2e44:	00db      	lsls	r3, r3, #3
    2e46:	4413      	add	r3, r2
    2e48:	440b      	add	r3, r1
    2e4a:	3301      	adds	r3, #1
    2e4c:	781b      	ldrb	r3, [r3, #0]
    2e4e:	461a      	mov	r2, r3
    2e50:	4b7b      	ldr	r3, [pc, #492]	; (3040 <Clock_Ip_InitClock+0x598>)
    2e52:	5c9b      	ldrb	r3, [r3, r2]
    2e54:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    2e56:	4a7b      	ldr	r2, [pc, #492]	; (3044 <Clock_Ip_InitClock+0x59c>)
    2e58:	9b02      	ldr	r3, [sp, #8]
    2e5a:	011b      	lsls	r3, r3, #4
    2e5c:	4413      	add	r3, r2
    2e5e:	3304      	adds	r3, #4
    2e60:	681c      	ldr	r4, [r3, #0]
    2e62:	9a03      	ldr	r2, [sp, #12]
    2e64:	4613      	mov	r3, r2
    2e66:	009b      	lsls	r3, r3, #2
    2e68:	4413      	add	r3, r2
    2e6a:	009b      	lsls	r3, r3, #2
    2e6c:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2e70:	9a01      	ldr	r2, [sp, #4]
    2e72:	4413      	add	r3, r2
    2e74:	9903      	ldr	r1, [sp, #12]
    2e76:	4618      	mov	r0, r3
    2e78:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    2e7a:	9b03      	ldr	r3, [sp, #12]
    2e7c:	3301      	adds	r3, #1
    2e7e:	9303      	str	r3, [sp, #12]
    2e80:	9b01      	ldr	r3, [sp, #4]
    2e82:	7c9b      	ldrb	r3, [r3, #18]
    2e84:	461a      	mov	r2, r3
    2e86:	9b03      	ldr	r3, [sp, #12]
    2e88:	4293      	cmp	r3, r2
    2e8a:	d3cf      	bcc.n	2e2c <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2e8c:	2300      	movs	r3, #0
    2e8e:	9303      	str	r3, [sp, #12]
    2e90:	e02a      	b.n	2ee8 <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    2e92:	9901      	ldr	r1, [sp, #4]
    2e94:	9a03      	ldr	r2, [sp, #12]
    2e96:	4613      	mov	r3, r2
    2e98:	009b      	lsls	r3, r3, #2
    2e9a:	4413      	add	r3, r2
    2e9c:	009b      	lsls	r3, r3, #2
    2e9e:	440b      	add	r3, r1
    2ea0:	332c      	adds	r3, #44	; 0x2c
    2ea2:	681a      	ldr	r2, [r3, #0]
    2ea4:	4961      	ldr	r1, [pc, #388]	; (302c <Clock_Ip_InitClock+0x584>)
    2ea6:	4613      	mov	r3, r2
    2ea8:	00db      	lsls	r3, r3, #3
    2eaa:	4413      	add	r3, r2
    2eac:	440b      	add	r3, r1
    2eae:	3301      	adds	r3, #1
    2eb0:	781b      	ldrb	r3, [r3, #0]
    2eb2:	461a      	mov	r2, r3
    2eb4:	4b64      	ldr	r3, [pc, #400]	; (3048 <Clock_Ip_InitClock+0x5a0>)
    2eb6:	5c9b      	ldrb	r3, [r3, r2]
    2eb8:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    2eba:	4964      	ldr	r1, [pc, #400]	; (304c <Clock_Ip_InitClock+0x5a4>)
    2ebc:	9a02      	ldr	r2, [sp, #8]
    2ebe:	4613      	mov	r3, r2
    2ec0:	009b      	lsls	r3, r3, #2
    2ec2:	4413      	add	r3, r2
    2ec4:	009b      	lsls	r3, r3, #2
    2ec6:	440b      	add	r3, r1
    2ec8:	3308      	adds	r3, #8
    2eca:	6819      	ldr	r1, [r3, #0]
    2ecc:	9a03      	ldr	r2, [sp, #12]
    2ece:	4613      	mov	r3, r2
    2ed0:	009b      	lsls	r3, r3, #2
    2ed2:	4413      	add	r3, r2
    2ed4:	009b      	lsls	r3, r3, #2
    2ed6:	3328      	adds	r3, #40	; 0x28
    2ed8:	9a01      	ldr	r2, [sp, #4]
    2eda:	4413      	add	r3, r2
    2edc:	3304      	adds	r3, #4
    2ede:	4618      	mov	r0, r3
    2ee0:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2ee2:	9b03      	ldr	r3, [sp, #12]
    2ee4:	3301      	adds	r3, #1
    2ee6:	9303      	str	r3, [sp, #12]
    2ee8:	9b01      	ldr	r3, [sp, #4]
    2eea:	7a5b      	ldrb	r3, [r3, #9]
    2eec:	461a      	mov	r2, r3
    2eee:	9b03      	ldr	r3, [sp, #12]
    2ef0:	4293      	cmp	r3, r2
    2ef2:	d3ce      	bcc.n	2e92 <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2ef4:	2300      	movs	r3, #0
    2ef6:	9303      	str	r3, [sp, #12]
    2ef8:	e029      	b.n	2f4e <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    2efa:	9901      	ldr	r1, [sp, #4]
    2efc:	9a03      	ldr	r2, [sp, #12]
    2efe:	4613      	mov	r3, r2
    2f00:	009b      	lsls	r3, r3, #2
    2f02:	4413      	add	r3, r2
    2f04:	00db      	lsls	r3, r3, #3
    2f06:	440b      	add	r3, r1
    2f08:	3340      	adds	r3, #64	; 0x40
    2f0a:	681a      	ldr	r2, [r3, #0]
    2f0c:	4947      	ldr	r1, [pc, #284]	; (302c <Clock_Ip_InitClock+0x584>)
    2f0e:	4613      	mov	r3, r2
    2f10:	00db      	lsls	r3, r3, #3
    2f12:	4413      	add	r3, r2
    2f14:	440b      	add	r3, r1
    2f16:	3301      	adds	r3, #1
    2f18:	781b      	ldrb	r3, [r3, #0]
    2f1a:	461a      	mov	r2, r3
    2f1c:	4b46      	ldr	r3, [pc, #280]	; (3038 <Clock_Ip_InitClock+0x590>)
    2f1e:	5c9b      	ldrb	r3, [r3, r2]
    2f20:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    2f22:	4946      	ldr	r1, [pc, #280]	; (303c <Clock_Ip_InitClock+0x594>)
    2f24:	9a02      	ldr	r2, [sp, #8]
    2f26:	4613      	mov	r3, r2
    2f28:	009b      	lsls	r3, r3, #2
    2f2a:	4413      	add	r3, r2
    2f2c:	009b      	lsls	r3, r3, #2
    2f2e:	440b      	add	r3, r1
    2f30:	330c      	adds	r3, #12
    2f32:	6819      	ldr	r1, [r3, #0]
    2f34:	9a03      	ldr	r2, [sp, #12]
    2f36:	4613      	mov	r3, r2
    2f38:	009b      	lsls	r3, r3, #2
    2f3a:	4413      	add	r3, r2
    2f3c:	00db      	lsls	r3, r3, #3
    2f3e:	3340      	adds	r3, #64	; 0x40
    2f40:	9a01      	ldr	r2, [sp, #4]
    2f42:	4413      	add	r3, r2
    2f44:	4618      	mov	r0, r3
    2f46:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2f48:	9b03      	ldr	r3, [sp, #12]
    2f4a:	3301      	adds	r3, #1
    2f4c:	9303      	str	r3, [sp, #12]
    2f4e:	9b01      	ldr	r3, [sp, #4]
    2f50:	7a9b      	ldrb	r3, [r3, #10]
    2f52:	461a      	mov	r2, r3
    2f54:	9b03      	ldr	r3, [sp, #12]
    2f56:	4293      	cmp	r3, r2
    2f58:	d3cf      	bcc.n	2efa <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    2f5a:	2300      	movs	r3, #0
    2f5c:	9303      	str	r3, [sp, #12]
    2f5e:	e025      	b.n	2fac <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    2f60:	9a01      	ldr	r2, [sp, #4]
    2f62:	9b03      	ldr	r3, [sp, #12]
    2f64:	3324      	adds	r3, #36	; 0x24
    2f66:	011b      	lsls	r3, r3, #4
    2f68:	4413      	add	r3, r2
    2f6a:	3304      	adds	r3, #4
    2f6c:	681a      	ldr	r2, [r3, #0]
    2f6e:	492f      	ldr	r1, [pc, #188]	; (302c <Clock_Ip_InitClock+0x584>)
    2f70:	4613      	mov	r3, r2
    2f72:	00db      	lsls	r3, r3, #3
    2f74:	4413      	add	r3, r2
    2f76:	440b      	add	r3, r1
    2f78:	3301      	adds	r3, #1
    2f7a:	781b      	ldrb	r3, [r3, #0]
    2f7c:	461a      	mov	r2, r3
    2f7e:	4b34      	ldr	r3, [pc, #208]	; (3050 <Clock_Ip_InitClock+0x5a8>)
    2f80:	5c9b      	ldrb	r3, [r3, r2]
    2f82:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    2f84:	4933      	ldr	r1, [pc, #204]	; (3054 <Clock_Ip_InitClock+0x5ac>)
    2f86:	9a02      	ldr	r2, [sp, #8]
    2f88:	4613      	mov	r3, r2
    2f8a:	005b      	lsls	r3, r3, #1
    2f8c:	4413      	add	r3, r2
    2f8e:	009b      	lsls	r3, r3, #2
    2f90:	440b      	add	r3, r1
    2f92:	3304      	adds	r3, #4
    2f94:	681b      	ldr	r3, [r3, #0]
    2f96:	9a03      	ldr	r2, [sp, #12]
    2f98:	3224      	adds	r2, #36	; 0x24
    2f9a:	0112      	lsls	r2, r2, #4
    2f9c:	9901      	ldr	r1, [sp, #4]
    2f9e:	440a      	add	r2, r1
    2fa0:	3204      	adds	r2, #4
    2fa2:	4610      	mov	r0, r2
    2fa4:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    2fa6:	9b03      	ldr	r3, [sp, #12]
    2fa8:	3301      	adds	r3, #1
    2faa:	9303      	str	r3, [sp, #12]
    2fac:	9b01      	ldr	r3, [sp, #4]
    2fae:	7b9b      	ldrb	r3, [r3, #14]
    2fb0:	461a      	mov	r2, r3
    2fb2:	9b03      	ldr	r3, [sp, #12]
    2fb4:	4293      	cmp	r3, r2
    2fb6:	d3d3      	bcc.n	2f60 <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    2fb8:	4b27      	ldr	r3, [pc, #156]	; (3058 <Clock_Ip_InitClock+0x5b0>)
    2fba:	2200      	movs	r2, #0
    2fbc:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    2fbe:	4b26      	ldr	r3, [pc, #152]	; (3058 <Clock_Ip_InitClock+0x5b0>)
    2fc0:	2200      	movs	r2, #0
    2fc2:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    2fc4:	4b24      	ldr	r3, [pc, #144]	; (3058 <Clock_Ip_InitClock+0x5b0>)
    2fc6:	2201      	movs	r2, #1
    2fc8:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    2fca:	4b23      	ldr	r3, [pc, #140]	; (3058 <Clock_Ip_InitClock+0x5b0>)
    2fcc:	2200      	movs	r2, #0
    2fce:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    2fd0:	f000 fa9c 	bl	350c <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    2fd4:	2300      	movs	r3, #0
    2fd6:	9303      	str	r3, [sp, #12]
    2fd8:	e04c      	b.n	3074 <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    2fda:	9a01      	ldr	r2, [sp, #4]
    2fdc:	9b03      	ldr	r3, [sp, #12]
    2fde:	330d      	adds	r3, #13
    2fe0:	00db      	lsls	r3, r3, #3
    2fe2:	4413      	add	r3, r2
    2fe4:	685b      	ldr	r3, [r3, #4]
    2fe6:	4a1d      	ldr	r2, [pc, #116]	; (305c <Clock_Ip_InitClock+0x5b4>)
    2fe8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2fec:	2b03      	cmp	r3, #3
    2fee:	d03b      	beq.n	3068 <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    2ff0:	9b01      	ldr	r3, [sp, #4]
    2ff2:	9a03      	ldr	r2, [sp, #12]
    2ff4:	320d      	adds	r2, #13
    2ff6:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    2ffa:	490c      	ldr	r1, [pc, #48]	; (302c <Clock_Ip_InitClock+0x584>)
    2ffc:	4613      	mov	r3, r2
    2ffe:	00db      	lsls	r3, r3, #3
    3000:	4413      	add	r3, r2
    3002:	440b      	add	r3, r1
    3004:	3301      	adds	r3, #1
    3006:	781b      	ldrb	r3, [r3, #0]
    3008:	461a      	mov	r2, r3
    300a:	4b15      	ldr	r3, [pc, #84]	; (3060 <Clock_Ip_InitClock+0x5b8>)
    300c:	5c9b      	ldrb	r3, [r3, r2]
    300e:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    3010:	4a14      	ldr	r2, [pc, #80]	; (3064 <Clock_Ip_InitClock+0x5bc>)
    3012:	9b02      	ldr	r3, [sp, #8]
    3014:	00db      	lsls	r3, r3, #3
    3016:	4413      	add	r3, r2
    3018:	685b      	ldr	r3, [r3, #4]
    301a:	9a03      	ldr	r2, [sp, #12]
    301c:	320d      	adds	r2, #13
    301e:	00d2      	lsls	r2, r2, #3
    3020:	9901      	ldr	r1, [sp, #4]
    3022:	440a      	add	r2, r1
    3024:	4610      	mov	r0, r2
    3026:	4798      	blx	r3
    3028:	e021      	b.n	306e <Clock_Ip_InitClock+0x5c6>
    302a:	bf00      	nop
    302c:	0000a6f0 	.word	0x0000a6f0
    3030:	0000a660 	.word	0x0000a660
    3034:	0000acc4 	.word	0x0000acc4
    3038:	0000a6b0 	.word	0x0000a6b0
    303c:	0000ad58 	.word	0x0000ad58
    3040:	0000a6e0 	.word	0x0000a6e0
    3044:	0000ad08 	.word	0x0000ad08
    3048:	0000a670 	.word	0x0000a670
    304c:	0000ac58 	.word	0x0000ac58
    3050:	0000a6a0 	.word	0x0000a6a0
    3054:	0000acb8 	.word	0x0000acb8
    3058:	1fff8ca8 	.word	0x1fff8ca8
    305c:	0000ab3c 	.word	0x0000ab3c
    3060:	0000a6c0 	.word	0x0000a6c0
    3064:	0000a5f8 	.word	0x0000a5f8
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    3068:	4b3a      	ldr	r3, [pc, #232]	; (3154 <Clock_Ip_InitClock+0x6ac>)
    306a:	2201      	movs	r2, #1
    306c:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    306e:	9b03      	ldr	r3, [sp, #12]
    3070:	3301      	adds	r3, #1
    3072:	9303      	str	r3, [sp, #12]
    3074:	9b01      	ldr	r3, [sp, #4]
    3076:	7adb      	ldrb	r3, [r3, #11]
    3078:	461a      	mov	r2, r3
    307a:	9b03      	ldr	r3, [sp, #12]
    307c:	4293      	cmp	r3, r2
    307e:	d3ac      	bcc.n	2fda <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    3080:	4b34      	ldr	r3, [pc, #208]	; (3154 <Clock_Ip_InitClock+0x6ac>)
    3082:	781b      	ldrb	r3, [r3, #0]
    3084:	f083 0301 	eor.w	r3, r3, #1
    3088:	b2db      	uxtb	r3, r3
    308a:	2b00      	cmp	r3, #0
    308c:	d05e      	beq.n	314c <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    308e:	2300      	movs	r3, #0
    3090:	9303      	str	r3, [sp, #12]
    3092:	e01f      	b.n	30d4 <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    3094:	9a01      	ldr	r2, [sp, #4]
    3096:	9b03      	ldr	r3, [sp, #12]
    3098:	334e      	adds	r3, #78	; 0x4e
    309a:	00db      	lsls	r3, r3, #3
    309c:	4413      	add	r3, r2
    309e:	685a      	ldr	r2, [r3, #4]
    30a0:	492d      	ldr	r1, [pc, #180]	; (3158 <Clock_Ip_InitClock+0x6b0>)
    30a2:	4613      	mov	r3, r2
    30a4:	00db      	lsls	r3, r3, #3
    30a6:	4413      	add	r3, r2
    30a8:	440b      	add	r3, r1
    30aa:	3301      	adds	r3, #1
    30ac:	781b      	ldrb	r3, [r3, #0]
    30ae:	461a      	mov	r2, r3
    30b0:	4b2a      	ldr	r3, [pc, #168]	; (315c <Clock_Ip_InitClock+0x6b4>)
    30b2:	5c9b      	ldrb	r3, [r3, r2]
    30b4:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    30b6:	4a2a      	ldr	r2, [pc, #168]	; (3160 <Clock_Ip_InitClock+0x6b8>)
    30b8:	9b02      	ldr	r3, [sp, #8]
    30ba:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    30be:	9a03      	ldr	r2, [sp, #12]
    30c0:	324e      	adds	r2, #78	; 0x4e
    30c2:	00d2      	lsls	r2, r2, #3
    30c4:	9901      	ldr	r1, [sp, #4]
    30c6:	440a      	add	r2, r1
    30c8:	3204      	adds	r2, #4
    30ca:	4610      	mov	r0, r2
    30cc:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    30ce:	9b03      	ldr	r3, [sp, #12]
    30d0:	3301      	adds	r3, #1
    30d2:	9303      	str	r3, [sp, #12]
    30d4:	9b01      	ldr	r3, [sp, #4]
    30d6:	7c1b      	ldrb	r3, [r3, #16]
    30d8:	461a      	mov	r2, r3
    30da:	9b03      	ldr	r3, [sp, #12]
    30dc:	4293      	cmp	r3, r2
    30de:	d3d9      	bcc.n	3094 <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    30e0:	2300      	movs	r3, #0
    30e2:	9303      	str	r3, [sp, #12]
    30e4:	e028      	b.n	3138 <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    30e6:	9901      	ldr	r1, [sp, #4]
    30e8:	9a03      	ldr	r2, [sp, #12]
    30ea:	4613      	mov	r3, r2
    30ec:	009b      	lsls	r3, r3, #2
    30ee:	4413      	add	r3, r2
    30f0:	009b      	lsls	r3, r3, #2
    30f2:	440b      	add	r3, r1
    30f4:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    30f8:	681a      	ldr	r2, [r3, #0]
    30fa:	4917      	ldr	r1, [pc, #92]	; (3158 <Clock_Ip_InitClock+0x6b0>)
    30fc:	4613      	mov	r3, r2
    30fe:	00db      	lsls	r3, r3, #3
    3100:	4413      	add	r3, r2
    3102:	440b      	add	r3, r1
    3104:	3301      	adds	r3, #1
    3106:	781b      	ldrb	r3, [r3, #0]
    3108:	461a      	mov	r2, r3
    310a:	4b16      	ldr	r3, [pc, #88]	; (3164 <Clock_Ip_InitClock+0x6bc>)
    310c:	5c9b      	ldrb	r3, [r3, r2]
    310e:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    3110:	4a15      	ldr	r2, [pc, #84]	; (3168 <Clock_Ip_InitClock+0x6c0>)
    3112:	9b02      	ldr	r3, [sp, #8]
    3114:	011b      	lsls	r3, r3, #4
    3116:	4413      	add	r3, r2
    3118:	330c      	adds	r3, #12
    311a:	6819      	ldr	r1, [r3, #0]
    311c:	9a03      	ldr	r2, [sp, #12]
    311e:	4613      	mov	r3, r2
    3120:	009b      	lsls	r3, r3, #2
    3122:	4413      	add	r3, r2
    3124:	009b      	lsls	r3, r3, #2
    3126:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    312a:	9a01      	ldr	r2, [sp, #4]
    312c:	4413      	add	r3, r2
    312e:	4618      	mov	r0, r3
    3130:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    3132:	9b03      	ldr	r3, [sp, #12]
    3134:	3301      	adds	r3, #1
    3136:	9303      	str	r3, [sp, #12]
    3138:	9b01      	ldr	r3, [sp, #4]
    313a:	7c9b      	ldrb	r3, [r3, #18]
    313c:	461a      	mov	r2, r3
    313e:	9b03      	ldr	r3, [sp, #12]
    3140:	4293      	cmp	r3, r2
    3142:	d3d0      	bcc.n	30e6 <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    3144:	2104      	movs	r1, #4
    3146:	9801      	ldr	r0, [sp, #4]
    3148:	f7ff f91a 	bl	2380 <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    314c:	bf00      	nop
    314e:	b004      	add	sp, #16
    3150:	bd10      	pop	{r4, pc}
    3152:	bf00      	nop
    3154:	1fff8ca8 	.word	0x1fff8ca8
    3158:	0000a6f0 	.word	0x0000a6f0
    315c:	0000a690 	.word	0x0000a690
    3160:	0000ac80 	.word	0x0000ac80
    3164:	0000a6e0 	.word	0x0000a6e0
    3168:	0000ad08 	.word	0x0000ad08

0000316c <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    316c:	b500      	push	{lr}
    316e:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    3170:	2302      	movs	r3, #2
    3172:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    3174:	2300      	movs	r3, #0
    3176:	9304      	str	r3, [sp, #16]
    3178:	e02c      	b.n	31d4 <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    317a:	4a36      	ldr	r2, [pc, #216]	; (3254 <Clock_Ip_GetPllStatus+0xe8>)
    317c:	9b04      	ldr	r3, [sp, #16]
    317e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    3182:	4935      	ldr	r1, [pc, #212]	; (3258 <Clock_Ip_GetPllStatus+0xec>)
    3184:	4613      	mov	r3, r2
    3186:	00db      	lsls	r3, r3, #3
    3188:	4413      	add	r3, r2
    318a:	440b      	add	r3, r1
    318c:	3301      	adds	r3, #1
    318e:	781b      	ldrb	r3, [r3, #0]
    3190:	461a      	mov	r2, r3
    3192:	4b32      	ldr	r3, [pc, #200]	; (325c <Clock_Ip_GetPllStatus+0xf0>)
    3194:	5c9b      	ldrb	r3, [r3, r2]
    3196:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    3198:	4931      	ldr	r1, [pc, #196]	; (3260 <Clock_Ip_GetPllStatus+0xf4>)
    319a:	9a03      	ldr	r2, [sp, #12]
    319c:	4613      	mov	r3, r2
    319e:	009b      	lsls	r3, r3, #2
    31a0:	4413      	add	r3, r2
    31a2:	009b      	lsls	r3, r3, #2
    31a4:	440b      	add	r3, r1
    31a6:	3308      	adds	r3, #8
    31a8:	681b      	ldr	r3, [r3, #0]
    31aa:	492a      	ldr	r1, [pc, #168]	; (3254 <Clock_Ip_GetPllStatus+0xe8>)
    31ac:	9a04      	ldr	r2, [sp, #16]
    31ae:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    31b2:	4610      	mov	r0, r2
    31b4:	4798      	blx	r3
    31b6:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    31b8:	9b02      	ldr	r3, [sp, #8]
    31ba:	2b01      	cmp	r3, #1
    31bc:	d102      	bne.n	31c4 <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    31be:	2301      	movs	r3, #1
    31c0:	9305      	str	r3, [sp, #20]
            break;
    31c2:	e00d      	b.n	31e0 <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    31c4:	9b02      	ldr	r3, [sp, #8]
    31c6:	2b02      	cmp	r3, #2
    31c8:	d101      	bne.n	31ce <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    31ca:	2300      	movs	r3, #0
    31cc:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    31ce:	9b04      	ldr	r3, [sp, #16]
    31d0:	3301      	adds	r3, #1
    31d2:	9304      	str	r3, [sp, #16]
    31d4:	4b23      	ldr	r3, [pc, #140]	; (3264 <Clock_Ip_GetPllStatus+0xf8>)
    31d6:	789b      	ldrb	r3, [r3, #2]
    31d8:	461a      	mov	r2, r3
    31da:	9b04      	ldr	r3, [sp, #16]
    31dc:	4293      	cmp	r3, r2
    31de:	d3cc      	bcc.n	317a <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    31e0:	9b05      	ldr	r3, [sp, #20]
    31e2:	2b00      	cmp	r3, #0
    31e4:	d130      	bne.n	3248 <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    31e6:	2300      	movs	r3, #0
    31e8:	9304      	str	r3, [sp, #16]
    31ea:	e027      	b.n	323c <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    31ec:	4a1e      	ldr	r2, [pc, #120]	; (3268 <Clock_Ip_GetPllStatus+0xfc>)
    31ee:	9b04      	ldr	r3, [sp, #16]
    31f0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    31f4:	4918      	ldr	r1, [pc, #96]	; (3258 <Clock_Ip_GetPllStatus+0xec>)
    31f6:	4613      	mov	r3, r2
    31f8:	00db      	lsls	r3, r3, #3
    31fa:	4413      	add	r3, r2
    31fc:	440b      	add	r3, r1
    31fe:	3301      	adds	r3, #1
    3200:	781b      	ldrb	r3, [r3, #0]
    3202:	461a      	mov	r2, r3
    3204:	4b19      	ldr	r3, [pc, #100]	; (326c <Clock_Ip_GetPllStatus+0x100>)
    3206:	5c9b      	ldrb	r3, [r3, r2]
    3208:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    320a:	4919      	ldr	r1, [pc, #100]	; (3270 <Clock_Ip_GetPllStatus+0x104>)
    320c:	9a03      	ldr	r2, [sp, #12]
    320e:	4613      	mov	r3, r2
    3210:	005b      	lsls	r3, r3, #1
    3212:	4413      	add	r3, r2
    3214:	009b      	lsls	r3, r3, #2
    3216:	440b      	add	r3, r1
    3218:	3308      	adds	r3, #8
    321a:	681b      	ldr	r3, [r3, #0]
    321c:	4912      	ldr	r1, [pc, #72]	; (3268 <Clock_Ip_GetPllStatus+0xfc>)
    321e:	9a04      	ldr	r2, [sp, #16]
    3220:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    3224:	4610      	mov	r0, r2
    3226:	4798      	blx	r3
    3228:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    322a:	9b01      	ldr	r3, [sp, #4]
    322c:	2b01      	cmp	r3, #1
    322e:	d102      	bne.n	3236 <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    3230:	2301      	movs	r3, #1
    3232:	9305      	str	r3, [sp, #20]
                break;
    3234:	e008      	b.n	3248 <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    3236:	9b04      	ldr	r3, [sp, #16]
    3238:	3301      	adds	r3, #1
    323a:	9304      	str	r3, [sp, #16]
    323c:	4b09      	ldr	r3, [pc, #36]	; (3264 <Clock_Ip_GetPllStatus+0xf8>)
    323e:	78db      	ldrb	r3, [r3, #3]
    3240:	461a      	mov	r2, r3
    3242:	9b04      	ldr	r3, [sp, #16]
    3244:	4293      	cmp	r3, r2
    3246:	d3d1      	bcc.n	31ec <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    3248:	9b05      	ldr	r3, [sp, #20]
}
    324a:	4618      	mov	r0, r3
    324c:	b007      	add	sp, #28
    324e:	f85d fb04 	ldr.w	pc, [sp], #4
    3252:	bf00      	nop
    3254:	0000abf8 	.word	0x0000abf8
    3258:	0000a6f0 	.word	0x0000a6f0
    325c:	0000a6b0 	.word	0x0000a6b0
    3260:	0000ad58 	.word	0x0000ad58
    3264:	1fff8ca8 	.word	0x1fff8ca8
    3268:	0000abfc 	.word	0x0000abfc
    326c:	0000a6a0 	.word	0x0000a6a0
    3270:	0000acb8 	.word	0x0000acb8

00003274 <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    3274:	b500      	push	{lr}
    3276:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    3278:	4b55      	ldr	r3, [pc, #340]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    327a:	681b      	ldr	r3, [r3, #0]
    327c:	2b00      	cmp	r3, #0
    327e:	f000 80a2 	beq.w	33c6 <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    3282:	2300      	movs	r3, #0
    3284:	9301      	str	r3, [sp, #4]
    3286:	e02c      	b.n	32e2 <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    3288:	4b51      	ldr	r3, [pc, #324]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    328a:	681a      	ldr	r2, [r3, #0]
    328c:	9b01      	ldr	r3, [sp, #4]
    328e:	330d      	adds	r3, #13
    3290:	00db      	lsls	r3, r3, #3
    3292:	4413      	add	r3, r2
    3294:	685b      	ldr	r3, [r3, #4]
    3296:	4a4f      	ldr	r2, [pc, #316]	; (33d4 <Clock_Ip_DistributePll+0x160>)
    3298:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    329c:	2b03      	cmp	r3, #3
    329e:	d11d      	bne.n	32dc <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    32a0:	4b4b      	ldr	r3, [pc, #300]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    32a2:	681b      	ldr	r3, [r3, #0]
    32a4:	9a01      	ldr	r2, [sp, #4]
    32a6:	320d      	adds	r2, #13
    32a8:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    32ac:	494a      	ldr	r1, [pc, #296]	; (33d8 <Clock_Ip_DistributePll+0x164>)
    32ae:	4613      	mov	r3, r2
    32b0:	00db      	lsls	r3, r3, #3
    32b2:	4413      	add	r3, r2
    32b4:	440b      	add	r3, r1
    32b6:	3301      	adds	r3, #1
    32b8:	781b      	ldrb	r3, [r3, #0]
    32ba:	461a      	mov	r2, r3
    32bc:	4b47      	ldr	r3, [pc, #284]	; (33dc <Clock_Ip_DistributePll+0x168>)
    32be:	5c9b      	ldrb	r3, [r3, r2]
    32c0:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    32c2:	4a47      	ldr	r2, [pc, #284]	; (33e0 <Clock_Ip_DistributePll+0x16c>)
    32c4:	9b00      	ldr	r3, [sp, #0]
    32c6:	00db      	lsls	r3, r3, #3
    32c8:	4413      	add	r3, r2
    32ca:	685b      	ldr	r3, [r3, #4]
    32cc:	4a40      	ldr	r2, [pc, #256]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    32ce:	6811      	ldr	r1, [r2, #0]
    32d0:	9a01      	ldr	r2, [sp, #4]
    32d2:	320d      	adds	r2, #13
    32d4:	00d2      	lsls	r2, r2, #3
    32d6:	440a      	add	r2, r1
    32d8:	4610      	mov	r0, r2
    32da:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    32dc:	9b01      	ldr	r3, [sp, #4]
    32de:	3301      	adds	r3, #1
    32e0:	9301      	str	r3, [sp, #4]
    32e2:	4b3b      	ldr	r3, [pc, #236]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    32e4:	681b      	ldr	r3, [r3, #0]
    32e6:	7adb      	ldrb	r3, [r3, #11]
    32e8:	461a      	mov	r2, r3
    32ea:	9b01      	ldr	r3, [sp, #4]
    32ec:	4293      	cmp	r3, r2
    32ee:	d3cb      	bcc.n	3288 <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    32f0:	4b3c      	ldr	r3, [pc, #240]	; (33e4 <Clock_Ip_DistributePll+0x170>)
    32f2:	781b      	ldrb	r3, [r3, #0]
    32f4:	2b00      	cmp	r3, #0
    32f6:	d066      	beq.n	33c6 <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    32f8:	2300      	movs	r3, #0
    32fa:	9301      	str	r3, [sp, #4]
    32fc:	e021      	b.n	3342 <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    32fe:	4b34      	ldr	r3, [pc, #208]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    3300:	681a      	ldr	r2, [r3, #0]
    3302:	9b01      	ldr	r3, [sp, #4]
    3304:	334e      	adds	r3, #78	; 0x4e
    3306:	00db      	lsls	r3, r3, #3
    3308:	4413      	add	r3, r2
    330a:	685a      	ldr	r2, [r3, #4]
    330c:	4932      	ldr	r1, [pc, #200]	; (33d8 <Clock_Ip_DistributePll+0x164>)
    330e:	4613      	mov	r3, r2
    3310:	00db      	lsls	r3, r3, #3
    3312:	4413      	add	r3, r2
    3314:	440b      	add	r3, r1
    3316:	3301      	adds	r3, #1
    3318:	781b      	ldrb	r3, [r3, #0]
    331a:	461a      	mov	r2, r3
    331c:	4b32      	ldr	r3, [pc, #200]	; (33e8 <Clock_Ip_DistributePll+0x174>)
    331e:	5c9b      	ldrb	r3, [r3, r2]
    3320:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    3322:	4a32      	ldr	r2, [pc, #200]	; (33ec <Clock_Ip_DistributePll+0x178>)
    3324:	9b00      	ldr	r3, [sp, #0]
    3326:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    332a:	4a29      	ldr	r2, [pc, #164]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    332c:	6811      	ldr	r1, [r2, #0]
    332e:	9a01      	ldr	r2, [sp, #4]
    3330:	324e      	adds	r2, #78	; 0x4e
    3332:	00d2      	lsls	r2, r2, #3
    3334:	440a      	add	r2, r1
    3336:	3204      	adds	r2, #4
    3338:	4610      	mov	r0, r2
    333a:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    333c:	9b01      	ldr	r3, [sp, #4]
    333e:	3301      	adds	r3, #1
    3340:	9301      	str	r3, [sp, #4]
    3342:	4b23      	ldr	r3, [pc, #140]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    3344:	681b      	ldr	r3, [r3, #0]
    3346:	7c1b      	ldrb	r3, [r3, #16]
    3348:	461a      	mov	r2, r3
    334a:	9b01      	ldr	r3, [sp, #4]
    334c:	4293      	cmp	r3, r2
    334e:	d3d6      	bcc.n	32fe <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    3350:	2300      	movs	r3, #0
    3352:	9301      	str	r3, [sp, #4]
    3354:	e02a      	b.n	33ac <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    3356:	4b1e      	ldr	r3, [pc, #120]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    3358:	6819      	ldr	r1, [r3, #0]
    335a:	9a01      	ldr	r2, [sp, #4]
    335c:	4613      	mov	r3, r2
    335e:	009b      	lsls	r3, r3, #2
    3360:	4413      	add	r3, r2
    3362:	009b      	lsls	r3, r3, #2
    3364:	440b      	add	r3, r1
    3366:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    336a:	681a      	ldr	r2, [r3, #0]
    336c:	491a      	ldr	r1, [pc, #104]	; (33d8 <Clock_Ip_DistributePll+0x164>)
    336e:	4613      	mov	r3, r2
    3370:	00db      	lsls	r3, r3, #3
    3372:	4413      	add	r3, r2
    3374:	440b      	add	r3, r1
    3376:	3301      	adds	r3, #1
    3378:	781b      	ldrb	r3, [r3, #0]
    337a:	461a      	mov	r2, r3
    337c:	4b1c      	ldr	r3, [pc, #112]	; (33f0 <Clock_Ip_DistributePll+0x17c>)
    337e:	5c9b      	ldrb	r3, [r3, r2]
    3380:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    3382:	4a1c      	ldr	r2, [pc, #112]	; (33f4 <Clock_Ip_DistributePll+0x180>)
    3384:	9b00      	ldr	r3, [sp, #0]
    3386:	011b      	lsls	r3, r3, #4
    3388:	4413      	add	r3, r2
    338a:	330c      	adds	r3, #12
    338c:	6819      	ldr	r1, [r3, #0]
    338e:	4b10      	ldr	r3, [pc, #64]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    3390:	6818      	ldr	r0, [r3, #0]
    3392:	9a01      	ldr	r2, [sp, #4]
    3394:	4613      	mov	r3, r2
    3396:	009b      	lsls	r3, r3, #2
    3398:	4413      	add	r3, r2
    339a:	009b      	lsls	r3, r3, #2
    339c:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    33a0:	4403      	add	r3, r0
    33a2:	4618      	mov	r0, r3
    33a4:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    33a6:	9b01      	ldr	r3, [sp, #4]
    33a8:	3301      	adds	r3, #1
    33aa:	9301      	str	r3, [sp, #4]
    33ac:	4b08      	ldr	r3, [pc, #32]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    33ae:	681b      	ldr	r3, [r3, #0]
    33b0:	7c9b      	ldrb	r3, [r3, #18]
    33b2:	461a      	mov	r2, r3
    33b4:	9b01      	ldr	r3, [sp, #4]
    33b6:	4293      	cmp	r3, r2
    33b8:	d3cd      	bcc.n	3356 <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    33ba:	4b05      	ldr	r3, [pc, #20]	; (33d0 <Clock_Ip_DistributePll+0x15c>)
    33bc:	681b      	ldr	r3, [r3, #0]
    33be:	2104      	movs	r1, #4
    33c0:	4618      	mov	r0, r3
    33c2:	f7fe ffdd 	bl	2380 <Clock_Ip_Command>
        }
    }
}
    33c6:	bf00      	nop
    33c8:	b003      	add	sp, #12
    33ca:	f85d fb04 	ldr.w	pc, [sp], #4
    33ce:	bf00      	nop
    33d0:	1fff8ca0 	.word	0x1fff8ca0
    33d4:	0000ab3c 	.word	0x0000ab3c
    33d8:	0000a6f0 	.word	0x0000a6f0
    33dc:	0000a6c0 	.word	0x0000a6c0
    33e0:	0000a5f8 	.word	0x0000a5f8
    33e4:	1fff8ca8 	.word	0x1fff8ca8
    33e8:	0000a690 	.word	0x0000a690
    33ec:	0000ac80 	.word	0x0000ac80
    33f0:	0000a6e0 	.word	0x0000a6e0
    33f4:	0000ad08 	.word	0x0000ad08

000033f8 <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    33f8:	b500      	push	{lr}
    33fa:	b085      	sub	sp, #20
    33fc:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    33fe:	490c      	ldr	r1, [pc, #48]	; (3430 <Clock_Ip_DisableClockMonitor+0x38>)
    3400:	9a01      	ldr	r2, [sp, #4]
    3402:	4613      	mov	r3, r2
    3404:	00db      	lsls	r3, r3, #3
    3406:	4413      	add	r3, r2
    3408:	440b      	add	r3, r1
    340a:	3301      	adds	r3, #1
    340c:	781b      	ldrb	r3, [r3, #0]
    340e:	461a      	mov	r2, r3
    3410:	4b08      	ldr	r3, [pc, #32]	; (3434 <Clock_Ip_DisableClockMonitor+0x3c>)
    3412:	5c9b      	ldrb	r3, [r3, r2]
    3414:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    3416:	4a08      	ldr	r2, [pc, #32]	; (3438 <Clock_Ip_DisableClockMonitor+0x40>)
    3418:	9b03      	ldr	r3, [sp, #12]
    341a:	011b      	lsls	r3, r3, #4
    341c:	4413      	add	r3, r2
    341e:	3308      	adds	r3, #8
    3420:	681b      	ldr	r3, [r3, #0]
    3422:	9801      	ldr	r0, [sp, #4]
    3424:	4798      	blx	r3
}
    3426:	bf00      	nop
    3428:	b005      	add	sp, #20
    342a:	f85d fb04 	ldr.w	pc, [sp], #4
    342e:	bf00      	nop
    3430:	0000a6f0 	.word	0x0000a6f0
    3434:	0000a6e0 	.word	0x0000a6e0
    3438:	0000ad08 	.word	0x0000ad08

0000343c <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    343c:	b082      	sub	sp, #8
    343e:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    3440:	4a02      	ldr	r2, [pc, #8]	; (344c <Clock_Ip_InstallNotificationsCallback+0x10>)
    3442:	9b01      	ldr	r3, [sp, #4]
    3444:	6013      	str	r3, [r2, #0]
}
    3446:	bf00      	nop
    3448:	b002      	add	sp, #8
    344a:	4770      	bx	lr
    344c:	1fff8b1c 	.word	0x1fff8b1c

00003450 <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    3450:	b500      	push	{lr}
    3452:	b085      	sub	sp, #20
    3454:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    3456:	490c      	ldr	r1, [pc, #48]	; (3488 <Clock_Ip_DisableModuleClock+0x38>)
    3458:	9a01      	ldr	r2, [sp, #4]
    345a:	4613      	mov	r3, r2
    345c:	00db      	lsls	r3, r3, #3
    345e:	4413      	add	r3, r2
    3460:	440b      	add	r3, r1
    3462:	3301      	adds	r3, #1
    3464:	781b      	ldrb	r3, [r3, #0]
    3466:	461a      	mov	r2, r3
    3468:	4b08      	ldr	r3, [pc, #32]	; (348c <Clock_Ip_DisableModuleClock+0x3c>)
    346a:	5c9b      	ldrb	r3, [r3, r2]
    346c:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    346e:	4a08      	ldr	r2, [pc, #32]	; (3490 <Clock_Ip_DisableModuleClock+0x40>)
    3470:	9b03      	ldr	r3, [sp, #12]
    3472:	00db      	lsls	r3, r3, #3
    3474:	4413      	add	r3, r2
    3476:	685b      	ldr	r3, [r3, #4]
    3478:	2101      	movs	r1, #1
    347a:	9801      	ldr	r0, [sp, #4]
    347c:	4798      	blx	r3
}
    347e:	bf00      	nop
    3480:	b005      	add	sp, #20
    3482:	f85d fb04 	ldr.w	pc, [sp], #4
    3486:	bf00      	nop
    3488:	0000a6f0 	.word	0x0000a6f0
    348c:	0000a690 	.word	0x0000a690
    3490:	0000ac80 	.word	0x0000ac80

00003494 <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    3494:	b500      	push	{lr}
    3496:	b085      	sub	sp, #20
    3498:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    349a:	490c      	ldr	r1, [pc, #48]	; (34cc <Clock_Ip_EnableModuleClock+0x38>)
    349c:	9a01      	ldr	r2, [sp, #4]
    349e:	4613      	mov	r3, r2
    34a0:	00db      	lsls	r3, r3, #3
    34a2:	4413      	add	r3, r2
    34a4:	440b      	add	r3, r1
    34a6:	3301      	adds	r3, #1
    34a8:	781b      	ldrb	r3, [r3, #0]
    34aa:	461a      	mov	r2, r3
    34ac:	4b08      	ldr	r3, [pc, #32]	; (34d0 <Clock_Ip_EnableModuleClock+0x3c>)
    34ae:	5c9b      	ldrb	r3, [r3, r2]
    34b0:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    34b2:	4a08      	ldr	r2, [pc, #32]	; (34d4 <Clock_Ip_EnableModuleClock+0x40>)
    34b4:	9b03      	ldr	r3, [sp, #12]
    34b6:	00db      	lsls	r3, r3, #3
    34b8:	4413      	add	r3, r2
    34ba:	685b      	ldr	r3, [r3, #4]
    34bc:	2100      	movs	r1, #0
    34be:	9801      	ldr	r0, [sp, #4]
    34c0:	4798      	blx	r3
}
    34c2:	bf00      	nop
    34c4:	b005      	add	sp, #20
    34c6:	f85d fb04 	ldr.w	pc, [sp], #4
    34ca:	bf00      	nop
    34cc:	0000a6f0 	.word	0x0000a6f0
    34d0:	0000a690 	.word	0x0000a690
    34d4:	0000ac80 	.word	0x0000ac80

000034d8 <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    34d8:	b500      	push	{lr}
    34da:	b083      	sub	sp, #12
    34dc:	9001      	str	r0, [sp, #4]
    34de:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    34e0:	4b08      	ldr	r3, [pc, #32]	; (3504 <Clock_Ip_PowerModeChangeNotification+0x2c>)
    34e2:	2200      	movs	r2, #0
    34e4:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    34e6:	4b08      	ldr	r3, [pc, #32]	; (3508 <Clock_Ip_PowerModeChangeNotification+0x30>)
    34e8:	681b      	ldr	r3, [r3, #0]
    34ea:	2102      	movs	r1, #2
    34ec:	4618      	mov	r0, r3
    34ee:	f7fe ff47 	bl	2380 <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    34f2:	9900      	ldr	r1, [sp, #0]
    34f4:	9801      	ldr	r0, [sp, #4]
    34f6:	f7fe fe23 	bl	2140 <Clock_Ip_ClockPowerModeChangeNotification>
}
    34fa:	bf00      	nop
    34fc:	b003      	add	sp, #12
    34fe:	f85d fb04 	ldr.w	pc, [sp], #4
    3502:	bf00      	nop
    3504:	1fff8b18 	.word	0x1fff8b18
    3508:	1fff8ca0 	.word	0x1fff8ca0

0000350c <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    350c:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    350e:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    3512:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    3514:	4b06      	ldr	r3, [pc, #24]	; (3530 <Clock_Ip_SetWaitStates+0x24>)
    3516:	785b      	ldrb	r3, [r3, #1]
    3518:	2b00      	cmp	r3, #0
    351a:	d005      	beq.n	3528 <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    351c:	9b01      	ldr	r3, [sp, #4]
    351e:	3b01      	subs	r3, #1
    3520:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    3522:	9b01      	ldr	r3, [sp, #4]
    3524:	2b00      	cmp	r3, #0
    3526:	d1f9      	bne.n	351c <Clock_Ip_SetWaitStates+0x10>
    }
}
    3528:	bf00      	nop
    352a:	b002      	add	sp, #8
    352c:	4770      	bx	lr
    352e:	bf00      	nop
    3530:	1fff8ca8 	.word	0x1fff8ca8

00003534 <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    3534:	b500      	push	{lr}
    3536:	b083      	sub	sp, #12
    3538:	9001      	str	r0, [sp, #4]
    353a:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    353c:	4b04      	ldr	r3, [pc, #16]	; (3550 <Clock_Ip_ReportClockErrors+0x1c>)
    353e:	681b      	ldr	r3, [r3, #0]
    3540:	9900      	ldr	r1, [sp, #0]
    3542:	9801      	ldr	r0, [sp, #4]
    3544:	4798      	blx	r3
}
    3546:	bf00      	nop
    3548:	b003      	add	sp, #12
    354a:	f85d fb04 	ldr.w	pc, [sp], #4
    354e:	bf00      	nop
    3550:	1fff8b1c 	.word	0x1fff8b1c

00003554 <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    3554:	b500      	push	{lr}
    3556:	b085      	sub	sp, #20
    3558:	9003      	str	r0, [sp, #12]
    355a:	9102      	str	r1, [sp, #8]
    355c:	9201      	str	r2, [sp, #4]
    355e:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    3560:	2000      	movs	r0, #0
    3562:	f7fd fc0a 	bl	d7a <OsIf_GetCounter>
    3566:	4602      	mov	r2, r0
    3568:	9b03      	ldr	r3, [sp, #12]
    356a:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    356c:	9b02      	ldr	r3, [sp, #8]
    356e:	2200      	movs	r2, #0
    3570:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    3572:	2100      	movs	r1, #0
    3574:	9800      	ldr	r0, [sp, #0]
    3576:	f7fd fc4c 	bl	e12 <OsIf_MicrosToTicks>
    357a:	4602      	mov	r2, r0
    357c:	9b01      	ldr	r3, [sp, #4]
    357e:	601a      	str	r2, [r3, #0]
}
    3580:	bf00      	nop
    3582:	b005      	add	sp, #20
    3584:	f85d fb04 	ldr.w	pc, [sp], #4

00003588 <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    3588:	b500      	push	{lr}
    358a:	b087      	sub	sp, #28
    358c:	9003      	str	r0, [sp, #12]
    358e:	9102      	str	r1, [sp, #8]
    3590:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    3592:	2300      	movs	r3, #0
    3594:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    3598:	2100      	movs	r1, #0
    359a:	9803      	ldr	r0, [sp, #12]
    359c:	f7fd fc06 	bl	dac <OsIf_GetElapsed>
    35a0:	4602      	mov	r2, r0
    35a2:	9b02      	ldr	r3, [sp, #8]
    35a4:	681b      	ldr	r3, [r3, #0]
    35a6:	441a      	add	r2, r3
    35a8:	9b02      	ldr	r3, [sp, #8]
    35aa:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    35ac:	9b02      	ldr	r3, [sp, #8]
    35ae:	681b      	ldr	r3, [r3, #0]
    35b0:	9a01      	ldr	r2, [sp, #4]
    35b2:	429a      	cmp	r2, r3
    35b4:	d802      	bhi.n	35bc <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    35b6:	2301      	movs	r3, #1
    35b8:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    35bc:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    35c0:	4618      	mov	r0, r3
    35c2:	b007      	add	sp, #28
    35c4:	f85d fb04 	ldr.w	pc, [sp], #4

000035c8 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    35c8:	b082      	sub	sp, #8
    35ca:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    35cc:	9b01      	ldr	r3, [sp, #4]
    35ce:	681a      	ldr	r2, [r3, #0]
    35d0:	4907      	ldr	r1, [pc, #28]	; (35f0 <Power_Ip_RCM_ResetInit+0x28>)
    35d2:	f641 7307 	movw	r3, #7943	; 0x1f07
    35d6:	4013      	ands	r3, r2
    35d8:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    35da:	9b01      	ldr	r3, [sp, #4]
    35dc:	685a      	ldr	r2, [r3, #4]
    35de:	4904      	ldr	r1, [pc, #16]	; (35f0 <Power_Ip_RCM_ResetInit+0x28>)
    35e0:	f642 73ff 	movw	r3, #12287	; 0x2fff
    35e4:	4013      	ands	r3, r2
    35e6:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    35e8:	bf00      	nop
    35ea:	b002      	add	sp, #8
    35ec:	4770      	bx	lr
    35ee:	bf00      	nop
    35f0:	4007f000 	.word	0x4007f000

000035f4 <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    35f4:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    35f6:	230c      	movs	r3, #12
    35f8:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    35fa:	2300      	movs	r3, #0
    35fc:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    35fe:	2300      	movs	r3, #0
    3600:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    3602:	2300      	movs	r3, #0
    3604:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    3606:	4b25      	ldr	r3, [pc, #148]	; (369c <Power_Ip_RCM_GetResetReason+0xa8>)
    3608:	699a      	ldr	r2, [r3, #24]
    360a:	f642 73ee 	movw	r3, #12270	; 0x2fee
    360e:	4013      	ands	r3, r2
    3610:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    3612:	9b03      	ldr	r3, [sp, #12]
    3614:	2b00      	cmp	r3, #0
    3616:	d008      	beq.n	362a <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    3618:	4920      	ldr	r1, [pc, #128]	; (369c <Power_Ip_RCM_GetResetReason+0xa8>)
    361a:	9a03      	ldr	r2, [sp, #12]
    361c:	f642 73ee 	movw	r3, #12270	; 0x2fee
    3620:	4013      	ands	r3, r2
    3622:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    3624:	4a1e      	ldr	r2, [pc, #120]	; (36a0 <Power_Ip_RCM_GetResetReason+0xac>)
    3626:	9b03      	ldr	r3, [sp, #12]
    3628:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    362a:	4b1d      	ldr	r3, [pc, #116]	; (36a0 <Power_Ip_RCM_GetResetReason+0xac>)
    362c:	681b      	ldr	r3, [r3, #0]
    362e:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    3630:	9a02      	ldr	r2, [sp, #8]
    3632:	f642 73ee 	movw	r3, #12270	; 0x2fee
    3636:	4013      	ands	r3, r2
    3638:	2b82      	cmp	r3, #130	; 0x82
    363a:	d102      	bne.n	3642 <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    363c:	2305      	movs	r3, #5
    363e:	9307      	str	r3, [sp, #28]
    3640:	e027      	b.n	3692 <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    3642:	2300      	movs	r3, #0
    3644:	9306      	str	r3, [sp, #24]
    3646:	e021      	b.n	368c <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    3648:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    364c:	9b06      	ldr	r3, [sp, #24]
    364e:	fa22 f303 	lsr.w	r3, r2, r3
    3652:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    3654:	9a01      	ldr	r2, [sp, #4]
    3656:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    365a:	4013      	ands	r3, r2
    365c:	2b00      	cmp	r3, #0
    365e:	d012      	beq.n	3686 <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    3660:	9a01      	ldr	r2, [sp, #4]
    3662:	9b02      	ldr	r3, [sp, #8]
    3664:	4013      	ands	r3, r2
    3666:	2b00      	cmp	r3, #0
    3668:	d00a      	beq.n	3680 <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    366a:	9b05      	ldr	r3, [sp, #20]
    366c:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    366e:	9b04      	ldr	r3, [sp, #16]
    3670:	3301      	adds	r3, #1
    3672:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    3674:	9b04      	ldr	r3, [sp, #16]
    3676:	2b01      	cmp	r3, #1
    3678:	d902      	bls.n	3680 <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    367a:	230d      	movs	r3, #13
    367c:	9307      	str	r3, [sp, #28]
                        break;
    367e:	e008      	b.n	3692 <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    3680:	9b05      	ldr	r3, [sp, #20]
    3682:	3301      	adds	r3, #1
    3684:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    3686:	9b06      	ldr	r3, [sp, #24]
    3688:	3301      	adds	r3, #1
    368a:	9306      	str	r3, [sp, #24]
    368c:	9b06      	ldr	r3, [sp, #24]
    368e:	2b1f      	cmp	r3, #31
    3690:	d9da      	bls.n	3648 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    3692:	9b07      	ldr	r3, [sp, #28]
}
    3694:	4618      	mov	r0, r3
    3696:	b008      	add	sp, #32
    3698:	4770      	bx	lr
    369a:	bf00      	nop
    369c:	4007f000 	.word	0x4007f000
    36a0:	1fff8d04 	.word	0x1fff8d04

000036a4 <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    36a4:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    36a6:	4b0c      	ldr	r3, [pc, #48]	; (36d8 <Power_Ip_RCM_GetResetRawValue+0x34>)
    36a8:	699a      	ldr	r2, [r3, #24]
    36aa:	f642 73ee 	movw	r3, #12270	; 0x2fee
    36ae:	4013      	ands	r3, r2
    36b0:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    36b2:	9b01      	ldr	r3, [sp, #4]
    36b4:	2b00      	cmp	r3, #0
    36b6:	d008      	beq.n	36ca <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    36b8:	4907      	ldr	r1, [pc, #28]	; (36d8 <Power_Ip_RCM_GetResetRawValue+0x34>)
    36ba:	9a01      	ldr	r2, [sp, #4]
    36bc:	f642 73ee 	movw	r3, #12270	; 0x2fee
    36c0:	4013      	ands	r3, r2
    36c2:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    36c4:	4a05      	ldr	r2, [pc, #20]	; (36dc <Power_Ip_RCM_GetResetRawValue+0x38>)
    36c6:	9b01      	ldr	r3, [sp, #4]
    36c8:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    36ca:	4b04      	ldr	r3, [pc, #16]	; (36dc <Power_Ip_RCM_GetResetRawValue+0x38>)
    36cc:	681b      	ldr	r3, [r3, #0]
    36ce:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    36d0:	9b00      	ldr	r3, [sp, #0]
}
    36d2:	4618      	mov	r0, r3
    36d4:	b002      	add	sp, #8
    36d6:	4770      	bx	lr
    36d8:	4007f000 	.word	0x4007f000
    36dc:	1fff8d04 	.word	0x1fff8d04

000036e0 <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    36e0:	b500      	push	{lr}
    36e2:	b085      	sub	sp, #20
    36e4:	9001      	str	r0, [sp, #4]

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    36e6:	4a20      	ldr	r2, [pc, #128]	; (3768 <Mcu_Init+0x88>)
    36e8:	9b01      	ldr	r3, [sp, #4]
    36ea:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    36ec:	2300      	movs	r3, #0
    36ee:	9303      	str	r3, [sp, #12]
    36f0:	e010      	b.n	3714 <Mcu_Init+0x34>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    36f2:	4b1d      	ldr	r3, [pc, #116]	; (3768 <Mcu_Init+0x88>)
    36f4:	681b      	ldr	r3, [r3, #0]
    36f6:	6919      	ldr	r1, [r3, #16]
    36f8:	9a03      	ldr	r2, [sp, #12]
    36fa:	4613      	mov	r3, r2
    36fc:	005b      	lsls	r3, r3, #1
    36fe:	4413      	add	r3, r2
    3700:	009b      	lsls	r3, r3, #2
    3702:	440b      	add	r3, r1
    3704:	681b      	ldr	r3, [r3, #0]
    3706:	9a03      	ldr	r2, [sp, #12]
    3708:	b2d1      	uxtb	r1, r2
    370a:	4a18      	ldr	r2, [pc, #96]	; (376c <Mcu_Init+0x8c>)
    370c:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    370e:	9b03      	ldr	r3, [sp, #12]
    3710:	3301      	adds	r3, #1
    3712:	9303      	str	r3, [sp, #12]
    3714:	4b14      	ldr	r3, [pc, #80]	; (3768 <Mcu_Init+0x88>)
    3716:	681b      	ldr	r3, [r3, #0]
    3718:	689b      	ldr	r3, [r3, #8]
    371a:	9a03      	ldr	r2, [sp, #12]
    371c:	429a      	cmp	r2, r3
    371e:	d3e8      	bcc.n	36f2 <Mcu_Init+0x12>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    3720:	2300      	movs	r3, #0
    3722:	9303      	str	r3, [sp, #12]
    3724:	e010      	b.n	3748 <Mcu_Init+0x68>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    3726:	4b10      	ldr	r3, [pc, #64]	; (3768 <Mcu_Init+0x88>)
    3728:	681b      	ldr	r3, [r3, #0]
    372a:	6959      	ldr	r1, [r3, #20]
    372c:	9a03      	ldr	r2, [sp, #12]
    372e:	4613      	mov	r3, r2
    3730:	01db      	lsls	r3, r3, #7
    3732:	1a9b      	subs	r3, r3, r2
    3734:	00db      	lsls	r3, r3, #3
    3736:	440b      	add	r3, r1
    3738:	681b      	ldr	r3, [r3, #0]
    373a:	9a03      	ldr	r2, [sp, #12]
    373c:	b2d1      	uxtb	r1, r2
    373e:	4a0c      	ldr	r2, [pc, #48]	; (3770 <Mcu_Init+0x90>)
    3740:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    3742:	9b03      	ldr	r3, [sp, #12]
    3744:	3301      	adds	r3, #1
    3746:	9303      	str	r3, [sp, #12]
    3748:	4b07      	ldr	r3, [pc, #28]	; (3768 <Mcu_Init+0x88>)
    374a:	681b      	ldr	r3, [r3, #0]
    374c:	68db      	ldr	r3, [r3, #12]
    374e:	9a03      	ldr	r2, [sp, #12]
    3750:	429a      	cmp	r2, r3
    3752:	d3e8      	bcc.n	3726 <Mcu_Init+0x46>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    3754:	4b04      	ldr	r3, [pc, #16]	; (3768 <Mcu_Init+0x88>)
    3756:	681b      	ldr	r3, [r3, #0]
    3758:	699b      	ldr	r3, [r3, #24]
    375a:	4618      	mov	r0, r3
    375c:	f000 fea6 	bl	44ac <Mcu_Ipw_Init>
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    3760:	bf00      	nop
    3762:	b005      	add	sp, #20
    3764:	f85d fb04 	ldr.w	pc, [sp], #4
    3768:	1fff8d10 	.word	0x1fff8d10
    376c:	1fff8d0c 	.word	0x1fff8d0c
    3770:	1fff8d08 	.word	0x1fff8d08

00003774 <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    3774:	b084      	sub	sp, #16
    3776:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    3778:	2301      	movs	r3, #1
    377a:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    377e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    3782:	4618      	mov	r0, r3
    3784:	b004      	add	sp, #16
    3786:	4770      	bx	lr

00003788 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    3788:	b500      	push	{lr}
    378a:	b085      	sub	sp, #20
    378c:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    378e:	4a0e      	ldr	r2, [pc, #56]	; (37c8 <Mcu_InitClock+0x40>)
    3790:	9b01      	ldr	r3, [sp, #4]
    3792:	4413      	add	r3, r2
    3794:	781b      	ldrb	r3, [r3, #0]
    3796:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    379a:	4b0c      	ldr	r3, [pc, #48]	; (37cc <Mcu_InitClock+0x44>)
    379c:	681b      	ldr	r3, [r3, #0]
    379e:	6959      	ldr	r1, [r3, #20]
    37a0:	f89d 200f 	ldrb.w	r2, [sp, #15]
    37a4:	4613      	mov	r3, r2
    37a6:	01db      	lsls	r3, r3, #7
    37a8:	1a9b      	subs	r3, r3, r2
    37aa:	00db      	lsls	r3, r3, #3
    37ac:	440b      	add	r3, r1
    37ae:	4618      	mov	r0, r3
    37b0:	f000 fe86 	bl	44c0 <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    37b4:	2300      	movs	r3, #0
    37b6:	f88d 300e 	strb.w	r3, [sp, #14]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    37ba:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    37be:	4618      	mov	r0, r3
    37c0:	b005      	add	sp, #20
    37c2:	f85d fb04 	ldr.w	pc, [sp], #4
    37c6:	bf00      	nop
    37c8:	1fff8d08 	.word	0x1fff8d08
    37cc:	1fff8d10 	.word	0x1fff8d10

000037d0 <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    37d0:	b500      	push	{lr}
    37d2:	b085      	sub	sp, #20
    37d4:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    37d6:	4a0d      	ldr	r2, [pc, #52]	; (380c <Mcu_SetMode+0x3c>)
    37d8:	9b01      	ldr	r3, [sp, #4]
    37da:	4413      	add	r3, r2
    37dc:	781b      	ldrb	r3, [r3, #0]
    37de:	f88d 300f 	strb.w	r3, [sp, #15]
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    37e2:	f006 fcbd 	bl	a160 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    37e6:	4b0a      	ldr	r3, [pc, #40]	; (3810 <Mcu_SetMode+0x40>)
    37e8:	681b      	ldr	r3, [r3, #0]
    37ea:	6919      	ldr	r1, [r3, #16]
    37ec:	f89d 200f 	ldrb.w	r2, [sp, #15]
    37f0:	4613      	mov	r3, r2
    37f2:	005b      	lsls	r3, r3, #1
    37f4:	4413      	add	r3, r2
    37f6:	009b      	lsls	r3, r3, #2
    37f8:	440b      	add	r3, r1
    37fa:	4618      	mov	r0, r3
    37fc:	f000 fe6a 	bl	44d4 <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    3800:	f006 fcda 	bl	a1b8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    3804:	bf00      	nop
    3806:	b005      	add	sp, #20
    3808:	f85d fb04 	ldr.w	pc, [sp], #4
    380c:	1fff8d0c 	.word	0x1fff8d0c
    3810:	1fff8d10 	.word	0x1fff8d10

00003814 <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    3814:	b082      	sub	sp, #8
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    3816:	2302      	movs	r3, #2
    3818:	9301      	str	r3, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    381a:	9b01      	ldr	r3, [sp, #4]
}
    381c:	4618      	mov	r0, r3
    381e:	b002      	add	sp, #8
    3820:	4770      	bx	lr

00003822 <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    3822:	b500      	push	{lr}
    3824:	b083      	sub	sp, #12
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    3826:	f000 fe5f 	bl	44e8 <Mcu_Ipw_GetResetReason>
    382a:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    382c:	9b01      	ldr	r3, [sp, #4]
}
    382e:	4618      	mov	r0, r3
    3830:	b003      	add	sp, #12
    3832:	f85d fb04 	ldr.w	pc, [sp], #4

00003836 <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    3836:	b500      	push	{lr}
    3838:	b083      	sub	sp, #12

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    383a:	f000 fe5b 	bl	44f4 <Mcu_Ipw_GetResetRawValue>
    383e:	9001      	str	r0, [sp, #4]
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    3840:	9b01      	ldr	r3, [sp, #4]
}
    3842:	4618      	mov	r0, r3
    3844:	b003      	add	sp, #12
    3846:	f85d fb04 	ldr.w	pc, [sp], #4

0000384a <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    384a:	b500      	push	{lr}
    384c:	b083      	sub	sp, #12
    384e:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    3850:	9801      	ldr	r0, [sp, #4]
    3852:	f000 fe55 	bl	4500 <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    3856:	bf00      	nop
    3858:	b003      	add	sp, #12
    385a:	f85d fb04 	ldr.w	pc, [sp], #4

0000385e <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    385e:	b082      	sub	sp, #8
    3860:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    3862:	4b03      	ldr	r3, [pc, #12]	; (3870 <Mcu_ClkSrcFailureNotification+0x12>)
    3864:	681b      	ldr	r3, [r3, #0]
    3866:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    3868:	bf00      	nop
    386a:	b002      	add	sp, #8
    386c:	4770      	bx	lr
    386e:	bf00      	nop
    3870:	1fff8d10 	.word	0x1fff8d10

00003874 <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    3874:	b082      	sub	sp, #8
    3876:	9001      	str	r0, [sp, #4]
    3878:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    387a:	bf00      	nop
    387c:	b002      	add	sp, #8
    387e:	4770      	bx	lr

00003880 <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    3880:	b082      	sub	sp, #8
    3882:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3884:	bf00      	nop
    3886:	b002      	add	sp, #8
    3888:	4770      	bx	lr

0000388a <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    388a:	b082      	sub	sp, #8
    388c:	9001      	str	r0, [sp, #4]
    388e:	460b      	mov	r3, r1
    3890:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    3894:	bf00      	nop
    3896:	b002      	add	sp, #8
    3898:	4770      	bx	lr

0000389a <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    389a:	b500      	push	{lr}
    389c:	b083      	sub	sp, #12
    389e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    38a0:	9b01      	ldr	r3, [sp, #4]
    38a2:	2b00      	cmp	r3, #0
    38a4:	d002      	beq.n	38ac <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    38a6:	9801      	ldr	r0, [sp, #4]
    38a8:	f000 f8e7 	bl	3a7a <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    38ac:	bf00      	nop
    38ae:	b003      	add	sp, #12
    38b0:	f85d fb04 	ldr.w	pc, [sp], #4

000038b4 <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    38b4:	b500      	push	{lr}
    38b6:	b085      	sub	sp, #20
    38b8:	9001      	str	r0, [sp, #4]
    38ba:	460b      	mov	r3, r1
    38bc:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    38c0:	9b01      	ldr	r3, [sp, #4]
    38c2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    38c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    38c8:	2b00      	cmp	r3, #0
    38ca:	d003      	beq.n	38d4 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    38cc:	2300      	movs	r3, #0
    38ce:	f8ad 300c 	strh.w	r3, [sp, #12]
    38d2:	e002      	b.n	38da <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    38d4:	2301      	movs	r3, #1
    38d6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    38da:	ab02      	add	r3, sp, #8
    38dc:	4618      	mov	r0, r3
    38de:	f7ff ffdc 	bl	389a <Clock_Ip_ClockSetSimLPO1KEnable>
}
    38e2:	bf00      	nop
    38e4:	b005      	add	sp, #20
    38e6:	f85d fb04 	ldr.w	pc, [sp], #4

000038ea <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    38ea:	b500      	push	{lr}
    38ec:	b083      	sub	sp, #12
    38ee:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    38f0:	9b01      	ldr	r3, [sp, #4]
    38f2:	2b00      	cmp	r3, #0
    38f4:	d002      	beq.n	38fc <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    38f6:	9801      	ldr	r0, [sp, #4]
    38f8:	f000 f8d6 	bl	3aa8 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    38fc:	bf00      	nop
    38fe:	b003      	add	sp, #12
    3900:	f85d fb04 	ldr.w	pc, [sp], #4

00003904 <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3904:	b500      	push	{lr}
    3906:	b085      	sub	sp, #20
    3908:	9001      	str	r0, [sp, #4]
    390a:	460b      	mov	r3, r1
    390c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3910:	9b01      	ldr	r3, [sp, #4]
    3912:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3914:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3918:	2b00      	cmp	r3, #0
    391a:	d003      	beq.n	3924 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    391c:	2300      	movs	r3, #0
    391e:	f8ad 300c 	strh.w	r3, [sp, #12]
    3922:	e002      	b.n	392a <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3924:	2301      	movs	r3, #1
    3926:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    392a:	ab02      	add	r3, sp, #8
    392c:	4618      	mov	r0, r3
    392e:	f7ff ffdc 	bl	38ea <Clock_Ip_ClockSetSimLPO32KEnable>
}
    3932:	bf00      	nop
    3934:	b005      	add	sp, #20
    3936:	f85d fb04 	ldr.w	pc, [sp], #4

0000393a <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    393a:	b500      	push	{lr}
    393c:	b083      	sub	sp, #12
    393e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3940:	9b01      	ldr	r3, [sp, #4]
    3942:	2b00      	cmp	r3, #0
    3944:	d002      	beq.n	394c <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    3946:	9801      	ldr	r0, [sp, #4]
    3948:	f000 f8c6 	bl	3ad8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    394c:	bf00      	nop
    394e:	b003      	add	sp, #12
    3950:	f85d fb04 	ldr.w	pc, [sp], #4

00003954 <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3954:	b500      	push	{lr}
    3956:	b085      	sub	sp, #20
    3958:	9001      	str	r0, [sp, #4]
    395a:	460b      	mov	r3, r1
    395c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3960:	9b01      	ldr	r3, [sp, #4]
    3962:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3964:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3968:	2b00      	cmp	r3, #0
    396a:	d003      	beq.n	3974 <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    396c:	2300      	movs	r3, #0
    396e:	f8ad 300c 	strh.w	r3, [sp, #12]
    3972:	e002      	b.n	397a <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3974:	2301      	movs	r3, #1
    3976:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    397a:	ab02      	add	r3, sp, #8
    397c:	4618      	mov	r0, r3
    397e:	f7ff ffdc 	bl	393a <Clock_Ip_ClockSetSimClkoutEnable>
}
    3982:	bf00      	nop
    3984:	b005      	add	sp, #20
    3986:	f85d fb04 	ldr.w	pc, [sp], #4

0000398a <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    398a:	b500      	push	{lr}
    398c:	b083      	sub	sp, #12
    398e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3990:	9b01      	ldr	r3, [sp, #4]
    3992:	2b00      	cmp	r3, #0
    3994:	d002      	beq.n	399c <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    3996:	9801      	ldr	r0, [sp, #4]
    3998:	f000 f8b6 	bl	3b08 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    399c:	bf00      	nop
    399e:	b003      	add	sp, #12
    39a0:	f85d fb04 	ldr.w	pc, [sp], #4

000039a4 <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    39a4:	b500      	push	{lr}
    39a6:	b085      	sub	sp, #20
    39a8:	9001      	str	r0, [sp, #4]
    39aa:	460b      	mov	r3, r1
    39ac:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    39b0:	9b01      	ldr	r3, [sp, #4]
    39b2:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    39b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    39b8:	2b00      	cmp	r3, #0
    39ba:	d003      	beq.n	39c4 <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    39bc:	2300      	movs	r3, #0
    39be:	f8ad 300c 	strh.w	r3, [sp, #12]
    39c2:	e002      	b.n	39ca <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    39c4:	2301      	movs	r3, #1
    39c6:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    39ca:	ab02      	add	r3, sp, #8
    39cc:	4618      	mov	r0, r3
    39ce:	f7ff ffdc 	bl	398a <Clock_Ip_ClockSetPccCgcEnable>
}
    39d2:	bf00      	nop
    39d4:	b005      	add	sp, #20
    39d6:	f85d fb04 	ldr.w	pc, [sp], #4

000039da <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    39da:	b500      	push	{lr}
    39dc:	b083      	sub	sp, #12
    39de:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    39e0:	9b01      	ldr	r3, [sp, #4]
    39e2:	2b00      	cmp	r3, #0
    39e4:	d002      	beq.n	39ec <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    39e6:	9801      	ldr	r0, [sp, #4]
    39e8:	f000 f8bc 	bl	3b64 <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    39ec:	bf00      	nop
    39ee:	b003      	add	sp, #12
    39f0:	f85d fb04 	ldr.w	pc, [sp], #4

000039f4 <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    39f4:	b500      	push	{lr}
    39f6:	b085      	sub	sp, #20
    39f8:	9001      	str	r0, [sp, #4]
    39fa:	460b      	mov	r3, r1
    39fc:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3a00:	9b01      	ldr	r3, [sp, #4]
    3a02:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3a04:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3a08:	2b00      	cmp	r3, #0
    3a0a:	d003      	beq.n	3a14 <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    3a0c:	2300      	movs	r3, #0
    3a0e:	f8ad 300c 	strh.w	r3, [sp, #12]
    3a12:	e002      	b.n	3a1a <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3a14:	2301      	movs	r3, #1
    3a16:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    3a1a:	ab02      	add	r3, sp, #8
    3a1c:	4618      	mov	r0, r3
    3a1e:	f7ff ffdc 	bl	39da <Clock_Ip_ClockSetSimGate>
}
    3a22:	bf00      	nop
    3a24:	b005      	add	sp, #20
    3a26:	f85d fb04 	ldr.w	pc, [sp], #4

00003a2a <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    3a2a:	b500      	push	{lr}
    3a2c:	b083      	sub	sp, #12
    3a2e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3a30:	9b01      	ldr	r3, [sp, #4]
    3a32:	2b00      	cmp	r3, #0
    3a34:	d002      	beq.n	3a3c <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    3a36:	9801      	ldr	r0, [sp, #4]
    3a38:	f000 f8c0 	bl	3bbc <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3a3c:	bf00      	nop
    3a3e:	b003      	add	sp, #12
    3a40:	f85d fb04 	ldr.w	pc, [sp], #4

00003a44 <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3a44:	b500      	push	{lr}
    3a46:	b085      	sub	sp, #20
    3a48:	9001      	str	r0, [sp, #4]
    3a4a:	460b      	mov	r3, r1
    3a4c:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    3a50:	9b01      	ldr	r3, [sp, #4]
    3a52:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3a54:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3a58:	2b00      	cmp	r3, #0
    3a5a:	d003      	beq.n	3a64 <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    3a5c:	2300      	movs	r3, #0
    3a5e:	f8ad 300c 	strh.w	r3, [sp, #12]
    3a62:	e002      	b.n	3a6a <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3a64:	2301      	movs	r3, #1
    3a66:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    3a6a:	ab02      	add	r3, sp, #8
    3a6c:	4618      	mov	r0, r3
    3a6e:	f7ff ffdc 	bl	3a2a <Clock_Ip_ClockSetSimTraceEnable>
}
    3a72:	bf00      	nop
    3a74:	b005      	add	sp, #20
    3a76:	f85d fb04 	ldr.w	pc, [sp], #4

00003a7a <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3a7a:	b084      	sub	sp, #16
    3a7c:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    3a7e:	4b09      	ldr	r3, [pc, #36]	; (3aa4 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    3a80:	691b      	ldr	r3, [r3, #16]
    3a82:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    3a84:	9b03      	ldr	r3, [sp, #12]
    3a86:	f023 0301 	bic.w	r3, r3, #1
    3a8a:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3a8c:	9b01      	ldr	r3, [sp, #4]
    3a8e:	889b      	ldrh	r3, [r3, #4]
    3a90:	461a      	mov	r2, r3
    3a92:	9b03      	ldr	r3, [sp, #12]
    3a94:	4313      	orrs	r3, r2
    3a96:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    3a98:	4a02      	ldr	r2, [pc, #8]	; (3aa4 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    3a9a:	9b03      	ldr	r3, [sp, #12]
    3a9c:	6113      	str	r3, [r2, #16]
}
    3a9e:	bf00      	nop
    3aa0:	b004      	add	sp, #16
    3aa2:	4770      	bx	lr
    3aa4:	40048000 	.word	0x40048000

00003aa8 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3aa8:	b084      	sub	sp, #16
    3aaa:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    3aac:	4b09      	ldr	r3, [pc, #36]	; (3ad4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    3aae:	691b      	ldr	r3, [r3, #16]
    3ab0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    3ab2:	9b03      	ldr	r3, [sp, #12]
    3ab4:	f023 0302 	bic.w	r3, r3, #2
    3ab8:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    3aba:	9b01      	ldr	r3, [sp, #4]
    3abc:	889b      	ldrh	r3, [r3, #4]
    3abe:	005b      	lsls	r3, r3, #1
    3ac0:	9a03      	ldr	r2, [sp, #12]
    3ac2:	4313      	orrs	r3, r2
    3ac4:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    3ac6:	4a03      	ldr	r2, [pc, #12]	; (3ad4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    3ac8:	9b03      	ldr	r3, [sp, #12]
    3aca:	6113      	str	r3, [r2, #16]
}
    3acc:	bf00      	nop
    3ace:	b004      	add	sp, #16
    3ad0:	4770      	bx	lr
    3ad2:	bf00      	nop
    3ad4:	40048000 	.word	0x40048000

00003ad8 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3ad8:	b084      	sub	sp, #16
    3ada:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    3adc:	4b09      	ldr	r3, [pc, #36]	; (3b04 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    3ade:	685b      	ldr	r3, [r3, #4]
    3ae0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    3ae2:	9b03      	ldr	r3, [sp, #12]
    3ae4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    3ae8:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    3aea:	9b01      	ldr	r3, [sp, #4]
    3aec:	889b      	ldrh	r3, [r3, #4]
    3aee:	02db      	lsls	r3, r3, #11
    3af0:	9a03      	ldr	r2, [sp, #12]
    3af2:	4313      	orrs	r3, r2
    3af4:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    3af6:	4a03      	ldr	r2, [pc, #12]	; (3b04 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    3af8:	9b03      	ldr	r3, [sp, #12]
    3afa:	6053      	str	r3, [r2, #4]
}
    3afc:	bf00      	nop
    3afe:	b004      	add	sp, #16
    3b00:	4770      	bx	lr
    3b02:	bf00      	nop
    3b04:	40048000 	.word	0x40048000

00003b08 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3b08:	b084      	sub	sp, #16
    3b0a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    3b0c:	4913      	ldr	r1, [pc, #76]	; (3b5c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3b0e:	9b01      	ldr	r3, [sp, #4]
    3b10:	681a      	ldr	r2, [r3, #0]
    3b12:	4813      	ldr	r0, [pc, #76]	; (3b60 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3b14:	4613      	mov	r3, r2
    3b16:	00db      	lsls	r3, r3, #3
    3b18:	4413      	add	r3, r2
    3b1a:	4403      	add	r3, r0
    3b1c:	3306      	adds	r3, #6
    3b1e:	781b      	ldrb	r3, [r3, #0]
    3b20:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    3b24:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    3b26:	9b03      	ldr	r3, [sp, #12]
    3b28:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    3b2c:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    3b2e:	9b01      	ldr	r3, [sp, #4]
    3b30:	889b      	ldrh	r3, [r3, #4]
    3b32:	079b      	lsls	r3, r3, #30
    3b34:	9a03      	ldr	r2, [sp, #12]
    3b36:	4313      	orrs	r3, r2
    3b38:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    3b3a:	4908      	ldr	r1, [pc, #32]	; (3b5c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3b3c:	9b01      	ldr	r3, [sp, #4]
    3b3e:	681a      	ldr	r2, [r3, #0]
    3b40:	4807      	ldr	r0, [pc, #28]	; (3b60 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3b42:	4613      	mov	r3, r2
    3b44:	00db      	lsls	r3, r3, #3
    3b46:	4413      	add	r3, r2
    3b48:	4403      	add	r3, r0
    3b4a:	3306      	adds	r3, #6
    3b4c:	781b      	ldrb	r3, [r3, #0]
    3b4e:	461a      	mov	r2, r3
    3b50:	9b03      	ldr	r3, [sp, #12]
    3b52:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    3b56:	bf00      	nop
    3b58:	b004      	add	sp, #16
    3b5a:	4770      	bx	lr
    3b5c:	40065000 	.word	0x40065000
    3b60:	0000a6f0 	.word	0x0000a6f0

00003b64 <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3b64:	b086      	sub	sp, #24
    3b66:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    3b68:	9b01      	ldr	r3, [sp, #4]
    3b6a:	889b      	ldrh	r3, [r3, #4]
    3b6c:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    3b6e:	9b01      	ldr	r3, [sp, #4]
    3b70:	681a      	ldr	r2, [r3, #0]
    3b72:	4910      	ldr	r1, [pc, #64]	; (3bb4 <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    3b74:	4613      	mov	r3, r2
    3b76:	00db      	lsls	r3, r3, #3
    3b78:	4413      	add	r3, r2
    3b7a:	440b      	add	r3, r1
    3b7c:	3306      	adds	r3, #6
    3b7e:	781b      	ldrb	r3, [r3, #0]
    3b80:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    3b82:	4b0d      	ldr	r3, [pc, #52]	; (3bb8 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3b84:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3b86:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    3b88:	2201      	movs	r2, #1
    3b8a:	9b04      	ldr	r3, [sp, #16]
    3b8c:	fa02 f303 	lsl.w	r3, r2, r3
    3b90:	43db      	mvns	r3, r3
    3b92:	9a03      	ldr	r2, [sp, #12]
    3b94:	4013      	ands	r3, r2
    3b96:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    3b98:	9a05      	ldr	r2, [sp, #20]
    3b9a:	9b04      	ldr	r3, [sp, #16]
    3b9c:	fa02 f303 	lsl.w	r3, r2, r3
    3ba0:	9a03      	ldr	r2, [sp, #12]
    3ba2:	4313      	orrs	r3, r2
    3ba4:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    3ba6:	4a04      	ldr	r2, [pc, #16]	; (3bb8 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3ba8:	9b03      	ldr	r3, [sp, #12]
    3baa:	6413      	str	r3, [r2, #64]	; 0x40
}
    3bac:	bf00      	nop
    3bae:	b006      	add	sp, #24
    3bb0:	4770      	bx	lr
    3bb2:	bf00      	nop
    3bb4:	0000a6f0 	.word	0x0000a6f0
    3bb8:	40048000 	.word	0x40048000

00003bbc <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3bbc:	b084      	sub	sp, #16
    3bbe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    3bc0:	4b0a      	ldr	r3, [pc, #40]	; (3bec <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    3bc2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3bc4:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    3bc6:	9b01      	ldr	r3, [sp, #4]
    3bc8:	889b      	ldrh	r3, [r3, #4]
    3bca:	2b01      	cmp	r3, #1
    3bcc:	d104      	bne.n	3bd8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    3bce:	9b03      	ldr	r3, [sp, #12]
    3bd0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    3bd4:	9303      	str	r3, [sp, #12]
    3bd6:	e003      	b.n	3be0 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    3bd8:	9b03      	ldr	r3, [sp, #12]
    3bda:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    3bde:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    3be0:	4a02      	ldr	r2, [pc, #8]	; (3bec <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    3be2:	9b03      	ldr	r3, [sp, #12]
    3be4:	6693      	str	r3, [r2, #104]	; 0x68
}
    3be6:	bf00      	nop
    3be8:	b004      	add	sp, #16
    3bea:	4770      	bx	lr
    3bec:	40048000 	.word	0x40048000

00003bf0 <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    3bf0:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    3bf2:	2300      	movs	r3, #0
    3bf4:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    3bf6:	4b07      	ldr	r3, [pc, #28]	; (3c14 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    3bf8:	681b      	ldr	r3, [r3, #0]
    3bfa:	685b      	ldr	r3, [r3, #4]
    3bfc:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    3bfe:	9b01      	ldr	r3, [sp, #4]
    3c00:	f023 0302 	bic.w	r3, r3, #2
    3c04:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    3c06:	4b03      	ldr	r3, [pc, #12]	; (3c14 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    3c08:	681b      	ldr	r3, [r3, #0]
    3c0a:	9a01      	ldr	r2, [sp, #4]
    3c0c:	605a      	str	r2, [r3, #4]
}
    3c0e:	bf00      	nop
    3c10:	b002      	add	sp, #8
    3c12:	4770      	bx	lr
    3c14:	1fff8b20 	.word	0x1fff8b20

00003c18 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    3c18:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    3c1a:	2300      	movs	r3, #0
    3c1c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    3c1e:	4b07      	ldr	r3, [pc, #28]	; (3c3c <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    3c20:	681b      	ldr	r3, [r3, #0]
    3c22:	685b      	ldr	r3, [r3, #4]
    3c24:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    3c26:	9b01      	ldr	r3, [sp, #4]
    3c28:	f043 0302 	orr.w	r3, r3, #2
    3c2c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    3c2e:	4b03      	ldr	r3, [pc, #12]	; (3c3c <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    3c30:	681b      	ldr	r3, [r3, #0]
    3c32:	9a01      	ldr	r2, [sp, #4]
    3c34:	605a      	str	r2, [r3, #4]
}
    3c36:	bf00      	nop
    3c38:	b002      	add	sp, #8
    3c3a:	4770      	bx	lr
    3c3c:	1fff8b20 	.word	0x1fff8b20

00003c40 <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    3c40:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    3c42:	2300      	movs	r3, #0
    3c44:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    3c46:	4b07      	ldr	r3, [pc, #28]	; (3c64 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    3c48:	681b      	ldr	r3, [r3, #0]
    3c4a:	685b      	ldr	r3, [r3, #4]
    3c4c:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    3c4e:	9b01      	ldr	r3, [sp, #4]
    3c50:	f043 0304 	orr.w	r3, r3, #4
    3c54:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    3c56:	4b03      	ldr	r3, [pc, #12]	; (3c64 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    3c58:	681b      	ldr	r3, [r3, #0]
    3c5a:	9a01      	ldr	r2, [sp, #4]
    3c5c:	605a      	str	r2, [r3, #4]
}
    3c5e:	bf00      	nop
    3c60:	b002      	add	sp, #8
    3c62:	4770      	bx	lr
    3c64:	1fff8b20 	.word	0x1fff8b20

00003c68 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    3c68:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    3c6a:	2300      	movs	r3, #0
    3c6c:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    3c6e:	4b07      	ldr	r3, [pc, #28]	; (3c8c <Power_Ip_CM4_DisableDeepSleep+0x24>)
    3c70:	681b      	ldr	r3, [r3, #0]
    3c72:	685b      	ldr	r3, [r3, #4]
    3c74:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    3c76:	9b01      	ldr	r3, [sp, #4]
    3c78:	f023 0304 	bic.w	r3, r3, #4
    3c7c:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    3c7e:	4b03      	ldr	r3, [pc, #12]	; (3c8c <Power_Ip_CM4_DisableDeepSleep+0x24>)
    3c80:	681b      	ldr	r3, [r3, #0]
    3c82:	9a01      	ldr	r2, [sp, #4]
    3c84:	605a      	str	r2, [r3, #4]
}
    3c86:	bf00      	nop
    3c88:	b002      	add	sp, #8
    3c8a:	4770      	bx	lr
    3c8c:	1fff8b20 	.word	0x1fff8b20

00003c90 <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    3c90:	b082      	sub	sp, #8
    3c92:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3c94:	bf00      	nop
    3c96:	b002      	add	sp, #8
    3c98:	4770      	bx	lr

00003c9a <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    3c9a:	b082      	sub	sp, #8
    3c9c:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    3c9e:	2300      	movs	r3, #0
}
    3ca0:	4618      	mov	r0, r3
    3ca2:	b002      	add	sp, #8
    3ca4:	4770      	bx	lr

00003ca6 <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    3ca6:	b082      	sub	sp, #8
    3ca8:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3caa:	bf00      	nop
    3cac:	b002      	add	sp, #8
    3cae:	4770      	bx	lr

00003cb0 <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    3cb0:	b082      	sub	sp, #8
    3cb2:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3cb4:	bf00      	nop
    3cb6:	b002      	add	sp, #8
    3cb8:	4770      	bx	lr

00003cba <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    3cba:	b082      	sub	sp, #8
    3cbc:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    3cbe:	bf00      	nop
    3cc0:	b002      	add	sp, #8
    3cc2:	4770      	bx	lr

00003cc4 <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3cc4:	b500      	push	{lr}
    3cc6:	b083      	sub	sp, #12
    3cc8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3cca:	9b01      	ldr	r3, [sp, #4]
    3ccc:	2b00      	cmp	r3, #0
    3cce:	d002      	beq.n	3cd6 <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    3cd0:	9801      	ldr	r0, [sp, #4]
    3cd2:	f000 f8d1 	bl	3e78 <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3cd6:	bf00      	nop
    3cd8:	b003      	add	sp, #12
    3cda:	f85d fb04 	ldr.w	pc, [sp], #4

00003cde <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3cde:	b500      	push	{lr}
    3ce0:	b083      	sub	sp, #12
    3ce2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3ce4:	9b01      	ldr	r3, [sp, #4]
    3ce6:	2b00      	cmp	r3, #0
    3ce8:	d002      	beq.n	3cf0 <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    3cea:	9801      	ldr	r0, [sp, #4]
    3cec:	f000 f950 	bl	3f90 <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3cf0:	bf00      	nop
    3cf2:	b003      	add	sp, #12
    3cf4:	f85d fb04 	ldr.w	pc, [sp], #4

00003cf8 <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    3cf8:	b500      	push	{lr}
    3cfa:	b083      	sub	sp, #12
    3cfc:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    3cfe:	9801      	ldr	r0, [sp, #4]
    3d00:	f000 f98e 	bl	4020 <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3d04:	bf00      	nop
    3d06:	b003      	add	sp, #12
    3d08:	f85d fb04 	ldr.w	pc, [sp], #4

00003d0c <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    3d0c:	b500      	push	{lr}
    3d0e:	b083      	sub	sp, #12
    3d10:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3d12:	9b01      	ldr	r3, [sp, #4]
    3d14:	2b00      	cmp	r3, #0
    3d16:	d002      	beq.n	3d1e <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    3d18:	9801      	ldr	r0, [sp, #4]
    3d1a:	f000 f999 	bl	4050 <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3d1e:	bf00      	nop
    3d20:	b003      	add	sp, #12
    3d22:	f85d fb04 	ldr.w	pc, [sp], #4

00003d26 <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    3d26:	b500      	push	{lr}
    3d28:	b083      	sub	sp, #12
    3d2a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3d2c:	9b01      	ldr	r3, [sp, #4]
    3d2e:	2b00      	cmp	r3, #0
    3d30:	d002      	beq.n	3d38 <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    3d32:	9801      	ldr	r0, [sp, #4]
    3d34:	f000 f9b0 	bl	4098 <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3d38:	bf00      	nop
    3d3a:	b003      	add	sp, #12
    3d3c:	f85d fb04 	ldr.w	pc, [sp], #4

00003d40 <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    3d40:	b500      	push	{lr}
    3d42:	b083      	sub	sp, #12
    3d44:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    3d46:	9801      	ldr	r0, [sp, #4]
    3d48:	f000 f9ba 	bl	40c0 <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3d4c:	bf00      	nop
    3d4e:	b003      	add	sp, #12
    3d50:	f85d fb04 	ldr.w	pc, [sp], #4

00003d54 <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3d54:	b500      	push	{lr}
    3d56:	b083      	sub	sp, #12
    3d58:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3d5a:	9b01      	ldr	r3, [sp, #4]
    3d5c:	2b00      	cmp	r3, #0
    3d5e:	d002      	beq.n	3d66 <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    3d60:	9801      	ldr	r0, [sp, #4]
    3d62:	f000 f9bd 	bl	40e0 <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3d66:	bf00      	nop
    3d68:	b003      	add	sp, #12
    3d6a:	f85d fb04 	ldr.w	pc, [sp], #4

00003d6e <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3d6e:	b500      	push	{lr}
    3d70:	b083      	sub	sp, #12
    3d72:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3d74:	9b01      	ldr	r3, [sp, #4]
    3d76:	2b00      	cmp	r3, #0
    3d78:	d002      	beq.n	3d80 <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    3d7a:	9801      	ldr	r0, [sp, #4]
    3d7c:	f000 f9d4 	bl	4128 <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3d80:	bf00      	nop
    3d82:	b003      	add	sp, #12
    3d84:	f85d fb04 	ldr.w	pc, [sp], #4

00003d88 <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    3d88:	b500      	push	{lr}
    3d8a:	b083      	sub	sp, #12
    3d8c:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    3d8e:	9801      	ldr	r0, [sp, #4]
    3d90:	f000 f9de 	bl	4150 <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3d94:	bf00      	nop
    3d96:	b003      	add	sp, #12
    3d98:	f85d fb04 	ldr.w	pc, [sp], #4

00003d9c <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    3d9c:	b500      	push	{lr}
    3d9e:	b089      	sub	sp, #36	; 0x24
    3da0:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    3da2:	2300      	movs	r3, #0
    3da4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    3da8:	4b20      	ldr	r3, [pc, #128]	; (3e2c <SetInputSouceSytemClock+0x90>)
    3daa:	695b      	ldr	r3, [r3, #20]
    3dac:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    3dae:	9b06      	ldr	r3, [sp, #24]
    3db0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3db4:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    3db6:	9b01      	ldr	r3, [sp, #4]
    3db8:	061b      	lsls	r3, r3, #24
    3dba:	9a06      	ldr	r2, [sp, #24]
    3dbc:	4313      	orrs	r3, r2
    3dbe:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    3dc0:	4a1a      	ldr	r2, [pc, #104]	; (3e2c <SetInputSouceSytemClock+0x90>)
    3dc2:	9b06      	ldr	r3, [sp, #24]
    3dc4:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3dc6:	aa02      	add	r2, sp, #8
    3dc8:	a903      	add	r1, sp, #12
    3dca:	a804      	add	r0, sp, #16
    3dcc:	f24c 3350 	movw	r3, #50000	; 0xc350
    3dd0:	f7ff fbc0 	bl	3554 <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    3dd4:	4b15      	ldr	r3, [pc, #84]	; (3e2c <SetInputSouceSytemClock+0x90>)
    3dd6:	691b      	ldr	r3, [r3, #16]
    3dd8:	0e1b      	lsrs	r3, r3, #24
    3dda:	f003 030f 	and.w	r3, r3, #15
    3dde:	9a01      	ldr	r2, [sp, #4]
    3de0:	429a      	cmp	r2, r3
    3de2:	bf0c      	ite	eq
    3de4:	2301      	moveq	r3, #1
    3de6:	2300      	movne	r3, #0
    3de8:	b2db      	uxtb	r3, r3
    3dea:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3dec:	9a02      	ldr	r2, [sp, #8]
    3dee:	a903      	add	r1, sp, #12
    3df0:	ab04      	add	r3, sp, #16
    3df2:	4618      	mov	r0, r3
    3df4:	f7ff fbc8 	bl	3588 <Clock_Ip_TimeoutExpired>
    3df8:	4603      	mov	r3, r0
    3dfa:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    3dfe:	9b05      	ldr	r3, [sp, #20]
    3e00:	2b00      	cmp	r3, #0
    3e02:	d106      	bne.n	3e12 <SetInputSouceSytemClock+0x76>
    3e04:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3e08:	f083 0301 	eor.w	r3, r3, #1
    3e0c:	b2db      	uxtb	r3, r3
    3e0e:	2b00      	cmp	r3, #0
    3e10:	d1e0      	bne.n	3dd4 <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    3e12:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3e16:	2b00      	cmp	r3, #0
    3e18:	d003      	beq.n	3e22 <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3e1a:	2105      	movs	r1, #5
    3e1c:	2001      	movs	r0, #1
    3e1e:	f7ff fb89 	bl	3534 <Clock_Ip_ReportClockErrors>
    }
}
    3e22:	bf00      	nop
    3e24:	b009      	add	sp, #36	; 0x24
    3e26:	f85d fb04 	ldr.w	pc, [sp], #4
    3e2a:	bf00      	nop
    3e2c:	40064000 	.word	0x40064000

00003e30 <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3e30:	b500      	push	{lr}
    3e32:	b083      	sub	sp, #12
    3e34:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3e36:	9b01      	ldr	r3, [sp, #4]
    3e38:	2b00      	cmp	r3, #0
    3e3a:	d002      	beq.n	3e42 <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    3e3c:	9801      	ldr	r0, [sp, #4]
    3e3e:	f000 f997 	bl	4170 <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3e42:	bf00      	nop
    3e44:	b003      	add	sp, #12
    3e46:	f85d fb04 	ldr.w	pc, [sp], #4

00003e4a <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3e4a:	b500      	push	{lr}
    3e4c:	b083      	sub	sp, #12
    3e4e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3e50:	9b01      	ldr	r3, [sp, #4]
    3e52:	2b00      	cmp	r3, #0
    3e54:	d002      	beq.n	3e5c <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    3e56:	9801      	ldr	r0, [sp, #4]
    3e58:	f000 fa7e 	bl	4358 <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3e5c:	bf00      	nop
    3e5e:	b003      	add	sp, #12
    3e60:	f85d fb04 	ldr.w	pc, [sp], #4

00003e64 <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    3e64:	b500      	push	{lr}
    3e66:	b083      	sub	sp, #12
    3e68:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    3e6a:	9801      	ldr	r0, [sp, #4]
    3e6c:	f000 fab8 	bl	43e0 <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3e70:	bf00      	nop
    3e72:	b003      	add	sp, #12
    3e74:	f85d fb04 	ldr.w	pc, [sp], #4

00003e78 <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3e78:	b500      	push	{lr}
    3e7a:	b08b      	sub	sp, #44	; 0x2c
    3e7c:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3e7e:	2300      	movs	r3, #0
    3e80:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    3e84:	9b01      	ldr	r3, [sp, #4]
    3e86:	2b00      	cmp	r3, #0
    3e88:	d10b      	bne.n	3ea2 <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    3e8a:	2305      	movs	r3, #5
    3e8c:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    3e8e:	2301      	movs	r3, #1
    3e90:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    3e94:	2301      	movs	r3, #1
    3e96:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    3e9a:	2301      	movs	r3, #1
    3e9c:	f88d 3010 	strb.w	r3, [sp, #16]
    3ea0:	e00e      	b.n	3ec0 <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    3ea2:	9b01      	ldr	r3, [sp, #4]
    3ea4:	681b      	ldr	r3, [r3, #0]
    3ea6:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    3ea8:	9b01      	ldr	r3, [sp, #4]
    3eaa:	79db      	ldrb	r3, [r3, #7]
    3eac:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    3eb0:	9b01      	ldr	r3, [sp, #4]
    3eb2:	889b      	ldrh	r3, [r3, #4]
    3eb4:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    3eb8:	9b01      	ldr	r3, [sp, #4]
    3eba:	7a1b      	ldrb	r3, [r3, #8]
    3ebc:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3ec0:	4b32      	ldr	r3, [pc, #200]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ec2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ec6:	4a31      	ldr	r2, [pc, #196]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ec8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3ecc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    3ed0:	4b2e      	ldr	r3, [pc, #184]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ed2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ed6:	4a2d      	ldr	r2, [pc, #180]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ed8:	f023 0301 	bic.w	r3, r3, #1
    3edc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3ee0:	4b2a      	ldr	r3, [pc, #168]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ee2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ee6:	4a29      	ldr	r2, [pc, #164]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ee8:	f023 0304 	bic.w	r3, r3, #4
    3eec:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    3ef0:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    3ef4:	2b01      	cmp	r3, #1
    3ef6:	d144      	bne.n	3f82 <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    3ef8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    3efc:	4a23      	ldr	r2, [pc, #140]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3efe:	f003 0301 	and.w	r3, r3, #1
    3f02:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3f06:	4b21      	ldr	r3, [pc, #132]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3f08:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3f0c:	4a1f      	ldr	r2, [pc, #124]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3f0e:	f043 0301 	orr.w	r3, r3, #1
    3f12:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    3f16:	4b1d      	ldr	r3, [pc, #116]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3f18:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3f1c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3f20:	009b      	lsls	r3, r3, #2
    3f22:	f003 0304 	and.w	r3, r3, #4
    3f26:	4919      	ldr	r1, [pc, #100]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3f28:	4313      	orrs	r3, r2
    3f2a:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3f2e:	aa05      	add	r2, sp, #20
    3f30:	a906      	add	r1, sp, #24
    3f32:	a807      	add	r0, sp, #28
    3f34:	f24c 3350 	movw	r3, #50000	; 0xc350
    3f38:	f7ff fb0c 	bl	3554 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3f3c:	4b13      	ldr	r3, [pc, #76]	; (3f8c <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3f3e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3f42:	0e1b      	lsrs	r3, r3, #24
    3f44:	f003 0301 	and.w	r3, r3, #1
    3f48:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3f4a:	9a05      	ldr	r2, [sp, #20]
    3f4c:	a906      	add	r1, sp, #24
    3f4e:	ab07      	add	r3, sp, #28
    3f50:	4618      	mov	r0, r3
    3f52:	f7ff fb19 	bl	3588 <Clock_Ip_TimeoutExpired>
    3f56:	4603      	mov	r3, r0
    3f58:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3f5c:	9b08      	ldr	r3, [sp, #32]
    3f5e:	2b00      	cmp	r3, #0
    3f60:	d106      	bne.n	3f70 <Clock_Ip_SetSirc_TrustedCall+0xf8>
    3f62:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3f66:	f083 0301 	eor.w	r3, r3, #1
    3f6a:	b2db      	uxtb	r3, r3
    3f6c:	2b00      	cmp	r3, #0
    3f6e:	d1e5      	bne.n	3f3c <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    3f70:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3f74:	2b00      	cmp	r3, #0
    3f76:	d004      	beq.n	3f82 <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    3f78:	9b02      	ldr	r3, [sp, #8]
    3f7a:	4619      	mov	r1, r3
    3f7c:	2001      	movs	r0, #1
    3f7e:	f7ff fad9 	bl	3534 <Clock_Ip_ReportClockErrors>
        }
    }
}
    3f82:	bf00      	nop
    3f84:	b00b      	add	sp, #44	; 0x2c
    3f86:	f85d fb04 	ldr.w	pc, [sp], #4
    3f8a:	bf00      	nop
    3f8c:	40064000 	.word	0x40064000

00003f90 <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3f90:	b500      	push	{lr}
    3f92:	b089      	sub	sp, #36	; 0x24
    3f94:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3f96:	2300      	movs	r3, #0
    3f98:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3f9c:	4b1f      	ldr	r3, [pc, #124]	; (401c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3f9e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3fa2:	4a1e      	ldr	r2, [pc, #120]	; (401c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3fa4:	f043 0301 	orr.w	r3, r3, #1
    3fa8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    3fac:	4b1b      	ldr	r3, [pc, #108]	; (401c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3fae:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3fb2:	4a1a      	ldr	r2, [pc, #104]	; (401c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3fb4:	f043 0304 	orr.w	r3, r3, #4
    3fb8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3fbc:	aa03      	add	r2, sp, #12
    3fbe:	a904      	add	r1, sp, #16
    3fc0:	a805      	add	r0, sp, #20
    3fc2:	f24c 3350 	movw	r3, #50000	; 0xc350
    3fc6:	f7ff fac5 	bl	3554 <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3fca:	4b14      	ldr	r3, [pc, #80]	; (401c <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3fcc:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3fd0:	0e1b      	lsrs	r3, r3, #24
    3fd2:	f003 0301 	and.w	r3, r3, #1
    3fd6:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3fd8:	9a03      	ldr	r2, [sp, #12]
    3fda:	a904      	add	r1, sp, #16
    3fdc:	ab05      	add	r3, sp, #20
    3fde:	4618      	mov	r0, r3
    3fe0:	f7ff fad2 	bl	3588 <Clock_Ip_TimeoutExpired>
    3fe4:	4603      	mov	r3, r0
    3fe6:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3fea:	9b06      	ldr	r3, [sp, #24]
    3fec:	2b00      	cmp	r3, #0
    3fee:	d106      	bne.n	3ffe <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    3ff0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3ff4:	f083 0301 	eor.w	r3, r3, #1
    3ff8:	b2db      	uxtb	r3, r3
    3ffa:	2b00      	cmp	r3, #0
    3ffc:	d1e5      	bne.n	3fca <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    3ffe:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4002:	2b00      	cmp	r3, #0
    4004:	d005      	beq.n	4012 <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    4006:	9b01      	ldr	r3, [sp, #4]
    4008:	681b      	ldr	r3, [r3, #0]
    400a:	4619      	mov	r1, r3
    400c:	2001      	movs	r0, #1
    400e:	f7ff fa91 	bl	3534 <Clock_Ip_ReportClockErrors>
    }
}
    4012:	bf00      	nop
    4014:	b009      	add	sp, #36	; 0x24
    4016:	f85d fb04 	ldr.w	pc, [sp], #4
    401a:	bf00      	nop
    401c:	40064000 	.word	0x40064000

00004020 <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    4020:	b082      	sub	sp, #8
    4022:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    4024:	4b09      	ldr	r3, [pc, #36]	; (404c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    4026:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    402a:	4a08      	ldr	r2, [pc, #32]	; (404c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    402c:	f023 0301 	bic.w	r3, r3, #1
    4030:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    4034:	4b05      	ldr	r3, [pc, #20]	; (404c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    4036:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    403a:	4a04      	ldr	r2, [pc, #16]	; (404c <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    403c:	f023 0304 	bic.w	r3, r3, #4
    4040:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    4044:	bf00      	nop
    4046:	b002      	add	sp, #8
    4048:	4770      	bx	lr
    404a:	bf00      	nop
    404c:	40064000 	.word	0x40064000

00004050 <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4050:	b082      	sub	sp, #8
    4052:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    4054:	4b0f      	ldr	r3, [pc, #60]	; (4094 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    4056:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    405a:	4a0e      	ldr	r2, [pc, #56]	; (4094 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    405c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4060:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    4064:	4b0b      	ldr	r3, [pc, #44]	; (4094 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    4066:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    406a:	4a0a      	ldr	r2, [pc, #40]	; (4094 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    406c:	f023 0304 	bic.w	r3, r3, #4
    4070:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    4074:	4b07      	ldr	r3, [pc, #28]	; (4094 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    4076:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    407a:	9b01      	ldr	r3, [sp, #4]
    407c:	7a1b      	ldrb	r3, [r3, #8]
    407e:	009b      	lsls	r3, r3, #2
    4080:	f003 0304 	and.w	r3, r3, #4
    4084:	4903      	ldr	r1, [pc, #12]	; (4094 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    4086:	4313      	orrs	r3, r2
    4088:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    408c:	bf00      	nop
    408e:	b002      	add	sp, #8
    4090:	4770      	bx	lr
    4092:	bf00      	nop
    4094:	40064000 	.word	0x40064000

00004098 <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4098:	b082      	sub	sp, #8
    409a:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    409c:	9b01      	ldr	r3, [sp, #4]
    409e:	889b      	ldrh	r3, [r3, #4]
    40a0:	2b01      	cmp	r3, #1
    40a2:	d107      	bne.n	40b4 <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    40a4:	4b05      	ldr	r3, [pc, #20]	; (40bc <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    40a6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    40aa:	4a04      	ldr	r2, [pc, #16]	; (40bc <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    40ac:	f043 0304 	orr.w	r3, r3, #4
    40b0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    40b4:	bf00      	nop
    40b6:	b002      	add	sp, #8
    40b8:	4770      	bx	lr
    40ba:	bf00      	nop
    40bc:	40064000 	.word	0x40064000

000040c0 <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    40c0:	b082      	sub	sp, #8
    40c2:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    40c4:	4b05      	ldr	r3, [pc, #20]	; (40dc <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    40c6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    40ca:	4a04      	ldr	r2, [pc, #16]	; (40dc <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    40cc:	f023 0304 	bic.w	r3, r3, #4
    40d0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    40d4:	bf00      	nop
    40d6:	b002      	add	sp, #8
    40d8:	4770      	bx	lr
    40da:	bf00      	nop
    40dc:	40064000 	.word	0x40064000

000040e0 <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    40e0:	b082      	sub	sp, #8
    40e2:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    40e4:	4b0f      	ldr	r3, [pc, #60]	; (4124 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    40e6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    40ea:	4a0e      	ldr	r2, [pc, #56]	; (4124 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    40ec:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    40f0:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    40f4:	4b0b      	ldr	r3, [pc, #44]	; (4124 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    40f6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    40fa:	4a0a      	ldr	r2, [pc, #40]	; (4124 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    40fc:	f023 0302 	bic.w	r3, r3, #2
    4100:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    4104:	4b07      	ldr	r3, [pc, #28]	; (4124 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    4106:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    410a:	9b01      	ldr	r3, [sp, #4]
    410c:	7a5b      	ldrb	r3, [r3, #9]
    410e:	005b      	lsls	r3, r3, #1
    4110:	f003 0302 	and.w	r3, r3, #2
    4114:	4903      	ldr	r1, [pc, #12]	; (4124 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    4116:	4313      	orrs	r3, r2
    4118:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    411c:	bf00      	nop
    411e:	b002      	add	sp, #8
    4120:	4770      	bx	lr
    4122:	bf00      	nop
    4124:	40064000 	.word	0x40064000

00004128 <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4128:	b082      	sub	sp, #8
    412a:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    412c:	9b01      	ldr	r3, [sp, #4]
    412e:	889b      	ldrh	r3, [r3, #4]
    4130:	2b01      	cmp	r3, #1
    4132:	d107      	bne.n	4144 <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    4134:	4b05      	ldr	r3, [pc, #20]	; (414c <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    4136:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    413a:	4a04      	ldr	r2, [pc, #16]	; (414c <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    413c:	f043 0302 	orr.w	r3, r3, #2
    4140:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    4144:	bf00      	nop
    4146:	b002      	add	sp, #8
    4148:	4770      	bx	lr
    414a:	bf00      	nop
    414c:	40064000 	.word	0x40064000

00004150 <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    4150:	b082      	sub	sp, #8
    4152:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    4154:	4b05      	ldr	r3, [pc, #20]	; (416c <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    4156:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    415a:	4a04      	ldr	r2, [pc, #16]	; (416c <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    415c:	f023 0302 	bic.w	r3, r3, #2
    4160:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    4164:	bf00      	nop
    4166:	b002      	add	sp, #8
    4168:	4770      	bx	lr
    416a:	bf00      	nop
    416c:	40064000 	.word	0x40064000

00004170 <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4170:	b500      	push	{lr}
    4172:	b08b      	sub	sp, #44	; 0x2c
    4174:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    4176:	9b01      	ldr	r3, [sp, #4]
    4178:	681a      	ldr	r2, [r3, #0]
    417a:	4975      	ldr	r1, [pc, #468]	; (4350 <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    417c:	4613      	mov	r3, r2
    417e:	00db      	lsls	r3, r3, #3
    4180:	4413      	add	r3, r2
    4182:	440b      	add	r3, r1
    4184:	781b      	ldrb	r3, [r3, #0]
    4186:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    4188:	2300      	movs	r3, #0
    418a:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    418e:	2300      	movs	r3, #0
    4190:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    4194:	4b6f      	ldr	r3, [pc, #444]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4196:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    419a:	4a6e      	ldr	r2, [pc, #440]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    419c:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    41a0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    41a4:	4b6b      	ldr	r3, [pc, #428]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    41a6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    41aa:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    41ae:	2b00      	cmp	r3, #0
    41b0:	d07d      	beq.n	42ae <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    41b2:	9b01      	ldr	r3, [sp, #4]
    41b4:	79db      	ldrb	r3, [r3, #7]
    41b6:	461a      	mov	r2, r3
    41b8:	4b66      	ldr	r3, [pc, #408]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    41ba:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    41be:	f003 0303 	and.w	r3, r3, #3
    41c2:	429a      	cmp	r2, r3
    41c4:	d10b      	bne.n	41de <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    41c6:	9b01      	ldr	r3, [sp, #4]
    41c8:	799b      	ldrb	r3, [r3, #6]
    41ca:	461a      	mov	r2, r3
    41cc:	4b61      	ldr	r3, [pc, #388]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    41ce:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    41d2:	08db      	lsrs	r3, r3, #3
    41d4:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    41d8:	429a      	cmp	r2, r3
    41da:	f000 80b4 	beq.w	4346 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    41de:	4b5d      	ldr	r3, [pc, #372]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    41e0:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    41e4:	f003 0301 	and.w	r3, r3, #1
    41e8:	2b00      	cmp	r3, #0
    41ea:	d105      	bne.n	41f8 <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    41ec:	2301      	movs	r3, #1
    41ee:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    41f2:	2000      	movs	r0, #0
    41f4:	f7ff fd66 	bl	3cc4 <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    41f8:	2002      	movs	r0, #2
    41fa:	f7ff fdcf 	bl	3d9c <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    41fe:	4b55      	ldr	r3, [pc, #340]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4200:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4204:	4a53      	ldr	r2, [pc, #332]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4206:	f023 0301 	bic.w	r3, r3, #1
    420a:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    420e:	9b01      	ldr	r3, [sp, #4]
    4210:	889b      	ldrh	r3, [r3, #4]
    4212:	2b01      	cmp	r3, #1
    4214:	f040 8097 	bne.w	4346 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    4218:	9b01      	ldr	r3, [sp, #4]
    421a:	79db      	ldrb	r3, [r3, #7]
    421c:	4a4d      	ldr	r2, [pc, #308]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    421e:	f003 0303 	and.w	r3, r3, #3
    4222:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    4226:	4b4b      	ldr	r3, [pc, #300]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4228:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    422c:	9b01      	ldr	r3, [sp, #4]
    422e:	799b      	ldrb	r3, [r3, #6]
    4230:	00db      	lsls	r3, r3, #3
    4232:	f003 0308 	and.w	r3, r3, #8
    4236:	4313      	orrs	r3, r2
    4238:	4a46      	ldr	r2, [pc, #280]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    423a:	f043 0301 	orr.w	r3, r3, #1
    423e:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4242:	aa03      	add	r2, sp, #12
    4244:	a904      	add	r1, sp, #16
    4246:	a805      	add	r0, sp, #20
    4248:	f24c 3350 	movw	r3, #50000	; 0xc350
    424c:	f7ff f982 	bl	3554 <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    4250:	4b40      	ldr	r3, [pc, #256]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4252:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4256:	0e1b      	lsrs	r3, r3, #24
    4258:	f003 0301 	and.w	r3, r3, #1
    425c:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    425e:	9a03      	ldr	r2, [sp, #12]
    4260:	a904      	add	r1, sp, #16
    4262:	ab05      	add	r3, sp, #20
    4264:	4618      	mov	r0, r3
    4266:	f7ff f98f 	bl	3588 <Clock_Ip_TimeoutExpired>
    426a:	4603      	mov	r3, r0
    426c:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    4270:	9b06      	ldr	r3, [sp, #24]
    4272:	2b00      	cmp	r3, #0
    4274:	d106      	bne.n	4284 <Clock_Ip_SetFirc_TrustedCall+0x114>
    4276:	f89d 301f 	ldrb.w	r3, [sp, #31]
    427a:	f083 0301 	eor.w	r3, r3, #1
    427e:	b2db      	uxtb	r3, r3
    4280:	2b00      	cmp	r3, #0
    4282:	d1e5      	bne.n	4250 <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    4284:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4288:	2b00      	cmp	r3, #0
    428a:	d005      	beq.n	4298 <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    428c:	9b01      	ldr	r3, [sp, #4]
    428e:	681b      	ldr	r3, [r3, #0]
    4290:	4619      	mov	r1, r3
    4292:	2001      	movs	r0, #1
    4294:	f7ff f94e 	bl	3534 <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    4298:	2003      	movs	r0, #3
    429a:	f7ff fd7f 	bl	3d9c <SetInputSouceSytemClock>

                if (SircWasDisabled)
    429e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    42a2:	2b00      	cmp	r3, #0
    42a4:	d04f      	beq.n	4346 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    42a6:	2002      	movs	r0, #2
    42a8:	f7ff fd26 	bl	3cf8 <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    42ac:	e04b      	b.n	4346 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    42ae:	4b29      	ldr	r3, [pc, #164]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42b0:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    42b4:	4a27      	ldr	r2, [pc, #156]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42b6:	f023 0301 	bic.w	r3, r3, #1
    42ba:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    42be:	9b01      	ldr	r3, [sp, #4]
    42c0:	889b      	ldrh	r3, [r3, #4]
    42c2:	2b01      	cmp	r3, #1
    42c4:	d13f      	bne.n	4346 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    42c6:	9b01      	ldr	r3, [sp, #4]
    42c8:	79db      	ldrb	r3, [r3, #7]
    42ca:	4a22      	ldr	r2, [pc, #136]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42cc:	f003 0303 	and.w	r3, r3, #3
    42d0:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    42d4:	4b1f      	ldr	r3, [pc, #124]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42d6:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    42da:	9b01      	ldr	r3, [sp, #4]
    42dc:	799b      	ldrb	r3, [r3, #6]
    42de:	00db      	lsls	r3, r3, #3
    42e0:	f003 0308 	and.w	r3, r3, #8
    42e4:	4313      	orrs	r3, r2
    42e6:	4a1b      	ldr	r2, [pc, #108]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    42e8:	f043 0301 	orr.w	r3, r3, #1
    42ec:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    42f0:	aa03      	add	r2, sp, #12
    42f2:	a904      	add	r1, sp, #16
    42f4:	a805      	add	r0, sp, #20
    42f6:	f24c 3350 	movw	r3, #50000	; 0xc350
    42fa:	f7ff f92b 	bl	3554 <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    42fe:	4b15      	ldr	r3, [pc, #84]	; (4354 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4300:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4304:	0e1b      	lsrs	r3, r3, #24
    4306:	f003 0301 	and.w	r3, r3, #1
    430a:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    430c:	9a03      	ldr	r2, [sp, #12]
    430e:	a904      	add	r1, sp, #16
    4310:	ab05      	add	r3, sp, #20
    4312:	4618      	mov	r0, r3
    4314:	f7ff f938 	bl	3588 <Clock_Ip_TimeoutExpired>
    4318:	4603      	mov	r3, r0
    431a:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    431e:	9b06      	ldr	r3, [sp, #24]
    4320:	2b00      	cmp	r3, #0
    4322:	d106      	bne.n	4332 <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    4324:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4328:	f083 0301 	eor.w	r3, r3, #1
    432c:	b2db      	uxtb	r3, r3
    432e:	2b00      	cmp	r3, #0
    4330:	d1e5      	bne.n	42fe <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    4332:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4336:	2b00      	cmp	r3, #0
    4338:	d005      	beq.n	4346 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    433a:	9b01      	ldr	r3, [sp, #4]
    433c:	681b      	ldr	r3, [r3, #0]
    433e:	4619      	mov	r1, r3
    4340:	2001      	movs	r0, #1
    4342:	f7ff f8f7 	bl	3534 <Clock_Ip_ReportClockErrors>
}
    4346:	bf00      	nop
    4348:	b00b      	add	sp, #44	; 0x2c
    434a:	f85d fb04 	ldr.w	pc, [sp], #4
    434e:	bf00      	nop
    4350:	0000a6f0 	.word	0x0000a6f0
    4354:	40064000 	.word	0x40064000

00004358 <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4358:	b500      	push	{lr}
    435a:	b089      	sub	sp, #36	; 0x24
    435c:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    435e:	2300      	movs	r3, #0
    4360:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    4364:	9b01      	ldr	r3, [sp, #4]
    4366:	889b      	ldrh	r3, [r3, #4]
    4368:	2b01      	cmp	r3, #1
    436a:	d132      	bne.n	43d2 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    436c:	4b1b      	ldr	r3, [pc, #108]	; (43dc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    436e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4372:	4a1a      	ldr	r2, [pc, #104]	; (43dc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    4374:	f043 0301 	orr.w	r3, r3, #1
    4378:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    437c:	aa03      	add	r2, sp, #12
    437e:	a904      	add	r1, sp, #16
    4380:	a805      	add	r0, sp, #20
    4382:	f24c 3350 	movw	r3, #50000	; 0xc350
    4386:	f7ff f8e5 	bl	3554 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    438a:	4b14      	ldr	r3, [pc, #80]	; (43dc <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    438c:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4390:	0e1b      	lsrs	r3, r3, #24
    4392:	f003 0301 	and.w	r3, r3, #1
    4396:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4398:	9a03      	ldr	r2, [sp, #12]
    439a:	a904      	add	r1, sp, #16
    439c:	ab05      	add	r3, sp, #20
    439e:	4618      	mov	r0, r3
    43a0:	f7ff f8f2 	bl	3588 <Clock_Ip_TimeoutExpired>
    43a4:	4603      	mov	r3, r0
    43a6:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    43aa:	9b06      	ldr	r3, [sp, #24]
    43ac:	2b00      	cmp	r3, #0
    43ae:	d106      	bne.n	43be <Clock_Ip_EnableFirc_TrustedCall+0x66>
    43b0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    43b4:	f083 0301 	eor.w	r3, r3, #1
    43b8:	b2db      	uxtb	r3, r3
    43ba:	2b00      	cmp	r3, #0
    43bc:	d1e5      	bne.n	438a <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    43be:	f89d 301f 	ldrb.w	r3, [sp, #31]
    43c2:	2b00      	cmp	r3, #0
    43c4:	d005      	beq.n	43d2 <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    43c6:	9b01      	ldr	r3, [sp, #4]
    43c8:	681b      	ldr	r3, [r3, #0]
    43ca:	4619      	mov	r1, r3
    43cc:	2001      	movs	r0, #1
    43ce:	f7ff f8b1 	bl	3534 <Clock_Ip_ReportClockErrors>
        }
    }
}
    43d2:	bf00      	nop
    43d4:	b009      	add	sp, #36	; 0x24
    43d6:	f85d fb04 	ldr.w	pc, [sp], #4
    43da:	bf00      	nop
    43dc:	40064000 	.word	0x40064000

000043e0 <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    43e0:	b082      	sub	sp, #8
    43e2:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    43e4:	4b05      	ldr	r3, [pc, #20]	; (43fc <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    43e6:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    43ea:	4a04      	ldr	r2, [pc, #16]	; (43fc <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    43ec:	f023 0301 	bic.w	r3, r3, #1
    43f0:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    43f4:	bf00      	nop
    43f6:	b002      	add	sp, #8
    43f8:	4770      	bx	lr
    43fa:	bf00      	nop
    43fc:	40064000 	.word	0x40064000

00004400 <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    4400:	b084      	sub	sp, #16
    4402:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    4404:	4b20      	ldr	r3, [pc, #128]	; (4488 <Power_Ip_PMC_PowerInit+0x88>)
    4406:	781b      	ldrb	r3, [r3, #0]
    4408:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    440c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4410:	f003 030f 	and.w	r3, r3, #15
    4414:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    4418:	9b01      	ldr	r3, [sp, #4]
    441a:	781a      	ldrb	r2, [r3, #0]
    441c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4420:	4313      	orrs	r3, r2
    4422:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    4426:	4a18      	ldr	r2, [pc, #96]	; (4488 <Power_Ip_PMC_PowerInit+0x88>)
    4428:	f89d 300f 	ldrb.w	r3, [sp, #15]
    442c:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    442e:	4b16      	ldr	r3, [pc, #88]	; (4488 <Power_Ip_PMC_PowerInit+0x88>)
    4430:	785b      	ldrb	r3, [r3, #1]
    4432:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    4436:	f89d 300f 	ldrb.w	r3, [sp, #15]
    443a:	f003 031f 	and.w	r3, r3, #31
    443e:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    4442:	9b01      	ldr	r3, [sp, #4]
    4444:	785a      	ldrb	r2, [r3, #1]
    4446:	f89d 300f 	ldrb.w	r3, [sp, #15]
    444a:	4313      	orrs	r3, r2
    444c:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    4450:	4a0d      	ldr	r2, [pc, #52]	; (4488 <Power_Ip_PMC_PowerInit+0x88>)
    4452:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4456:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    4458:	4b0b      	ldr	r3, [pc, #44]	; (4488 <Power_Ip_PMC_PowerInit+0x88>)
    445a:	789b      	ldrb	r3, [r3, #2]
    445c:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    4460:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4464:	f003 0338 	and.w	r3, r3, #56	; 0x38
    4468:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    446c:	9b01      	ldr	r3, [sp, #4]
    446e:	789a      	ldrb	r2, [r3, #2]
    4470:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4474:	4313      	orrs	r3, r2
    4476:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    447a:	4a03      	ldr	r2, [pc, #12]	; (4488 <Power_Ip_PMC_PowerInit+0x88>)
    447c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    4480:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    4482:	bf00      	nop
    4484:	b004      	add	sp, #16
    4486:	4770      	bx	lr
    4488:	4007d000 	.word	0x4007d000

0000448c <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    448c:	b082      	sub	sp, #8
    448e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4490:	bf00      	nop
    4492:	b002      	add	sp, #8
    4494:	4770      	bx	lr

00004496 <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    4496:	b082      	sub	sp, #8
    4498:	9001      	str	r0, [sp, #4]
    449a:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    449c:	bf00      	nop
    449e:	b002      	add	sp, #8
    44a0:	4770      	bx	lr

000044a2 <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    44a2:	b082      	sub	sp, #8
    44a4:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    44a6:	bf00      	nop
    44a8:	b002      	add	sp, #8
    44aa:	4770      	bx	lr

000044ac <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    44ac:	b500      	push	{lr}
    44ae:	b083      	sub	sp, #12
    44b0:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    44b2:	9801      	ldr	r0, [sp, #4]
    44b4:	f7fd ffd4 	bl	2460 <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    44b8:	bf00      	nop
    44ba:	b003      	add	sp, #12
    44bc:	f85d fb04 	ldr.w	pc, [sp], #4

000044c0 <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    44c0:	b500      	push	{lr}
    44c2:	b083      	sub	sp, #12
    44c4:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    44c6:	9801      	ldr	r0, [sp, #4]
    44c8:	f7fe faee 	bl	2aa8 <Clock_Ip_InitClock>
}
    44cc:	bf00      	nop
    44ce:	b003      	add	sp, #12
    44d0:	f85d fb04 	ldr.w	pc, [sp], #4

000044d4 <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    44d4:	b500      	push	{lr}
    44d6:	b083      	sub	sp, #12
    44d8:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    44da:	9801      	ldr	r0, [sp, #4]
    44dc:	f7fd ff72 	bl	23c4 <Power_Ip_SetMode>
}
    44e0:	bf00      	nop
    44e2:	b003      	add	sp, #12
    44e4:	f85d fb04 	ldr.w	pc, [sp], #4

000044e8 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    44e8:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    44ea:	f7fd ffa1 	bl	2430 <Power_Ip_GetResetReason>
    44ee:	4603      	mov	r3, r0
}
    44f0:	4618      	mov	r0, r3
    44f2:	bd08      	pop	{r3, pc}

000044f4 <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    44f4:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    44f6:	f7fd ffa9 	bl	244c <Power_Ip_GetResetRawValue>
    44fa:	4603      	mov	r3, r0
}
    44fc:	4618      	mov	r0, r3
    44fe:	bd08      	pop	{r3, pc}

00004500 <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    4500:	b500      	push	{lr}
    4502:	b083      	sub	sp, #12
    4504:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    4506:	9b01      	ldr	r3, [sp, #4]
    4508:	2b00      	cmp	r3, #0
    450a:	d102      	bne.n	4512 <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    450c:	f7fd ffbe 	bl	248c <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    4510:	e001      	b.n	4516 <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    4512:	f7fd ffc0 	bl	2496 <Power_Ip_EnableSleepOnExit>
}
    4516:	bf00      	nop
    4518:	b003      	add	sp, #12
    451a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00004520 <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    4520:	b082      	sub	sp, #8
    4522:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4524:	bf00      	nop
    4526:	b002      	add	sp, #8
    4528:	4770      	bx	lr

0000452a <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    452a:	b500      	push	{lr}
    452c:	b083      	sub	sp, #12
    452e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4530:	9b01      	ldr	r3, [sp, #4]
    4532:	2b00      	cmp	r3, #0
    4534:	d002      	beq.n	453c <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    4536:	9801      	ldr	r0, [sp, #4]
    4538:	f000 f8ad 	bl	4696 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    453c:	bf00      	nop
    453e:	b003      	add	sp, #12
    4540:	f85d fb04 	ldr.w	pc, [sp], #4

00004544 <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    4544:	b500      	push	{lr}
    4546:	b083      	sub	sp, #12
    4548:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    454a:	9b01      	ldr	r3, [sp, #4]
    454c:	2b00      	cmp	r3, #0
    454e:	d002      	beq.n	4556 <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    4550:	9801      	ldr	r0, [sp, #4]
    4552:	f000 f8cd 	bl	46f0 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4556:	bf00      	nop
    4558:	b003      	add	sp, #12
    455a:	f85d fb04 	ldr.w	pc, [sp], #4

0000455e <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    455e:	b500      	push	{lr}
    4560:	b083      	sub	sp, #12
    4562:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4564:	9b01      	ldr	r3, [sp, #4]
    4566:	2b00      	cmp	r3, #0
    4568:	d002      	beq.n	4570 <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    456a:	9801      	ldr	r0, [sp, #4]
    456c:	f000 f8ee 	bl	474c <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4570:	bf00      	nop
    4572:	b003      	add	sp, #12
    4574:	f85d fb04 	ldr.w	pc, [sp], #4

00004578 <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    4578:	b500      	push	{lr}
    457a:	b083      	sub	sp, #12
    457c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    457e:	9b01      	ldr	r3, [sp, #4]
    4580:	2b00      	cmp	r3, #0
    4582:	d002      	beq.n	458a <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    4584:	9801      	ldr	r0, [sp, #4]
    4586:	f000 f8f9 	bl	477c <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    458a:	bf00      	nop
    458c:	b003      	add	sp, #12
    458e:	f85d fb04 	ldr.w	pc, [sp], #4

00004592 <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    4592:	b500      	push	{lr}
    4594:	b083      	sub	sp, #12
    4596:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4598:	9b01      	ldr	r3, [sp, #4]
    459a:	2b00      	cmp	r3, #0
    459c:	d002      	beq.n	45a4 <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    459e:	9801      	ldr	r0, [sp, #4]
    45a0:	f000 f904 	bl	47ac <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    45a4:	bf00      	nop
    45a6:	b003      	add	sp, #12
    45a8:	f85d fb04 	ldr.w	pc, [sp], #4

000045ac <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    45ac:	b500      	push	{lr}
    45ae:	b083      	sub	sp, #12
    45b0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    45b2:	9b01      	ldr	r3, [sp, #4]
    45b4:	2b00      	cmp	r3, #0
    45b6:	d002      	beq.n	45be <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    45b8:	9801      	ldr	r0, [sp, #4]
    45ba:	f000 f90f 	bl	47dc <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    45be:	bf00      	nop
    45c0:	b003      	add	sp, #12
    45c2:	f85d fb04 	ldr.w	pc, [sp], #4

000045c6 <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    45c6:	b500      	push	{lr}
    45c8:	b083      	sub	sp, #12
    45ca:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    45cc:	9b01      	ldr	r3, [sp, #4]
    45ce:	2b00      	cmp	r3, #0
    45d0:	d002      	beq.n	45d8 <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    45d2:	9801      	ldr	r0, [sp, #4]
    45d4:	f000 f91a 	bl	480c <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    45d8:	bf00      	nop
    45da:	b003      	add	sp, #12
    45dc:	f85d fb04 	ldr.w	pc, [sp], #4

000045e0 <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    45e0:	b500      	push	{lr}
    45e2:	b083      	sub	sp, #12
    45e4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    45e6:	9b01      	ldr	r3, [sp, #4]
    45e8:	2b00      	cmp	r3, #0
    45ea:	d002      	beq.n	45f2 <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    45ec:	9801      	ldr	r0, [sp, #4]
    45ee:	f000 f925 	bl	483c <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    45f2:	bf00      	nop
    45f4:	b003      	add	sp, #12
    45f6:	f85d fb04 	ldr.w	pc, [sp], #4

000045fa <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    45fa:	b500      	push	{lr}
    45fc:	b083      	sub	sp, #12
    45fe:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4600:	9b01      	ldr	r3, [sp, #4]
    4602:	2b00      	cmp	r3, #0
    4604:	d002      	beq.n	460c <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    4606:	9801      	ldr	r0, [sp, #4]
    4608:	f000 f930 	bl	486c <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    460c:	bf00      	nop
    460e:	b003      	add	sp, #12
    4610:	f85d fb04 	ldr.w	pc, [sp], #4

00004614 <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    4614:	b500      	push	{lr}
    4616:	b083      	sub	sp, #12
    4618:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    461a:	9b01      	ldr	r3, [sp, #4]
    461c:	2b00      	cmp	r3, #0
    461e:	d002      	beq.n	4626 <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    4620:	9801      	ldr	r0, [sp, #4]
    4622:	f000 f93b 	bl	489c <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4626:	bf00      	nop
    4628:	b003      	add	sp, #12
    462a:	f85d fb04 	ldr.w	pc, [sp], #4

0000462e <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    462e:	b500      	push	{lr}
    4630:	b083      	sub	sp, #12
    4632:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4634:	9b01      	ldr	r3, [sp, #4]
    4636:	2b00      	cmp	r3, #0
    4638:	d002      	beq.n	4640 <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    463a:	9801      	ldr	r0, [sp, #4]
    463c:	f000 f946 	bl	48cc <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4640:	bf00      	nop
    4642:	b003      	add	sp, #12
    4644:	f85d fb04 	ldr.w	pc, [sp], #4

00004648 <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    4648:	b500      	push	{lr}
    464a:	b083      	sub	sp, #12
    464c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    464e:	9b01      	ldr	r3, [sp, #4]
    4650:	2b00      	cmp	r3, #0
    4652:	d002      	beq.n	465a <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    4654:	9801      	ldr	r0, [sp, #4]
    4656:	f000 f951 	bl	48fc <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    465a:	bf00      	nop
    465c:	b003      	add	sp, #12
    465e:	f85d fb04 	ldr.w	pc, [sp], #4

00004662 <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    4662:	b500      	push	{lr}
    4664:	b083      	sub	sp, #12
    4666:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4668:	9b01      	ldr	r3, [sp, #4]
    466a:	2b00      	cmp	r3, #0
    466c:	d002      	beq.n	4674 <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    466e:	9801      	ldr	r0, [sp, #4]
    4670:	f000 f95e 	bl	4930 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4674:	bf00      	nop
    4676:	b003      	add	sp, #12
    4678:	f85d fb04 	ldr.w	pc, [sp], #4

0000467c <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    467c:	b500      	push	{lr}
    467e:	b083      	sub	sp, #12
    4680:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4682:	9b01      	ldr	r3, [sp, #4]
    4684:	2b00      	cmp	r3, #0
    4686:	d002      	beq.n	468e <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    4688:	9801      	ldr	r0, [sp, #4]
    468a:	f000 f98b 	bl	49a4 <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    468e:	bf00      	nop
    4690:	b003      	add	sp, #12
    4692:	f85d fb04 	ldr.w	pc, [sp], #4

00004696 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    4696:	b086      	sub	sp, #24
    4698:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    469a:	9b01      	ldr	r3, [sp, #4]
    469c:	681a      	ldr	r2, [r3, #0]
    469e:	4911      	ldr	r1, [pc, #68]	; (46e4 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    46a0:	4613      	mov	r3, r2
    46a2:	00db      	lsls	r3, r3, #3
    46a4:	4413      	add	r3, r2
    46a6:	440b      	add	r3, r1
    46a8:	781b      	ldrb	r3, [r3, #0]
    46aa:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    46ac:	9b01      	ldr	r3, [sp, #4]
    46ae:	685b      	ldr	r3, [r3, #4]
    46b0:	4a0d      	ldr	r2, [pc, #52]	; (46e8 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    46b2:	5cd3      	ldrb	r3, [r2, r3]
    46b4:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    46b6:	4a0d      	ldr	r2, [pc, #52]	; (46ec <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    46b8:	9b05      	ldr	r3, [sp, #20]
    46ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    46be:	681b      	ldr	r3, [r3, #0]
    46c0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    46c2:	9b03      	ldr	r3, [sp, #12]
    46c4:	f023 0307 	bic.w	r3, r3, #7
    46c8:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    46ca:	9a03      	ldr	r2, [sp, #12]
    46cc:	9b04      	ldr	r3, [sp, #16]
    46ce:	4313      	orrs	r3, r2
    46d0:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    46d2:	4a06      	ldr	r2, [pc, #24]	; (46ec <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    46d4:	9b05      	ldr	r3, [sp, #20]
    46d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    46da:	9a03      	ldr	r2, [sp, #12]
    46dc:	601a      	str	r2, [r3, #0]
}
    46de:	bf00      	nop
    46e0:	b006      	add	sp, #24
    46e2:	4770      	bx	lr
    46e4:	0000a6f0 	.word	0x0000a6f0
    46e8:	0000aae8 	.word	0x0000aae8
    46ec:	0000ab2c 	.word	0x0000ab2c

000046f0 <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    46f0:	b086      	sub	sp, #24
    46f2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    46f4:	9b01      	ldr	r3, [sp, #4]
    46f6:	681a      	ldr	r2, [r3, #0]
    46f8:	4911      	ldr	r1, [pc, #68]	; (4740 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    46fa:	4613      	mov	r3, r2
    46fc:	00db      	lsls	r3, r3, #3
    46fe:	4413      	add	r3, r2
    4700:	440b      	add	r3, r1
    4702:	781b      	ldrb	r3, [r3, #0]
    4704:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    4706:	9b01      	ldr	r3, [sp, #4]
    4708:	685b      	ldr	r3, [r3, #4]
    470a:	4a0e      	ldr	r2, [pc, #56]	; (4744 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    470c:	5cd3      	ldrb	r3, [r2, r3]
    470e:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    4710:	4a0d      	ldr	r2, [pc, #52]	; (4748 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    4712:	9b05      	ldr	r3, [sp, #20]
    4714:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4718:	681b      	ldr	r3, [r3, #0]
    471a:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    471c:	9b03      	ldr	r3, [sp, #12]
    471e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    4722:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    4724:	9b04      	ldr	r3, [sp, #16]
    4726:	021b      	lsls	r3, r3, #8
    4728:	9a03      	ldr	r2, [sp, #12]
    472a:	4313      	orrs	r3, r2
    472c:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    472e:	4a06      	ldr	r2, [pc, #24]	; (4748 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    4730:	9b05      	ldr	r3, [sp, #20]
    4732:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4736:	9a03      	ldr	r2, [sp, #12]
    4738:	601a      	str	r2, [r3, #0]
}
    473a:	bf00      	nop
    473c:	b006      	add	sp, #24
    473e:	4770      	bx	lr
    4740:	0000a6f0 	.word	0x0000a6f0
    4744:	0000aae8 	.word	0x0000aae8
    4748:	0000ab2c 	.word	0x0000ab2c

0000474c <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    474c:	b084      	sub	sp, #16
    474e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    4750:	4b09      	ldr	r3, [pc, #36]	; (4778 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    4752:	695b      	ldr	r3, [r3, #20]
    4754:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    4756:	9b03      	ldr	r3, [sp, #12]
    4758:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    475c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    475e:	9b01      	ldr	r3, [sp, #4]
    4760:	685b      	ldr	r3, [r3, #4]
    4762:	3b01      	subs	r3, #1
    4764:	041b      	lsls	r3, r3, #16
    4766:	9a03      	ldr	r2, [sp, #12]
    4768:	4313      	orrs	r3, r2
    476a:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    476c:	4a02      	ldr	r2, [pc, #8]	; (4778 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    476e:	9b03      	ldr	r3, [sp, #12]
    4770:	6153      	str	r3, [r2, #20]
}
    4772:	bf00      	nop
    4774:	b004      	add	sp, #16
    4776:	4770      	bx	lr
    4778:	40064000 	.word	0x40064000

0000477c <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    477c:	b084      	sub	sp, #16
    477e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    4780:	4b09      	ldr	r3, [pc, #36]	; (47a8 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    4782:	695b      	ldr	r3, [r3, #20]
    4784:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    4786:	9b03      	ldr	r3, [sp, #12]
    4788:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    478c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    478e:	9b01      	ldr	r3, [sp, #4]
    4790:	685b      	ldr	r3, [r3, #4]
    4792:	3b01      	subs	r3, #1
    4794:	011b      	lsls	r3, r3, #4
    4796:	9a03      	ldr	r2, [sp, #12]
    4798:	4313      	orrs	r3, r2
    479a:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    479c:	4a02      	ldr	r2, [pc, #8]	; (47a8 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    479e:	9b03      	ldr	r3, [sp, #12]
    47a0:	6153      	str	r3, [r2, #20]
}
    47a2:	bf00      	nop
    47a4:	b004      	add	sp, #16
    47a6:	4770      	bx	lr
    47a8:	40064000 	.word	0x40064000

000047ac <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    47ac:	b084      	sub	sp, #16
    47ae:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    47b0:	4b09      	ldr	r3, [pc, #36]	; (47d8 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    47b2:	695b      	ldr	r3, [r3, #20]
    47b4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    47b6:	9b03      	ldr	r3, [sp, #12]
    47b8:	f023 030f 	bic.w	r3, r3, #15
    47bc:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    47be:	9b01      	ldr	r3, [sp, #4]
    47c0:	685b      	ldr	r3, [r3, #4]
    47c2:	3b01      	subs	r3, #1
    47c4:	9a03      	ldr	r2, [sp, #12]
    47c6:	4313      	orrs	r3, r2
    47c8:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    47ca:	4a03      	ldr	r2, [pc, #12]	; (47d8 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    47cc:	9b03      	ldr	r3, [sp, #12]
    47ce:	6153      	str	r3, [r2, #20]
}
    47d0:	bf00      	nop
    47d2:	b004      	add	sp, #16
    47d4:	4770      	bx	lr
    47d6:	bf00      	nop
    47d8:	40064000 	.word	0x40064000

000047dc <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    47dc:	b084      	sub	sp, #16
    47de:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    47e0:	4b09      	ldr	r3, [pc, #36]	; (4808 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    47e2:	699b      	ldr	r3, [r3, #24]
    47e4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    47e6:	9b03      	ldr	r3, [sp, #12]
    47e8:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    47ec:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    47ee:	9b01      	ldr	r3, [sp, #4]
    47f0:	685b      	ldr	r3, [r3, #4]
    47f2:	3b01      	subs	r3, #1
    47f4:	041b      	lsls	r3, r3, #16
    47f6:	9a03      	ldr	r2, [sp, #12]
    47f8:	4313      	orrs	r3, r2
    47fa:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    47fc:	4a02      	ldr	r2, [pc, #8]	; (4808 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    47fe:	9b03      	ldr	r3, [sp, #12]
    4800:	6193      	str	r3, [r2, #24]
}
    4802:	bf00      	nop
    4804:	b004      	add	sp, #16
    4806:	4770      	bx	lr
    4808:	40064000 	.word	0x40064000

0000480c <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    480c:	b084      	sub	sp, #16
    480e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    4810:	4b09      	ldr	r3, [pc, #36]	; (4838 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    4812:	699b      	ldr	r3, [r3, #24]
    4814:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    4816:	9b03      	ldr	r3, [sp, #12]
    4818:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    481c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    481e:	9b01      	ldr	r3, [sp, #4]
    4820:	685b      	ldr	r3, [r3, #4]
    4822:	3b01      	subs	r3, #1
    4824:	011b      	lsls	r3, r3, #4
    4826:	9a03      	ldr	r2, [sp, #12]
    4828:	4313      	orrs	r3, r2
    482a:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    482c:	4a02      	ldr	r2, [pc, #8]	; (4838 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    482e:	9b03      	ldr	r3, [sp, #12]
    4830:	6193      	str	r3, [r2, #24]
}
    4832:	bf00      	nop
    4834:	b004      	add	sp, #16
    4836:	4770      	bx	lr
    4838:	40064000 	.word	0x40064000

0000483c <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    483c:	b084      	sub	sp, #16
    483e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    4840:	4b09      	ldr	r3, [pc, #36]	; (4868 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    4842:	699b      	ldr	r3, [r3, #24]
    4844:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    4846:	9b03      	ldr	r3, [sp, #12]
    4848:	f023 030f 	bic.w	r3, r3, #15
    484c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    484e:	9b01      	ldr	r3, [sp, #4]
    4850:	685b      	ldr	r3, [r3, #4]
    4852:	3b01      	subs	r3, #1
    4854:	9a03      	ldr	r2, [sp, #12]
    4856:	4313      	orrs	r3, r2
    4858:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    485a:	4a03      	ldr	r2, [pc, #12]	; (4868 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    485c:	9b03      	ldr	r3, [sp, #12]
    485e:	6193      	str	r3, [r2, #24]
}
    4860:	bf00      	nop
    4862:	b004      	add	sp, #16
    4864:	4770      	bx	lr
    4866:	bf00      	nop
    4868:	40064000 	.word	0x40064000

0000486c <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    486c:	b084      	sub	sp, #16
    486e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    4870:	4b09      	ldr	r3, [pc, #36]	; (4898 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    4872:	69db      	ldr	r3, [r3, #28]
    4874:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    4876:	9b03      	ldr	r3, [sp, #12]
    4878:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    487c:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    487e:	9b01      	ldr	r3, [sp, #4]
    4880:	685b      	ldr	r3, [r3, #4]
    4882:	3b01      	subs	r3, #1
    4884:	041b      	lsls	r3, r3, #16
    4886:	9a03      	ldr	r2, [sp, #12]
    4888:	4313      	orrs	r3, r2
    488a:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    488c:	4a02      	ldr	r2, [pc, #8]	; (4898 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    488e:	9b03      	ldr	r3, [sp, #12]
    4890:	61d3      	str	r3, [r2, #28]
}
    4892:	bf00      	nop
    4894:	b004      	add	sp, #16
    4896:	4770      	bx	lr
    4898:	40064000 	.word	0x40064000

0000489c <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    489c:	b084      	sub	sp, #16
    489e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    48a0:	4b09      	ldr	r3, [pc, #36]	; (48c8 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    48a2:	69db      	ldr	r3, [r3, #28]
    48a4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    48a6:	9b03      	ldr	r3, [sp, #12]
    48a8:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    48ac:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    48ae:	9b01      	ldr	r3, [sp, #4]
    48b0:	685b      	ldr	r3, [r3, #4]
    48b2:	3b01      	subs	r3, #1
    48b4:	011b      	lsls	r3, r3, #4
    48b6:	9a03      	ldr	r2, [sp, #12]
    48b8:	4313      	orrs	r3, r2
    48ba:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    48bc:	4a02      	ldr	r2, [pc, #8]	; (48c8 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    48be:	9b03      	ldr	r3, [sp, #12]
    48c0:	61d3      	str	r3, [r2, #28]
}
    48c2:	bf00      	nop
    48c4:	b004      	add	sp, #16
    48c6:	4770      	bx	lr
    48c8:	40064000 	.word	0x40064000

000048cc <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    48cc:	b084      	sub	sp, #16
    48ce:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    48d0:	4b09      	ldr	r3, [pc, #36]	; (48f8 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    48d2:	69db      	ldr	r3, [r3, #28]
    48d4:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    48d6:	9b03      	ldr	r3, [sp, #12]
    48d8:	f023 030f 	bic.w	r3, r3, #15
    48dc:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    48de:	9b01      	ldr	r3, [sp, #4]
    48e0:	685b      	ldr	r3, [r3, #4]
    48e2:	3b01      	subs	r3, #1
    48e4:	9a03      	ldr	r2, [sp, #12]
    48e6:	4313      	orrs	r3, r2
    48e8:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    48ea:	4a03      	ldr	r2, [pc, #12]	; (48f8 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    48ec:	9b03      	ldr	r3, [sp, #12]
    48ee:	61d3      	str	r3, [r2, #28]
}
    48f0:	bf00      	nop
    48f2:	b004      	add	sp, #16
    48f4:	4770      	bx	lr
    48f6:	bf00      	nop
    48f8:	40064000 	.word	0x40064000

000048fc <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    48fc:	b084      	sub	sp, #16
    48fe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    4900:	4b0a      	ldr	r3, [pc, #40]	; (492c <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    4902:	685b      	ldr	r3, [r3, #4]
    4904:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    4906:	9b03      	ldr	r3, [sp, #12]
    4908:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    490c:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    490e:	9b01      	ldr	r3, [sp, #4]
    4910:	685b      	ldr	r3, [r3, #4]
    4912:	3b01      	subs	r3, #1
    4914:	021b      	lsls	r3, r3, #8
    4916:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    491a:	9a03      	ldr	r2, [sp, #12]
    491c:	4313      	orrs	r3, r2
    491e:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    4920:	4a02      	ldr	r2, [pc, #8]	; (492c <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    4922:	9b03      	ldr	r3, [sp, #12]
    4924:	6053      	str	r3, [r2, #4]
}
    4926:	bf00      	nop
    4928:	b004      	add	sp, #16
    492a:	4770      	bx	lr
    492c:	40048000 	.word	0x40048000

00004930 <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    4930:	b084      	sub	sp, #16
    4932:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    4934:	4919      	ldr	r1, [pc, #100]	; (499c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    4936:	9b01      	ldr	r3, [sp, #4]
    4938:	681a      	ldr	r2, [r3, #0]
    493a:	4819      	ldr	r0, [pc, #100]	; (49a0 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    493c:	4613      	mov	r3, r2
    493e:	00db      	lsls	r3, r3, #3
    4940:	4413      	add	r3, r2
    4942:	4403      	add	r3, r0
    4944:	3305      	adds	r3, #5
    4946:	781b      	ldrb	r3, [r3, #0]
    4948:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    494c:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    494e:	9b03      	ldr	r3, [sp, #12]
    4950:	f023 030f 	bic.w	r3, r3, #15
    4954:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    4956:	9b01      	ldr	r3, [sp, #4]
    4958:	685b      	ldr	r3, [r3, #4]
    495a:	3b01      	subs	r3, #1
    495c:	f003 0307 	and.w	r3, r3, #7
    4960:	9a03      	ldr	r2, [sp, #12]
    4962:	4313      	orrs	r3, r2
    4964:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    4966:	9b01      	ldr	r3, [sp, #4]
    4968:	7a1b      	ldrb	r3, [r3, #8]
    496a:	3b01      	subs	r3, #1
    496c:	00db      	lsls	r3, r3, #3
    496e:	f003 0308 	and.w	r3, r3, #8
    4972:	9a03      	ldr	r2, [sp, #12]
    4974:	4313      	orrs	r3, r2
    4976:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    4978:	4908      	ldr	r1, [pc, #32]	; (499c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    497a:	9b01      	ldr	r3, [sp, #4]
    497c:	681a      	ldr	r2, [r3, #0]
    497e:	4808      	ldr	r0, [pc, #32]	; (49a0 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    4980:	4613      	mov	r3, r2
    4982:	00db      	lsls	r3, r3, #3
    4984:	4413      	add	r3, r2
    4986:	4403      	add	r3, r0
    4988:	3305      	adds	r3, #5
    498a:	781b      	ldrb	r3, [r3, #0]
    498c:	461a      	mov	r2, r3
    498e:	9b03      	ldr	r3, [sp, #12]
    4990:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    4994:	bf00      	nop
    4996:	b004      	add	sp, #16
    4998:	4770      	bx	lr
    499a:	bf00      	nop
    499c:	40065000 	.word	0x40065000
    49a0:	0000a6f0 	.word	0x0000a6f0

000049a4 <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    49a4:	b084      	sub	sp, #16
    49a6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    49a8:	4b10      	ldr	r3, [pc, #64]	; (49ec <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    49aa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    49ac:	4a0f      	ldr	r2, [pc, #60]	; (49ec <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    49ae:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    49b2:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    49b4:	4b0d      	ldr	r3, [pc, #52]	; (49ec <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    49b6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    49b8:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    49ba:	9b03      	ldr	r3, [sp, #12]
    49bc:	f023 030f 	bic.w	r3, r3, #15
    49c0:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    49c2:	9b01      	ldr	r3, [sp, #4]
    49c4:	685b      	ldr	r3, [r3, #4]
    49c6:	3b01      	subs	r3, #1
    49c8:	005b      	lsls	r3, r3, #1
    49ca:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    49ce:	9b01      	ldr	r3, [sp, #4]
    49d0:	7a1b      	ldrb	r3, [r3, #8]
    49d2:	3b01      	subs	r3, #1
    49d4:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    49d8:	4313      	orrs	r3, r2
    49da:	9a03      	ldr	r2, [sp, #12]
    49dc:	4313      	orrs	r3, r2
    49de:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    49e0:	4a02      	ldr	r2, [pc, #8]	; (49ec <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    49e2:	9b03      	ldr	r3, [sp, #12]
    49e4:	6693      	str	r3, [r2, #104]	; 0x68
}
    49e6:	bf00      	nop
    49e8:	b004      	add	sp, #16
    49ea:	4770      	bx	lr
    49ec:	40048000 	.word	0x40048000

000049f0 <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    49f0:	b500      	push	{lr}
    49f2:	b083      	sub	sp, #12
    49f4:	9001      	str	r0, [sp, #4]
    49f6:	460b      	mov	r3, r1
    49f8:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    49fc:	4b05      	ldr	r3, [pc, #20]	; (4a14 <Power_Ip_ReportPowerErrors+0x24>)
    49fe:	681b      	ldr	r3, [r3, #0]
    4a00:	f89d 2003 	ldrb.w	r2, [sp, #3]
    4a04:	4611      	mov	r1, r2
    4a06:	9801      	ldr	r0, [sp, #4]
    4a08:	4798      	blx	r3
}
    4a0a:	bf00      	nop
    4a0c:	b003      	add	sp, #12
    4a0e:	f85d fb04 	ldr.w	pc, [sp], #4
    4a12:	bf00      	nop
    4a14:	1fff8b14 	.word	0x1fff8b14

00004a18 <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    4a18:	b082      	sub	sp, #8
    4a1a:	9001      	str	r0, [sp, #4]
    4a1c:	460b      	mov	r3, r1
    4a1e:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    4a22:	bf00      	nop
    4a24:	b002      	add	sp, #8
    4a26:	4770      	bx	lr

00004a28 <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    4a28:	b500      	push	{lr}
    4a2a:	b085      	sub	sp, #20
    4a2c:	9003      	str	r0, [sp, #12]
    4a2e:	9102      	str	r1, [sp, #8]
    4a30:	9201      	str	r2, [sp, #4]
    4a32:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    4a34:	2000      	movs	r0, #0
    4a36:	f7fc f9a0 	bl	d7a <OsIf_GetCounter>
    4a3a:	4602      	mov	r2, r0
    4a3c:	9b03      	ldr	r3, [sp, #12]
    4a3e:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    4a40:	9b02      	ldr	r3, [sp, #8]
    4a42:	2200      	movs	r2, #0
    4a44:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    4a46:	2100      	movs	r1, #0
    4a48:	9800      	ldr	r0, [sp, #0]
    4a4a:	f7fc f9e2 	bl	e12 <OsIf_MicrosToTicks>
    4a4e:	4602      	mov	r2, r0
    4a50:	9b01      	ldr	r3, [sp, #4]
    4a52:	601a      	str	r2, [r3, #0]
}
    4a54:	bf00      	nop
    4a56:	b005      	add	sp, #20
    4a58:	f85d fb04 	ldr.w	pc, [sp], #4

00004a5c <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    4a5c:	b500      	push	{lr}
    4a5e:	b087      	sub	sp, #28
    4a60:	9003      	str	r0, [sp, #12]
    4a62:	9102      	str	r1, [sp, #8]
    4a64:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    4a66:	2300      	movs	r3, #0
    4a68:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    4a6c:	2100      	movs	r1, #0
    4a6e:	9803      	ldr	r0, [sp, #12]
    4a70:	f7fc f99c 	bl	dac <OsIf_GetElapsed>
    4a74:	4602      	mov	r2, r0
    4a76:	9b02      	ldr	r3, [sp, #8]
    4a78:	681b      	ldr	r3, [r3, #0]
    4a7a:	441a      	add	r2, r3
    4a7c:	9b02      	ldr	r3, [sp, #8]
    4a7e:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    4a80:	9b02      	ldr	r3, [sp, #8]
    4a82:	681b      	ldr	r3, [r3, #0]
    4a84:	9a01      	ldr	r2, [sp, #4]
    4a86:	429a      	cmp	r2, r3
    4a88:	d802      	bhi.n	4a90 <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    4a8a:	2301      	movs	r3, #1
    4a8c:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    4a90:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    4a94:	4618      	mov	r0, r3
    4a96:	b007      	add	sp, #28
    4a98:	f85d fb04 	ldr.w	pc, [sp], #4

00004a9c <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    4a9c:	b082      	sub	sp, #8
    4a9e:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    4aa0:	9b01      	ldr	r3, [sp, #4]
    4aa2:	681b      	ldr	r3, [r3, #0]
    4aa4:	4a03      	ldr	r2, [pc, #12]	; (4ab4 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    4aa6:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    4aaa:	6093      	str	r3, [r2, #8]
}
    4aac:	bf00      	nop
    4aae:	b002      	add	sp, #8
    4ab0:	4770      	bx	lr
    4ab2:	bf00      	nop
    4ab4:	4007e000 	.word	0x4007e000

00004ab8 <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    4ab8:	b084      	sub	sp, #16
    4aba:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    4abc:	2301      	movs	r3, #1
    4abe:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    4ac0:	4b15      	ldr	r3, [pc, #84]	; (4b18 <Power_Ip_SMC_ModeCheckEntry+0x60>)
    4ac2:	695b      	ldr	r3, [r3, #20]
    4ac4:	b2db      	uxtb	r3, r3
    4ac6:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    4ac8:	9b01      	ldr	r3, [sp, #4]
    4aca:	2b02      	cmp	r3, #2
    4acc:	d012      	beq.n	4af4 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    4ace:	9b01      	ldr	r3, [sp, #4]
    4ad0:	2b02      	cmp	r3, #2
    4ad2:	d818      	bhi.n	4b06 <Power_Ip_SMC_ModeCheckEntry+0x4e>
    4ad4:	9b01      	ldr	r3, [sp, #4]
    4ad6:	2b00      	cmp	r3, #0
    4ad8:	d003      	beq.n	4ae2 <Power_Ip_SMC_ModeCheckEntry+0x2a>
    4ada:	9b01      	ldr	r3, [sp, #4]
    4adc:	2b01      	cmp	r3, #1
    4ade:	d003      	beq.n	4ae8 <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    4ae0:	e011      	b.n	4b06 <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    4ae2:	2300      	movs	r3, #0
    4ae4:	9303      	str	r3, [sp, #12]
            break;
    4ae6:	e013      	b.n	4b10 <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    4ae8:	9b02      	ldr	r3, [sp, #8]
    4aea:	2b01      	cmp	r3, #1
    4aec:	d10d      	bne.n	4b0a <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    4aee:	2300      	movs	r3, #0
    4af0:	9303      	str	r3, [sp, #12]
            break;
    4af2:	e00a      	b.n	4b0a <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    4af4:	9b02      	ldr	r3, [sp, #8]
    4af6:	2b01      	cmp	r3, #1
    4af8:	d002      	beq.n	4b00 <Power_Ip_SMC_ModeCheckEntry+0x48>
    4afa:	9b02      	ldr	r3, [sp, #8]
    4afc:	2b10      	cmp	r3, #16
    4afe:	d106      	bne.n	4b0e <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    4b00:	2300      	movs	r3, #0
    4b02:	9303      	str	r3, [sp, #12]
            break;
    4b04:	e003      	b.n	4b0e <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    4b06:	bf00      	nop
    4b08:	e002      	b.n	4b10 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    4b0a:	bf00      	nop
    4b0c:	e000      	b.n	4b10 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    4b0e:	bf00      	nop
        }
    }

    return PowerModeCheck;
    4b10:	9b03      	ldr	r3, [sp, #12]
}
    4b12:	4618      	mov	r0, r3
    4b14:	b004      	add	sp, #16
    4b16:	4770      	bx	lr
    4b18:	4007e000 	.word	0x4007e000

00004b1c <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    4b1c:	b500      	push	{lr}
    4b1e:	b08b      	sub	sp, #44	; 0x2c
    4b20:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    4b22:	2300      	movs	r3, #0
    4b24:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    4b26:	2300      	movs	r3, #0
    4b28:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    4b2a:	2300      	movs	r3, #0
    4b2c:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    4b30:	9b01      	ldr	r3, [sp, #4]
    4b32:	685b      	ldr	r3, [r3, #4]
    4b34:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    4b36:	9b08      	ldr	r3, [sp, #32]
    4b38:	2b02      	cmp	r3, #2
    4b3a:	d076      	beq.n	4c2a <Power_Ip_SMC_ModeConfig+0x10e>
    4b3c:	9b08      	ldr	r3, [sp, #32]
    4b3e:	2b02      	cmp	r3, #2
    4b40:	f200 80ab 	bhi.w	4c9a <Power_Ip_SMC_ModeConfig+0x17e>
    4b44:	9b08      	ldr	r3, [sp, #32]
    4b46:	2b00      	cmp	r3, #0
    4b48:	d003      	beq.n	4b52 <Power_Ip_SMC_ModeConfig+0x36>
    4b4a:	9b08      	ldr	r3, [sp, #32]
    4b4c:	2b01      	cmp	r3, #1
    4b4e:	d034      	beq.n	4bba <Power_Ip_SMC_ModeConfig+0x9e>
    4b50:	e0a3      	b.n	4c9a <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    4b52:	4b58      	ldr	r3, [pc, #352]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4b54:	68db      	ldr	r3, [r3, #12]
    4b56:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4b58:	9b06      	ldr	r3, [sp, #24]
    4b5a:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4b5e:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    4b60:	4a54      	ldr	r2, [pc, #336]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4b62:	9b06      	ldr	r3, [sp, #24]
    4b64:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4b66:	aa02      	add	r2, sp, #8
    4b68:	a903      	add	r1, sp, #12
    4b6a:	a804      	add	r0, sp, #16
    4b6c:	f24c 3350 	movw	r3, #50000	; 0xc350
    4b70:	f7ff ff5a 	bl	4a28 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4b74:	9a02      	ldr	r2, [sp, #8]
    4b76:	a903      	add	r1, sp, #12
    4b78:	ab04      	add	r3, sp, #16
    4b7a:	4618      	mov	r0, r3
    4b7c:	f7ff ff6e 	bl	4a5c <Power_Ip_TimeoutExpired>
    4b80:	4603      	mov	r3, r0
    4b82:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    4b86:	4b4b      	ldr	r3, [pc, #300]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4b88:	695b      	ldr	r3, [r3, #20]
    4b8a:	f003 0301 	and.w	r3, r3, #1
    4b8e:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4b90:	9b05      	ldr	r3, [sp, #20]
    4b92:	2b01      	cmp	r3, #1
    4b94:	d006      	beq.n	4ba4 <Power_Ip_SMC_ModeConfig+0x88>
    4b96:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4b9a:	f083 0301 	eor.w	r3, r3, #1
    4b9e:	b2db      	uxtb	r3, r3
    4ba0:	2b00      	cmp	r3, #0
    4ba2:	d1e7      	bne.n	4b74 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    4ba4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4ba8:	2b00      	cmp	r3, #0
    4baa:	d079      	beq.n	4ca0 <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4bac:	2301      	movs	r3, #1
    4bae:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4bb0:	21ff      	movs	r1, #255	; 0xff
    4bb2:	2000      	movs	r0, #0
    4bb4:	f7ff ff1c 	bl	49f0 <Power_Ip_ReportPowerErrors>
            }

            break;
    4bb8:	e072      	b.n	4ca0 <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    4bba:	4b3e      	ldr	r3, [pc, #248]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4bbc:	68db      	ldr	r3, [r3, #12]
    4bbe:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4bc0:	9b06      	ldr	r3, [sp, #24]
    4bc2:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4bc6:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    4bc8:	9b06      	ldr	r3, [sp, #24]
    4bca:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    4bce:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    4bd0:	4a38      	ldr	r2, [pc, #224]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4bd2:	9b06      	ldr	r3, [sp, #24]
    4bd4:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4bd6:	aa02      	add	r2, sp, #8
    4bd8:	a903      	add	r1, sp, #12
    4bda:	a804      	add	r0, sp, #16
    4bdc:	f24c 3350 	movw	r3, #50000	; 0xc350
    4be0:	f7ff ff22 	bl	4a28 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4be4:	9a02      	ldr	r2, [sp, #8]
    4be6:	a903      	add	r1, sp, #12
    4be8:	ab04      	add	r3, sp, #16
    4bea:	4618      	mov	r0, r3
    4bec:	f7ff ff36 	bl	4a5c <Power_Ip_TimeoutExpired>
    4bf0:	4603      	mov	r3, r0
    4bf2:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    4bf6:	4b2f      	ldr	r3, [pc, #188]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4bf8:	695b      	ldr	r3, [r3, #20]
    4bfa:	f003 0380 	and.w	r3, r3, #128	; 0x80
    4bfe:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4c00:	9b05      	ldr	r3, [sp, #20]
    4c02:	2b80      	cmp	r3, #128	; 0x80
    4c04:	d006      	beq.n	4c14 <Power_Ip_SMC_ModeConfig+0xf8>
    4c06:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4c0a:	f083 0301 	eor.w	r3, r3, #1
    4c0e:	b2db      	uxtb	r3, r3
    4c10:	2b00      	cmp	r3, #0
    4c12:	d1e7      	bne.n	4be4 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    4c14:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4c18:	2b00      	cmp	r3, #0
    4c1a:	d043      	beq.n	4ca4 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4c1c:	2301      	movs	r3, #1
    4c1e:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4c20:	21ff      	movs	r1, #255	; 0xff
    4c22:	2000      	movs	r0, #0
    4c24:	f7ff fee4 	bl	49f0 <Power_Ip_ReportPowerErrors>
            }

            break;
    4c28:	e03c      	b.n	4ca4 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    4c2a:	4b22      	ldr	r3, [pc, #136]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4c2c:	68db      	ldr	r3, [r3, #12]
    4c2e:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    4c30:	9b06      	ldr	r3, [sp, #24]
    4c32:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    4c36:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    4c38:	9b06      	ldr	r3, [sp, #24]
    4c3a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    4c3e:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    4c40:	4a1c      	ldr	r2, [pc, #112]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4c42:	9b06      	ldr	r3, [sp, #24]
    4c44:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    4c46:	aa02      	add	r2, sp, #8
    4c48:	a903      	add	r1, sp, #12
    4c4a:	a804      	add	r0, sp, #16
    4c4c:	f24c 3350 	movw	r3, #50000	; 0xc350
    4c50:	f7ff feea 	bl	4a28 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4c54:	9a02      	ldr	r2, [sp, #8]
    4c56:	a903      	add	r1, sp, #12
    4c58:	ab04      	add	r3, sp, #16
    4c5a:	4618      	mov	r0, r3
    4c5c:	f7ff fefe 	bl	4a5c <Power_Ip_TimeoutExpired>
    4c60:	4603      	mov	r3, r0
    4c62:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    4c66:	4b13      	ldr	r3, [pc, #76]	; (4cb4 <Power_Ip_SMC_ModeConfig+0x198>)
    4c68:	695b      	ldr	r3, [r3, #20]
    4c6a:	f003 0304 	and.w	r3, r3, #4
    4c6e:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    4c70:	9b05      	ldr	r3, [sp, #20]
    4c72:	2b04      	cmp	r3, #4
    4c74:	d006      	beq.n	4c84 <Power_Ip_SMC_ModeConfig+0x168>
    4c76:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4c7a:	f083 0301 	eor.w	r3, r3, #1
    4c7e:	b2db      	uxtb	r3, r3
    4c80:	2b00      	cmp	r3, #0
    4c82:	d1e7      	bne.n	4c54 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    4c84:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4c88:	2b00      	cmp	r3, #0
    4c8a:	d00d      	beq.n	4ca8 <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4c8c:	2301      	movs	r3, #1
    4c8e:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    4c90:	21ff      	movs	r1, #255	; 0xff
    4c92:	2000      	movs	r0, #0
    4c94:	f7ff feac 	bl	49f0 <Power_Ip_ReportPowerErrors>
            }

            break;
    4c98:	e006      	b.n	4ca8 <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    4c9a:	2301      	movs	r3, #1
    4c9c:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    4c9e:	e004      	b.n	4caa <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4ca0:	bf00      	nop
    4ca2:	e002      	b.n	4caa <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4ca4:	bf00      	nop
    4ca6:	e000      	b.n	4caa <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    4ca8:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    4caa:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    4cac:	4618      	mov	r0, r3
    4cae:	b00b      	add	sp, #44	; 0x2c
    4cb0:	f85d fb04 	ldr.w	pc, [sp], #4
    4cb4:	4007e000 	.word	0x4007e000

00004cb8 <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    4cb8:	b082      	sub	sp, #8
    4cba:	9001      	str	r0, [sp, #4]
    4cbc:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    4cbe:	bf00      	nop
    4cc0:	b002      	add	sp, #8
    4cc2:	4770      	bx	lr

00004cc4 <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    4cc4:	b082      	sub	sp, #8
    4cc6:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4cc8:	bf00      	nop
    4cca:	b002      	add	sp, #8
    4ccc:	4770      	bx	lr

00004cce <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    4cce:	b082      	sub	sp, #8
    4cd0:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    4cd2:	2302      	movs	r3, #2
}
    4cd4:	4618      	mov	r0, r3
    4cd6:	b002      	add	sp, #8
    4cd8:	4770      	bx	lr

00004cda <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    4cda:	b082      	sub	sp, #8
    4cdc:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    4cde:	bf00      	nop
    4ce0:	b002      	add	sp, #8
    4ce2:	4770      	bx	lr

00004ce4 <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    4ce4:	b500      	push	{lr}
    4ce6:	b083      	sub	sp, #12
    4ce8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4cea:	9b01      	ldr	r3, [sp, #4]
    4cec:	2b00      	cmp	r3, #0
    4cee:	d002      	beq.n	4cf6 <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    4cf0:	9801      	ldr	r0, [sp, #4]
    4cf2:	f000 f870 	bl	4dd6 <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4cf6:	bf00      	nop
    4cf8:	b003      	add	sp, #12
    4cfa:	f85d fb04 	ldr.w	pc, [sp], #4

00004cfe <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    4cfe:	b500      	push	{lr}
    4d00:	b083      	sub	sp, #12
    4d02:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4d04:	9b01      	ldr	r3, [sp, #4]
    4d06:	2b00      	cmp	r3, #0
    4d08:	d002      	beq.n	4d10 <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    4d0a:	9801      	ldr	r0, [sp, #4]
    4d0c:	f000 f89a 	bl	4e44 <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4d10:	bf00      	nop
    4d12:	b003      	add	sp, #12
    4d14:	f85d fb04 	ldr.w	pc, [sp], #4

00004d18 <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    4d18:	b500      	push	{lr}
    4d1a:	b089      	sub	sp, #36	; 0x24
    4d1c:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    4d1e:	2301      	movs	r3, #1
    4d20:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    4d22:	2300      	movs	r3, #0
    4d24:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    4d28:	4b1e      	ldr	r3, [pc, #120]	; (4da4 <Clock_Ip_CompleteSpll+0x8c>)
    4d2a:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4d2e:	f003 0301 	and.w	r3, r3, #1
    4d32:	2b00      	cmp	r3, #0
    4d34:	d02f      	beq.n	4d96 <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4d36:	aa02      	add	r2, sp, #8
    4d38:	a903      	add	r1, sp, #12
    4d3a:	a804      	add	r0, sp, #16
    4d3c:	f24c 3350 	movw	r3, #50000	; 0xc350
    4d40:	f7fe fc08 	bl	3554 <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    4d44:	4b17      	ldr	r3, [pc, #92]	; (4da4 <Clock_Ip_CompleteSpll+0x8c>)
    4d46:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4d4a:	0e1b      	lsrs	r3, r3, #24
    4d4c:	f003 0301 	and.w	r3, r3, #1
    4d50:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4d52:	9a02      	ldr	r2, [sp, #8]
    4d54:	a903      	add	r1, sp, #12
    4d56:	ab04      	add	r3, sp, #16
    4d58:	4618      	mov	r0, r3
    4d5a:	f7fe fc15 	bl	3588 <Clock_Ip_TimeoutExpired>
    4d5e:	4603      	mov	r3, r0
    4d60:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    4d64:	9b05      	ldr	r3, [sp, #20]
    4d66:	2b00      	cmp	r3, #0
    4d68:	d106      	bne.n	4d78 <Clock_Ip_CompleteSpll+0x60>
    4d6a:	f89d 301b 	ldrb.w	r3, [sp, #27]
    4d6e:	f083 0301 	eor.w	r3, r3, #1
    4d72:	b2db      	uxtb	r3, r3
    4d74:	2b00      	cmp	r3, #0
    4d76:	d1e5      	bne.n	4d44 <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    4d78:	f89d 301b 	ldrb.w	r3, [sp, #27]
    4d7c:	f083 0301 	eor.w	r3, r3, #1
    4d80:	b2db      	uxtb	r3, r3
    4d82:	2b00      	cmp	r3, #0
    4d84:	d002      	beq.n	4d8c <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    4d86:	2302      	movs	r3, #2
    4d88:	9307      	str	r3, [sp, #28]
    4d8a:	e006      	b.n	4d9a <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    4d8c:	9901      	ldr	r1, [sp, #4]
    4d8e:	2001      	movs	r0, #1
    4d90:	f7fe fbd0 	bl	3534 <Clock_Ip_ReportClockErrors>
    4d94:	e001      	b.n	4d9a <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    4d96:	2300      	movs	r3, #0
    4d98:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    4d9a:	9b07      	ldr	r3, [sp, #28]
}
    4d9c:	4618      	mov	r0, r3
    4d9e:	b009      	add	sp, #36	; 0x24
    4da0:	f85d fb04 	ldr.w	pc, [sp], #4
    4da4:	40064000 	.word	0x40064000

00004da8 <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    4da8:	b500      	push	{lr}
    4daa:	b083      	sub	sp, #12
    4dac:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    4dae:	9801      	ldr	r0, [sp, #4]
    4db0:	f000 f886 	bl	4ec0 <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    4db4:	bf00      	nop
    4db6:	b003      	add	sp, #12
    4db8:	f85d fb04 	ldr.w	pc, [sp], #4

00004dbc <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    4dbc:	b500      	push	{lr}
    4dbe:	b083      	sub	sp, #12
    4dc0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4dc2:	9b01      	ldr	r3, [sp, #4]
    4dc4:	2b00      	cmp	r3, #0
    4dc6:	d002      	beq.n	4dce <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    4dc8:	9801      	ldr	r0, [sp, #4]
    4dca:	f000 f891 	bl	4ef0 <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4dce:	bf00      	nop
    4dd0:	b003      	add	sp, #12
    4dd2:	f85d fb04 	ldr.w	pc, [sp], #4

00004dd6 <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4dd6:	b082      	sub	sp, #8
    4dd8:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    4dda:	4b19      	ldr	r3, [pc, #100]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4ddc:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4de0:	4a17      	ldr	r2, [pc, #92]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4de2:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4de6:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    4dea:	4b15      	ldr	r3, [pc, #84]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4dec:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4df0:	4a13      	ldr	r2, [pc, #76]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4df2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    4df6:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    4dfa:	4b11      	ldr	r3, [pc, #68]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4dfc:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4e00:	4a0f      	ldr	r2, [pc, #60]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4e02:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    4e06:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    4e0a:	4b0d      	ldr	r3, [pc, #52]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4e0c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4e10:	4a0b      	ldr	r2, [pc, #44]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4e12:	f023 0301 	bic.w	r3, r3, #1
    4e16:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    4e1a:	4b09      	ldr	r3, [pc, #36]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4e1c:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4e20:	4a07      	ldr	r2, [pc, #28]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4e22:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    4e26:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    4e2a:	4b05      	ldr	r3, [pc, #20]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4e2c:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4e30:	4a03      	ldr	r2, [pc, #12]	; (4e40 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4e32:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    4e36:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    4e3a:	bf00      	nop
    4e3c:	b002      	add	sp, #8
    4e3e:	4770      	bx	lr
    4e40:	40064000 	.word	0x40064000

00004e44 <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4e44:	b082      	sub	sp, #8
    4e46:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    4e48:	9b01      	ldr	r3, [sp, #4]
    4e4a:	889b      	ldrh	r3, [r3, #4]
    4e4c:	2b01      	cmp	r3, #1
    4e4e:	d12f      	bne.n	4eb0 <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    4e50:	4b1a      	ldr	r3, [pc, #104]	; (4ebc <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4e52:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    4e56:	9b01      	ldr	r3, [sp, #4]
    4e58:	7b5b      	ldrb	r3, [r3, #13]
    4e5a:	3b01      	subs	r3, #1
    4e5c:	021b      	lsls	r3, r3, #8
    4e5e:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    4e62:	9b01      	ldr	r3, [sp, #4]
    4e64:	7d1b      	ldrb	r3, [r3, #20]
    4e66:	3b10      	subs	r3, #16
    4e68:	041b      	lsls	r3, r3, #16
    4e6a:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    4e6e:	430b      	orrs	r3, r1
    4e70:	4912      	ldr	r1, [pc, #72]	; (4ebc <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4e72:	4313      	orrs	r3, r2
    4e74:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    4e78:	9b01      	ldr	r3, [sp, #4]
    4e7a:	7fdb      	ldrb	r3, [r3, #31]
    4e7c:	2b02      	cmp	r3, #2
    4e7e:	d011      	beq.n	4ea4 <Clock_Ip_SetSpll_TrustedCall+0x60>
    4e80:	2b02      	cmp	r3, #2
    4e82:	dc17      	bgt.n	4eb4 <Clock_Ip_SetSpll_TrustedCall+0x70>
    4e84:	2b00      	cmp	r3, #0
    4e86:	d002      	beq.n	4e8e <Clock_Ip_SetSpll_TrustedCall+0x4a>
    4e88:	2b01      	cmp	r3, #1
    4e8a:	d005      	beq.n	4e98 <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    4e8c:	e012      	b.n	4eb4 <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    4e8e:	4b0b      	ldr	r3, [pc, #44]	; (4ebc <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4e90:	2200      	movs	r2, #0
    4e92:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    4e96:	e00e      	b.n	4eb6 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    4e98:	4b08      	ldr	r3, [pc, #32]	; (4ebc <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4e9a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    4e9e:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    4ea2:	e008      	b.n	4eb6 <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    4ea4:	4b05      	ldr	r3, [pc, #20]	; (4ebc <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4ea6:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    4eaa:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    4eae:	e002      	b.n	4eb6 <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    4eb0:	bf00      	nop
    4eb2:	e000      	b.n	4eb6 <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    4eb4:	bf00      	nop
}
    4eb6:	bf00      	nop
    4eb8:	b002      	add	sp, #8
    4eba:	4770      	bx	lr
    4ebc:	40064000 	.word	0x40064000

00004ec0 <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    4ec0:	b082      	sub	sp, #8
    4ec2:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    4ec4:	4b09      	ldr	r3, [pc, #36]	; (4eec <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4ec6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4eca:	4a08      	ldr	r2, [pc, #32]	; (4eec <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4ecc:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4ed0:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    4ed4:	4b05      	ldr	r3, [pc, #20]	; (4eec <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4ed6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4eda:	4a04      	ldr	r2, [pc, #16]	; (4eec <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4edc:	f023 0301 	bic.w	r3, r3, #1
    4ee0:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    4ee4:	bf00      	nop
    4ee6:	b002      	add	sp, #8
    4ee8:	4770      	bx	lr
    4eea:	bf00      	nop
    4eec:	40064000 	.word	0x40064000

00004ef0 <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4ef0:	b082      	sub	sp, #8
    4ef2:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    4ef4:	9b01      	ldr	r3, [sp, #4]
    4ef6:	889b      	ldrh	r3, [r3, #4]
    4ef8:	2b01      	cmp	r3, #1
    4efa:	d107      	bne.n	4f0c <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    4efc:	4b05      	ldr	r3, [pc, #20]	; (4f14 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    4efe:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4f02:	4a04      	ldr	r2, [pc, #16]	; (4f14 <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    4f04:	f043 0301 	orr.w	r3, r3, #1
    4f08:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    4f0c:	bf00      	nop
    4f0e:	b002      	add	sp, #8
    4f10:	4770      	bx	lr
    4f12:	bf00      	nop
    4f14:	40064000 	.word	0x40064000

00004f18 <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    4f18:	b086      	sub	sp, #24
    4f1a:	9003      	str	r0, [sp, #12]
    4f1c:	9102      	str	r1, [sp, #8]
    4f1e:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    4f20:	23ff      	movs	r3, #255	; 0xff
    4f22:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    4f24:	9b03      	ldr	r3, [sp, #12]
    4f26:	4a39      	ldr	r2, [pc, #228]	; (500c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    4f28:	4293      	cmp	r3, r2
    4f2a:	d151      	bne.n	4fd0 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    4f2c:	9b02      	ldr	r3, [sp, #8]
    4f2e:	2b10      	cmp	r3, #16
    4f30:	d867      	bhi.n	5002 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    4f32:	a201      	add	r2, pc, #4	; (adr r2, 4f38 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    4f34:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    4f38:	00004f7d 	.word	0x00004f7d
    4f3c:	00004f8b 	.word	0x00004f8b
    4f40:	00005003 	.word	0x00005003
    4f44:	00005003 	.word	0x00005003
    4f48:	00005003 	.word	0x00005003
    4f4c:	00005003 	.word	0x00005003
    4f50:	00005003 	.word	0x00005003
    4f54:	00005003 	.word	0x00005003
    4f58:	00005003 	.word	0x00005003
    4f5c:	00005003 	.word	0x00005003
    4f60:	00005003 	.word	0x00005003
    4f64:	00005003 	.word	0x00005003
    4f68:	00005003 	.word	0x00005003
    4f6c:	00004f99 	.word	0x00004f99
    4f70:	00004fa7 	.word	0x00004fa7
    4f74:	00004fb5 	.word	0x00004fb5
    4f78:	00004fc3 	.word	0x00004fc3
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    4f7c:	2301      	movs	r3, #1
    4f7e:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4f80:	9a05      	ldr	r2, [sp, #20]
    4f82:	9b01      	ldr	r3, [sp, #4]
    4f84:	4313      	orrs	r3, r2
    4f86:	9305      	str	r3, [sp, #20]
                break;
    4f88:	e03c      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    4f8a:	2302      	movs	r3, #2
    4f8c:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4f8e:	9a05      	ldr	r2, [sp, #20]
    4f90:	9b01      	ldr	r3, [sp, #4]
    4f92:	4313      	orrs	r3, r2
    4f94:	9305      	str	r3, [sp, #20]
                break;
    4f96:	e035      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    4f98:	2304      	movs	r3, #4
    4f9a:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4f9c:	9a05      	ldr	r2, [sp, #20]
    4f9e:	9b01      	ldr	r3, [sp, #4]
    4fa0:	4313      	orrs	r3, r2
    4fa2:	9305      	str	r3, [sp, #20]
                break;
    4fa4:	e02e      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    4fa6:	2308      	movs	r3, #8
    4fa8:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    4faa:	9a05      	ldr	r2, [sp, #20]
    4fac:	9b01      	ldr	r3, [sp, #4]
    4fae:	4313      	orrs	r3, r2
    4fb0:	9305      	str	r3, [sp, #20]
                break;
    4fb2:	e027      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    4fb4:	230e      	movs	r3, #14
    4fb6:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4fb8:	9a05      	ldr	r2, [sp, #20]
    4fba:	9b01      	ldr	r3, [sp, #4]
    4fbc:	4013      	ands	r3, r2
    4fbe:	9305      	str	r3, [sp, #20]
                break;
    4fc0:	e020      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    4fc2:	230d      	movs	r3, #13
    4fc4:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4fc6:	9a05      	ldr	r2, [sp, #20]
    4fc8:	9b01      	ldr	r3, [sp, #4]
    4fca:	4013      	ands	r3, r2
    4fcc:	9305      	str	r3, [sp, #20]
                break;
    4fce:	e019      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    4fd0:	9b03      	ldr	r3, [sp, #12]
    4fd2:	4a0f      	ldr	r2, [pc, #60]	; (5010 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    4fd4:	4293      	cmp	r3, r2
    4fd6:	d115      	bne.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    4fd8:	9b02      	ldr	r3, [sp, #8]
    4fda:	2b00      	cmp	r3, #0
    4fdc:	d003      	beq.n	4fe6 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    4fde:	9b02      	ldr	r3, [sp, #8]
    4fe0:	2b01      	cmp	r3, #1
    4fe2:	d007      	beq.n	4ff4 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    4fe4:	e00e      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    4fe6:	230b      	movs	r3, #11
    4fe8:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4fea:	9a05      	ldr	r2, [sp, #20]
    4fec:	9b01      	ldr	r3, [sp, #4]
    4fee:	4013      	ands	r3, r2
    4ff0:	9305      	str	r3, [sp, #20]
                break;
    4ff2:	e007      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    4ff4:	2307      	movs	r3, #7
    4ff6:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    4ff8:	9a05      	ldr	r2, [sp, #20]
    4ffa:	9b01      	ldr	r3, [sp, #4]
    4ffc:	4013      	ands	r3, r2
    4ffe:	9305      	str	r3, [sp, #20]
                break;
    5000:	e000      	b.n	5004 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    5002:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    5004:	9b05      	ldr	r3, [sp, #20]
}
    5006:	4618      	mov	r0, r3
    5008:	b006      	add	sp, #24
    500a:	4770      	bx	lr
    500c:	4004a000 	.word	0x4004a000
    5010:	4004b000 	.word	0x4004b000

00005014 <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    5014:	b500      	push	{lr}
    5016:	b089      	sub	sp, #36	; 0x24
    5018:	9003      	str	r0, [sp, #12]
    501a:	9102      	str	r1, [sp, #8]
    501c:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    501e:	9b01      	ldr	r3, [sp, #4]
    5020:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    5022:	9b01      	ldr	r3, [sp, #4]
    5024:	2b08      	cmp	r3, #8
    5026:	d121      	bne.n	506c <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    5028:	4b13      	ldr	r3, [pc, #76]	; (5078 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    502a:	685b      	ldr	r3, [r3, #4]
    502c:	f003 030f 	and.w	r3, r3, #15
    5030:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    5032:	9a06      	ldr	r2, [sp, #24]
    5034:	9902      	ldr	r1, [sp, #8]
    5036:	9803      	ldr	r0, [sp, #12]
    5038:	f7ff ff6e 	bl	4f18 <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    503c:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    503e:	9b05      	ldr	r3, [sp, #20]
    5040:	2bff      	cmp	r3, #255	; 0xff
    5042:	d011      	beq.n	5068 <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    5044:	f002 f886 	bl	7154 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    5048:	4b0b      	ldr	r3, [pc, #44]	; (5078 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    504a:	685b      	ldr	r3, [r3, #4]
    504c:	4a0a      	ldr	r2, [pc, #40]	; (5078 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    504e:	f023 030f 	bic.w	r3, r3, #15
    5052:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    5054:	4b08      	ldr	r3, [pc, #32]	; (5078 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    5056:	685a      	ldr	r2, [r3, #4]
    5058:	9b05      	ldr	r3, [sp, #20]
    505a:	f003 030f 	and.w	r3, r3, #15
    505e:	4906      	ldr	r1, [pc, #24]	; (5078 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    5060:	4313      	orrs	r3, r2
    5062:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    5064:	f002 f8a2 	bl	71ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    5068:	2300      	movs	r3, #0
    506a:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    506c:	9b07      	ldr	r3, [sp, #28]
}
    506e:	4618      	mov	r0, r3
    5070:	b009      	add	sp, #36	; 0x24
    5072:	f85d fb04 	ldr.w	pc, [sp], #4
    5076:	bf00      	nop
    5078:	40048000 	.word	0x40048000

0000507c <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    507c:	b500      	push	{lr}
    507e:	b087      	sub	sp, #28
    5080:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    5082:	2300      	movs	r3, #0
    5084:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    5086:	2300      	movs	r3, #0
    5088:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    508a:	2300      	movs	r3, #0
    508c:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    508e:	9b01      	ldr	r3, [sp, #4]
    5090:	68db      	ldr	r3, [r3, #12]
    5092:	2b02      	cmp	r3, #2
    5094:	d00a      	beq.n	50ac <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    5096:	9b05      	ldr	r3, [sp, #20]
    5098:	f043 0302 	orr.w	r3, r3, #2
    509c:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    509e:	9b01      	ldr	r3, [sp, #4]
    50a0:	68db      	ldr	r3, [r3, #12]
    50a2:	f003 0301 	and.w	r3, r3, #1
    50a6:	9a05      	ldr	r2, [sp, #20]
    50a8:	4313      	orrs	r3, r2
    50aa:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    50ac:	9b01      	ldr	r3, [sp, #4]
    50ae:	699b      	ldr	r3, [r3, #24]
    50b0:	019b      	lsls	r3, r3, #6
    50b2:	f003 0340 	and.w	r3, r3, #64	; 0x40
    50b6:	9a05      	ldr	r2, [sp, #20]
    50b8:	4313      	orrs	r3, r2
    50ba:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    50bc:	9b01      	ldr	r3, [sp, #4]
    50be:	6a1b      	ldr	r3, [r3, #32]
    50c0:	03db      	lsls	r3, r3, #15
    50c2:	b29b      	uxth	r3, r3
    50c4:	9a05      	ldr	r2, [sp, #20]
    50c6:	4313      	orrs	r3, r2
    50c8:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    50ca:	9b01      	ldr	r3, [sp, #4]
    50cc:	7f1b      	ldrb	r3, [r3, #28]
    50ce:	2b00      	cmp	r3, #0
    50d0:	d001      	beq.n	50d6 <Port_Ci_Port_Ip_PinInit+0x5a>
    50d2:	2310      	movs	r3, #16
    50d4:	e000      	b.n	50d8 <Port_Ci_Port_Ip_PinInit+0x5c>
    50d6:	2300      	movs	r3, #0
    50d8:	9a05      	ldr	r2, [sp, #20]
    50da:	4313      	orrs	r3, r2
    50dc:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    50de:	9b01      	ldr	r3, [sp, #4]
    50e0:	691b      	ldr	r3, [r3, #16]
    50e2:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    50e4:	9b01      	ldr	r3, [sp, #4]
    50e6:	6818      	ldr	r0, [r3, #0]
    50e8:	9b01      	ldr	r3, [sp, #4]
    50ea:	689b      	ldr	r3, [r3, #8]
    50ec:	9a04      	ldr	r2, [sp, #16]
    50ee:	4619      	mov	r1, r3
    50f0:	f7ff ff90 	bl	5014 <Port_Ci_Port_Ip_ConfigureInterleave>
    50f4:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    50f6:	9b03      	ldr	r3, [sp, #12]
    50f8:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    50fa:	9b04      	ldr	r3, [sp, #16]
    50fc:	021b      	lsls	r3, r3, #8
    50fe:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    5102:	9a05      	ldr	r2, [sp, #20]
    5104:	4313      	orrs	r3, r2
    5106:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    5108:	f001 fe8a 	bl	6e20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    510c:	9b01      	ldr	r3, [sp, #4]
    510e:	681b      	ldr	r3, [r3, #0]
    5110:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    5114:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    5116:	9b01      	ldr	r3, [sp, #4]
    5118:	689b      	ldr	r3, [r3, #8]
    511a:	2201      	movs	r2, #1
    511c:	fa02 f303 	lsl.w	r3, r2, r3
    5120:	43db      	mvns	r3, r3
    5122:	9a02      	ldr	r2, [sp, #8]
    5124:	4013      	ands	r3, r2
    5126:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    5128:	9b01      	ldr	r3, [sp, #4]
    512a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    512e:	2b00      	cmp	r3, #0
    5130:	d001      	beq.n	5136 <Port_Ci_Port_Ip_PinInit+0xba>
    5132:	2201      	movs	r2, #1
    5134:	e000      	b.n	5138 <Port_Ci_Port_Ip_PinInit+0xbc>
    5136:	2200      	movs	r2, #0
    5138:	9b01      	ldr	r3, [sp, #4]
    513a:	689b      	ldr	r3, [r3, #8]
    513c:	fa02 f303 	lsl.w	r3, r2, r3
    5140:	9a02      	ldr	r2, [sp, #8]
    5142:	4313      	orrs	r3, r2
    5144:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    5146:	9b01      	ldr	r3, [sp, #4]
    5148:	681b      	ldr	r3, [r3, #0]
    514a:	9a02      	ldr	r2, [sp, #8]
    514c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    5150:	f001 fe92 	bl	6e78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    5154:	9b04      	ldr	r3, [sp, #16]
    5156:	2b01      	cmp	r3, #1
    5158:	d16d      	bne.n	5236 <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    515a:	9b01      	ldr	r3, [sp, #4]
    515c:	695b      	ldr	r3, [r3, #20]
    515e:	2b02      	cmp	r3, #2
    5160:	d138      	bne.n	51d4 <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    5162:	9b01      	ldr	r3, [sp, #4]
    5164:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    5168:	2b01      	cmp	r3, #1
    516a:	d10f      	bne.n	518c <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    516c:	f001 feaa 	bl	6ec4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    5170:	9b01      	ldr	r3, [sp, #4]
    5172:	685b      	ldr	r3, [r3, #4]
    5174:	6859      	ldr	r1, [r3, #4]
    5176:	9b01      	ldr	r3, [sp, #4]
    5178:	689b      	ldr	r3, [r3, #8]
    517a:	2201      	movs	r2, #1
    517c:	409a      	lsls	r2, r3
    517e:	9b01      	ldr	r3, [sp, #4]
    5180:	685b      	ldr	r3, [r3, #4]
    5182:	430a      	orrs	r2, r1
    5184:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    5186:	f001 fec9 	bl	6f1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    518a:	e013      	b.n	51b4 <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    518c:	9b01      	ldr	r3, [sp, #4]
    518e:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    5192:	2b00      	cmp	r3, #0
    5194:	d10e      	bne.n	51b4 <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    5196:	f001 fee7 	bl	6f68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    519a:	9b01      	ldr	r3, [sp, #4]
    519c:	685b      	ldr	r3, [r3, #4]
    519e:	6899      	ldr	r1, [r3, #8]
    51a0:	9b01      	ldr	r3, [sp, #4]
    51a2:	689b      	ldr	r3, [r3, #8]
    51a4:	2201      	movs	r2, #1
    51a6:	409a      	lsls	r2, r3
    51a8:	9b01      	ldr	r3, [sp, #4]
    51aa:	685b      	ldr	r3, [r3, #4]
    51ac:	430a      	orrs	r2, r1
    51ae:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    51b0:	f001 ff06 	bl	6fc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    51b4:	f001 ff2a 	bl	700c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    51b8:	9b01      	ldr	r3, [sp, #4]
    51ba:	685b      	ldr	r3, [r3, #4]
    51bc:	6959      	ldr	r1, [r3, #20]
    51be:	9b01      	ldr	r3, [sp, #4]
    51c0:	689b      	ldr	r3, [r3, #8]
    51c2:	2201      	movs	r2, #1
    51c4:	409a      	lsls	r2, r3
    51c6:	9b01      	ldr	r3, [sp, #4]
    51c8:	685b      	ldr	r3, [r3, #4]
    51ca:	430a      	orrs	r2, r1
    51cc:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    51ce:	f001 ff49 	bl	7064 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    51d2:	e030      	b.n	5236 <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    51d4:	f001 ff1a 	bl	700c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    51d8:	9b01      	ldr	r3, [sp, #4]
    51da:	685b      	ldr	r3, [r3, #4]
    51dc:	6959      	ldr	r1, [r3, #20]
    51de:	9b01      	ldr	r3, [sp, #4]
    51e0:	689b      	ldr	r3, [r3, #8]
    51e2:	2201      	movs	r2, #1
    51e4:	fa02 f303 	lsl.w	r3, r2, r3
    51e8:	43da      	mvns	r2, r3
    51ea:	9b01      	ldr	r3, [sp, #4]
    51ec:	685b      	ldr	r3, [r3, #4]
    51ee:	400a      	ands	r2, r1
    51f0:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    51f2:	f001 ff37 	bl	7064 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    51f6:	f001 ff5b 	bl	70b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    51fa:	9b01      	ldr	r3, [sp, #4]
    51fc:	685b      	ldr	r3, [r3, #4]
    51fe:	6999      	ldr	r1, [r3, #24]
    5200:	9b01      	ldr	r3, [sp, #4]
    5202:	689b      	ldr	r3, [r3, #8]
    5204:	2201      	movs	r2, #1
    5206:	fa02 f303 	lsl.w	r3, r2, r3
    520a:	43da      	mvns	r2, r3
    520c:	9b01      	ldr	r3, [sp, #4]
    520e:	685b      	ldr	r3, [r3, #4]
    5210:	400a      	ands	r2, r1
    5212:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    5214:	9b01      	ldr	r3, [sp, #4]
    5216:	695b      	ldr	r3, [r3, #20]
    5218:	2b03      	cmp	r3, #3
    521a:	d10a      	bne.n	5232 <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    521c:	9b01      	ldr	r3, [sp, #4]
    521e:	685b      	ldr	r3, [r3, #4]
    5220:	6999      	ldr	r1, [r3, #24]
    5222:	9b01      	ldr	r3, [sp, #4]
    5224:	689b      	ldr	r3, [r3, #8]
    5226:	2201      	movs	r2, #1
    5228:	409a      	lsls	r2, r3
    522a:	9b01      	ldr	r3, [sp, #4]
    522c:	685b      	ldr	r3, [r3, #4]
    522e:	430a      	orrs	r2, r1
    5230:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    5232:	f001 ff69 	bl	7108 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    5236:	9b01      	ldr	r3, [sp, #4]
    5238:	681b      	ldr	r3, [r3, #0]
    523a:	9a01      	ldr	r2, [sp, #4]
    523c:	6892      	ldr	r2, [r2, #8]
    523e:	9905      	ldr	r1, [sp, #20]
    5240:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    5244:	bf00      	nop
    5246:	b007      	add	sp, #28
    5248:	f85d fb04 	ldr.w	pc, [sp], #4

0000524c <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    524c:	b500      	push	{lr}
    524e:	b085      	sub	sp, #20
    5250:	9001      	str	r0, [sp, #4]
    5252:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    5254:	2300      	movs	r3, #0
    5256:	9303      	str	r3, [sp, #12]
    5258:	e00d      	b.n	5276 <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    525a:	9a03      	ldr	r2, [sp, #12]
    525c:	4613      	mov	r3, r2
    525e:	009b      	lsls	r3, r3, #2
    5260:	4413      	add	r3, r2
    5262:	00db      	lsls	r3, r3, #3
    5264:	461a      	mov	r2, r3
    5266:	9b00      	ldr	r3, [sp, #0]
    5268:	4413      	add	r3, r2
    526a:	4618      	mov	r0, r3
    526c:	f7ff ff06 	bl	507c <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    5270:	9b03      	ldr	r3, [sp, #12]
    5272:	3301      	adds	r3, #1
    5274:	9303      	str	r3, [sp, #12]
    5276:	9a03      	ldr	r2, [sp, #12]
    5278:	9b01      	ldr	r3, [sp, #4]
    527a:	429a      	cmp	r2, r3
    527c:	d3ed      	bcc.n	525a <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    527e:	2300      	movs	r3, #0
}
    5280:	4618      	mov	r0, r3
    5282:	b005      	add	sp, #20
    5284:	f85d fb04 	ldr.w	pc, [sp], #4

00005288 <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    5288:	b500      	push	{lr}
    528a:	b087      	sub	sp, #28
    528c:	9003      	str	r0, [sp, #12]
    528e:	9102      	str	r1, [sp, #8]
    5290:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    5292:	9a01      	ldr	r2, [sp, #4]
    5294:	9902      	ldr	r1, [sp, #8]
    5296:	9803      	ldr	r0, [sp, #12]
    5298:	f7ff febc 	bl	5014 <Port_Ci_Port_Ip_ConfigureInterleave>
    529c:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    529e:	f001 ffab 	bl	71f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    52a2:	9b03      	ldr	r3, [sp, #12]
    52a4:	9a02      	ldr	r2, [sp, #8]
    52a6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    52aa:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    52ac:	9b04      	ldr	r3, [sp, #16]
    52ae:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    52b2:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    52b4:	9b05      	ldr	r3, [sp, #20]
    52b6:	021b      	lsls	r3, r3, #8
    52b8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    52bc:	9a04      	ldr	r2, [sp, #16]
    52be:	4313      	orrs	r3, r2
    52c0:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    52c2:	9b03      	ldr	r3, [sp, #12]
    52c4:	9a02      	ldr	r2, [sp, #8]
    52c6:	9904      	ldr	r1, [sp, #16]
    52c8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    52cc:	f001 ffc0 	bl	7250 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    52d0:	bf00      	nop
    52d2:	b007      	add	sp, #28
    52d4:	f85d fb04 	ldr.w	pc, [sp], #4

000052d8 <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    52d8:	b500      	push	{lr}
    52da:	b083      	sub	sp, #12
    52dc:	9001      	str	r0, [sp, #4]
    52de:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    52e0:	f001 ffdc 	bl	729c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    52e4:	9b01      	ldr	r3, [sp, #4]
    52e6:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    52ea:	2101      	movs	r1, #1
    52ec:	9b00      	ldr	r3, [sp, #0]
    52ee:	fa01 f303 	lsl.w	r3, r1, r3
    52f2:	431a      	orrs	r2, r3
    52f4:	9b01      	ldr	r3, [sp, #4]
    52f6:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    52fa:	f001 fffb 	bl	72f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    52fe:	bf00      	nop
    5300:	b003      	add	sp, #12
    5302:	f85d fb04 	ldr.w	pc, [sp], #4

00005306 <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    5306:	b500      	push	{lr}
    5308:	b083      	sub	sp, #12
    530a:	9001      	str	r0, [sp, #4]
    530c:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    530e:	f002 f817 	bl	7340 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    5312:	9b01      	ldr	r3, [sp, #4]
    5314:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    5318:	2101      	movs	r1, #1
    531a:	9b00      	ldr	r3, [sp, #0]
    531c:	fa01 f303 	lsl.w	r3, r1, r3
    5320:	43db      	mvns	r3, r3
    5322:	401a      	ands	r2, r3
    5324:	9b01      	ldr	r3, [sp, #4]
    5326:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    532a:	f002 f835 	bl	7398 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    532e:	bf00      	nop
    5330:	b003      	add	sp, #12
    5332:	f85d fb04 	ldr.w	pc, [sp], #4

00005336 <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    5336:	b082      	sub	sp, #8
    5338:	9001      	str	r0, [sp, #4]
    533a:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    533c:	9b00      	ldr	r3, [sp, #0]
    533e:	785b      	ldrb	r3, [r3, #1]
    5340:	f003 0201 	and.w	r2, r3, #1
    5344:	9b01      	ldr	r3, [sp, #4]
    5346:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    534a:	9b00      	ldr	r3, [sp, #0]
    534c:	789b      	ldrb	r3, [r3, #2]
    534e:	f003 021f 	and.w	r2, r3, #31
    5352:	9b01      	ldr	r3, [sp, #4]
    5354:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    5358:	bf00      	nop
    535a:	b002      	add	sp, #8
    535c:	4770      	bx	lr

0000535e <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    535e:	b086      	sub	sp, #24
    5360:	9003      	str	r0, [sp, #12]
    5362:	9301      	str	r3, [sp, #4]
    5364:	460b      	mov	r3, r1
    5366:	f8ad 300a 	strh.w	r3, [sp, #10]
    536a:	4613      	mov	r3, r2
    536c:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    5370:	2300      	movs	r3, #0
    5372:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    5376:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    537a:	f043 0301 	orr.w	r3, r3, #1
    537e:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    5382:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5386:	f043 0302 	orr.w	r3, r3, #2
    538a:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    538e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5392:	f043 0310 	orr.w	r3, r3, #16
    5396:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    539a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    539e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    53a2:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    53a6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53aa:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    53ae:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    53b2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53b6:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    53ba:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    53be:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    53c2:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    53c6:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    53ca:	4013      	ands	r3, r2
    53cc:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    53d0:	9b01      	ldr	r3, [sp, #4]
    53d2:	2b00      	cmp	r3, #0
    53d4:	d003      	beq.n	53de <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    53d6:	9b01      	ldr	r3, [sp, #4]
    53d8:	2b01      	cmp	r3, #1
    53da:	d00a      	beq.n	53f2 <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    53dc:	e013      	b.n	5406 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    53de:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    53e2:	041a      	lsls	r2, r3, #16
    53e4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53e8:	431a      	orrs	r2, r3
    53ea:	9b03      	ldr	r3, [sp, #12]
    53ec:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    53f0:	e009      	b.n	5406 <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    53f2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    53f6:	041a      	lsls	r2, r3, #16
    53f8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    53fc:	431a      	orrs	r2, r3
    53fe:	9b03      	ldr	r3, [sp, #12]
    5400:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    5404:	bf00      	nop
    }
}
    5406:	bf00      	nop
    5408:	b006      	add	sp, #24
    540a:	4770      	bx	lr

0000540c <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    540c:	b500      	push	{lr}
    540e:	b085      	sub	sp, #20
    5410:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    5412:	9b01      	ldr	r3, [sp, #4]
    5414:	9303      	str	r3, [sp, #12]
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
        }
        else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
        {
            Port_Ipw_Init(pLocalConfigPtr);
    5416:	9803      	ldr	r0, [sp, #12]
    5418:	f000 f94e 	bl	56b8 <Port_Ipw_Init>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
    541c:	4a03      	ldr	r2, [pc, #12]	; (542c <Port_Init+0x20>)
    541e:	9b03      	ldr	r3, [sp, #12]
    5420:	6013      	str	r3, [r2, #0]
        }
    }
}
    5422:	bf00      	nop
    5424:	b005      	add	sp, #20
    5426:	f85d fb04 	ldr.w	pc, [sp], #4
    542a:	bf00      	nop
    542c:	1fff8d14 	.word	0x1fff8d14

00005430 <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    5430:	b508      	push	{r3, lr}
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    }
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    5432:	4b03      	ldr	r3, [pc, #12]	; (5440 <Port_RefreshPortDirection+0x10>)
    5434:	681b      	ldr	r3, [r3, #0]
    5436:	4618      	mov	r0, r3
    5438:	f000 f996 	bl	5768 <Port_Ipw_RefreshPortDirection>
    }
}
    543c:	bf00      	nop
    543e:	bd08      	pop	{r3, pc}
    5440:	1fff8d14 	.word	0x1fff8d14

00005444 <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    5444:	b500      	push	{lr}
    5446:	b087      	sub	sp, #28
    5448:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    544a:	9b01      	ldr	r3, [sp, #4]
    544c:	885b      	ldrh	r3, [r3, #2]
    544e:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    5452:	9b01      	ldr	r3, [sp, #4]
    5454:	689b      	ldr	r3, [r3, #8]
    5456:	7a1b      	ldrb	r3, [r3, #8]
    5458:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    545c:	9b01      	ldr	r3, [sp, #4]
    545e:	689b      	ldr	r3, [r3, #8]
    5460:	681b      	ldr	r3, [r3, #0]
    5462:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    5464:	9b01      	ldr	r3, [sp, #4]
    5466:	689b      	ldr	r3, [r3, #8]
    5468:	685b      	ldr	r3, [r3, #4]
    546a:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    546c:	2300      	movs	r3, #0
    546e:	f8ad 3016 	strh.w	r3, [sp, #22]
    5472:	e111      	b.n	5698 <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    5474:	9b02      	ldr	r3, [sp, #8]
    5476:	2b02      	cmp	r3, #2
    5478:	d169      	bne.n	554e <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    547a:	f89d 3013 	ldrb.w	r3, [sp, #19]
    547e:	2b01      	cmp	r3, #1
    5480:	d11a      	bne.n	54b8 <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5482:	9b01      	ldr	r3, [sp, #4]
    5484:	685a      	ldr	r2, [r3, #4]
    5486:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    548a:	005b      	lsls	r3, r3, #1
    548c:	4413      	add	r3, r2
    548e:	881b      	ldrh	r3, [r3, #0]
    5490:	f003 021f 	and.w	r2, r3, #31
    5494:	9b01      	ldr	r3, [sp, #4]
    5496:	6859      	ldr	r1, [r3, #4]
    5498:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    549c:	005b      	lsls	r3, r3, #1
    549e:	440b      	add	r3, r1
    54a0:	881b      	ldrh	r3, [r3, #0]
    54a2:	095b      	lsrs	r3, r3, #5
    54a4:	b29b      	uxth	r3, r3
    54a6:	4619      	mov	r1, r3
    54a8:	4b81      	ldr	r3, [pc, #516]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    54aa:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    54ae:	2101      	movs	r1, #1
    54b0:	fa01 f202 	lsl.w	r2, r1, r2
    54b4:	605a      	str	r2, [r3, #4]
    54b6:	e01d      	b.n	54f4 <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    54b8:	f89d 3013 	ldrb.w	r3, [sp, #19]
    54bc:	2b00      	cmp	r3, #0
    54be:	d119      	bne.n	54f4 <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    54c0:	9b01      	ldr	r3, [sp, #4]
    54c2:	685a      	ldr	r2, [r3, #4]
    54c4:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54c8:	005b      	lsls	r3, r3, #1
    54ca:	4413      	add	r3, r2
    54cc:	881b      	ldrh	r3, [r3, #0]
    54ce:	f003 021f 	and.w	r2, r3, #31
    54d2:	9b01      	ldr	r3, [sp, #4]
    54d4:	6859      	ldr	r1, [r3, #4]
    54d6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    54da:	005b      	lsls	r3, r3, #1
    54dc:	440b      	add	r3, r1
    54de:	881b      	ldrh	r3, [r3, #0]
    54e0:	095b      	lsrs	r3, r3, #5
    54e2:	b29b      	uxth	r3, r3
    54e4:	4619      	mov	r1, r3
    54e6:	4b72      	ldr	r3, [pc, #456]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    54e8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    54ec:	2101      	movs	r1, #1
    54ee:	fa01 f202 	lsl.w	r2, r1, r2
    54f2:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    54f4:	f001 ff76 	bl	73e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    54f8:	9b01      	ldr	r3, [sp, #4]
    54fa:	685a      	ldr	r2, [r3, #4]
    54fc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5500:	005b      	lsls	r3, r3, #1
    5502:	4413      	add	r3, r2
    5504:	881b      	ldrh	r3, [r3, #0]
    5506:	095b      	lsrs	r3, r3, #5
    5508:	b29b      	uxth	r3, r3
    550a:	461a      	mov	r2, r3
    550c:	4b68      	ldr	r3, [pc, #416]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    550e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5512:	6959      	ldr	r1, [r3, #20]
    5514:	9b01      	ldr	r3, [sp, #4]
    5516:	685a      	ldr	r2, [r3, #4]
    5518:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    551c:	005b      	lsls	r3, r3, #1
    551e:	4413      	add	r3, r2
    5520:	881b      	ldrh	r3, [r3, #0]
    5522:	f003 031f 	and.w	r3, r3, #31
    5526:	2201      	movs	r2, #1
    5528:	409a      	lsls	r2, r3
    552a:	9b01      	ldr	r3, [sp, #4]
    552c:	6858      	ldr	r0, [r3, #4]
    552e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5532:	005b      	lsls	r3, r3, #1
    5534:	4403      	add	r3, r0
    5536:	881b      	ldrh	r3, [r3, #0]
    5538:	095b      	lsrs	r3, r3, #5
    553a:	b29b      	uxth	r3, r3
    553c:	4618      	mov	r0, r3
    553e:	4b5c      	ldr	r3, [pc, #368]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    5540:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5544:	430a      	orrs	r2, r1
    5546:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    5548:	f001 ff78 	bl	743c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    554c:	e086      	b.n	565c <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    554e:	f001 ff49 	bl	73e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    5552:	9b01      	ldr	r3, [sp, #4]
    5554:	685a      	ldr	r2, [r3, #4]
    5556:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    555a:	005b      	lsls	r3, r3, #1
    555c:	4413      	add	r3, r2
    555e:	881b      	ldrh	r3, [r3, #0]
    5560:	095b      	lsrs	r3, r3, #5
    5562:	b29b      	uxth	r3, r3
    5564:	461a      	mov	r2, r3
    5566:	4b52      	ldr	r3, [pc, #328]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    5568:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    556c:	6959      	ldr	r1, [r3, #20]
    556e:	9b01      	ldr	r3, [sp, #4]
    5570:	685a      	ldr	r2, [r3, #4]
    5572:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5576:	005b      	lsls	r3, r3, #1
    5578:	4413      	add	r3, r2
    557a:	881b      	ldrh	r3, [r3, #0]
    557c:	f003 031f 	and.w	r3, r3, #31
    5580:	2201      	movs	r2, #1
    5582:	fa02 f303 	lsl.w	r3, r2, r3
    5586:	43da      	mvns	r2, r3
    5588:	9b01      	ldr	r3, [sp, #4]
    558a:	6858      	ldr	r0, [r3, #4]
    558c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5590:	005b      	lsls	r3, r3, #1
    5592:	4403      	add	r3, r0
    5594:	881b      	ldrh	r3, [r3, #0]
    5596:	095b      	lsrs	r3, r3, #5
    5598:	b29b      	uxth	r3, r3
    559a:	4618      	mov	r0, r3
    559c:	4b44      	ldr	r3, [pc, #272]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    559e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    55a2:	400a      	ands	r2, r1
    55a4:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    55a6:	f001 ff49 	bl	743c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    55aa:	f001 ff6d 	bl	7488 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    55ae:	9b01      	ldr	r3, [sp, #4]
    55b0:	685a      	ldr	r2, [r3, #4]
    55b2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55b6:	005b      	lsls	r3, r3, #1
    55b8:	4413      	add	r3, r2
    55ba:	881b      	ldrh	r3, [r3, #0]
    55bc:	095b      	lsrs	r3, r3, #5
    55be:	b29b      	uxth	r3, r3
    55c0:	461a      	mov	r2, r3
    55c2:	4b3b      	ldr	r3, [pc, #236]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    55c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    55c8:	6999      	ldr	r1, [r3, #24]
    55ca:	9b01      	ldr	r3, [sp, #4]
    55cc:	685a      	ldr	r2, [r3, #4]
    55ce:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55d2:	005b      	lsls	r3, r3, #1
    55d4:	4413      	add	r3, r2
    55d6:	881b      	ldrh	r3, [r3, #0]
    55d8:	f003 031f 	and.w	r3, r3, #31
    55dc:	2201      	movs	r2, #1
    55de:	fa02 f303 	lsl.w	r3, r2, r3
    55e2:	43da      	mvns	r2, r3
    55e4:	9b01      	ldr	r3, [sp, #4]
    55e6:	6858      	ldr	r0, [r3, #4]
    55e8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    55ec:	005b      	lsls	r3, r3, #1
    55ee:	4403      	add	r3, r0
    55f0:	881b      	ldrh	r3, [r3, #0]
    55f2:	095b      	lsrs	r3, r3, #5
    55f4:	b29b      	uxth	r3, r3
    55f6:	4618      	mov	r0, r3
    55f8:	4b2d      	ldr	r3, [pc, #180]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    55fa:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    55fe:	400a      	ands	r2, r1
    5600:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    5602:	9b02      	ldr	r3, [sp, #8]
    5604:	2b03      	cmp	r3, #3
    5606:	d127      	bne.n	5658 <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    5608:	9b01      	ldr	r3, [sp, #4]
    560a:	685a      	ldr	r2, [r3, #4]
    560c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5610:	005b      	lsls	r3, r3, #1
    5612:	4413      	add	r3, r2
    5614:	881b      	ldrh	r3, [r3, #0]
    5616:	095b      	lsrs	r3, r3, #5
    5618:	b29b      	uxth	r3, r3
    561a:	461a      	mov	r2, r3
    561c:	4b24      	ldr	r3, [pc, #144]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    561e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5622:	6999      	ldr	r1, [r3, #24]
    5624:	9b01      	ldr	r3, [sp, #4]
    5626:	685a      	ldr	r2, [r3, #4]
    5628:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    562c:	005b      	lsls	r3, r3, #1
    562e:	4413      	add	r3, r2
    5630:	881b      	ldrh	r3, [r3, #0]
    5632:	f003 031f 	and.w	r3, r3, #31
    5636:	2201      	movs	r2, #1
    5638:	409a      	lsls	r2, r3
    563a:	9b01      	ldr	r3, [sp, #4]
    563c:	6858      	ldr	r0, [r3, #4]
    563e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5642:	005b      	lsls	r3, r3, #1
    5644:	4403      	add	r3, r0
    5646:	881b      	ldrh	r3, [r3, #0]
    5648:	095b      	lsrs	r3, r3, #5
    564a:	b29b      	uxth	r3, r3
    564c:	4618      	mov	r0, r3
    564e:	4b18      	ldr	r3, [pc, #96]	; (56b0 <Port_Ipw_Init_UnusedPins+0x26c>)
    5650:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5654:	430a      	orrs	r2, r1
    5656:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    5658:	f001 ff42 	bl	74e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    565c:	9b01      	ldr	r3, [sp, #4]
    565e:	685a      	ldr	r2, [r3, #4]
    5660:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5664:	005b      	lsls	r3, r3, #1
    5666:	4413      	add	r3, r2
    5668:	881b      	ldrh	r3, [r3, #0]
    566a:	095b      	lsrs	r3, r3, #5
    566c:	b29b      	uxth	r3, r3
    566e:	461a      	mov	r2, r3
    5670:	4b10      	ldr	r3, [pc, #64]	; (56b4 <Port_Ipw_Init_UnusedPins+0x270>)
    5672:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5676:	9a01      	ldr	r2, [sp, #4]
    5678:	6851      	ldr	r1, [r2, #4]
    567a:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    567e:	0052      	lsls	r2, r2, #1
    5680:	440a      	add	r2, r1
    5682:	8812      	ldrh	r2, [r2, #0]
    5684:	f002 021f 	and.w	r2, r2, #31
    5688:	9903      	ldr	r1, [sp, #12]
    568a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    568e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    5692:	3301      	adds	r3, #1
    5694:	f8ad 3016 	strh.w	r3, [sp, #22]
    5698:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    569c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    56a0:	429a      	cmp	r2, r3
    56a2:	f4ff aee7 	bcc.w	5474 <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    56a6:	bf00      	nop
    56a8:	bf00      	nop
    56aa:	b007      	add	sp, #28
    56ac:	f85d fb04 	ldr.w	pc, [sp], #4
    56b0:	0000ad94 	.word	0x0000ad94
    56b4:	0000ad80 	.word	0x0000ad80

000056b8 <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    56b8:	b500      	push	{lr}
    56ba:	b085      	sub	sp, #20
    56bc:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    56be:	9b01      	ldr	r3, [sp, #4]
    56c0:	7c1b      	ldrb	r3, [r3, #16]
    56c2:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    56c6:	2300      	movs	r3, #0
    56c8:	f8ad 300e 	strh.w	r3, [sp, #14]
    56cc:	e035      	b.n	573a <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    56ce:	9b01      	ldr	r3, [sp, #4]
    56d0:	695a      	ldr	r2, [r3, #20]
    56d2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    56d6:	00db      	lsls	r3, r3, #3
    56d8:	4413      	add	r3, r2
    56da:	781b      	ldrb	r3, [r3, #0]
    56dc:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    56e0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    56e4:	4a1f      	ldr	r2, [pc, #124]	; (5764 <Port_Ipw_Init+0xac>)
    56e6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    56ea:	9b01      	ldr	r3, [sp, #4]
    56ec:	695a      	ldr	r2, [r3, #20]
    56ee:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    56f2:	00db      	lsls	r3, r3, #3
    56f4:	4413      	add	r3, r2
    56f6:	4619      	mov	r1, r3
    56f8:	f7ff fe1d 	bl	5336 <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    56fc:	f002 f85e 	bl	77bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    5700:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5704:	4a17      	ldr	r2, [pc, #92]	; (5764 <Port_Ipw_Init+0xac>)
    5706:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    570a:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    570e:	9b01      	ldr	r3, [sp, #4]
    5710:	695a      	ldr	r2, [r3, #20]
    5712:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5716:	00db      	lsls	r3, r3, #3
    5718:	4413      	add	r3, r2
    571a:	685a      	ldr	r2, [r3, #4]
    571c:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5720:	4810      	ldr	r0, [pc, #64]	; (5764 <Port_Ipw_Init+0xac>)
    5722:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    5726:	430a      	orrs	r2, r1
    5728:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    572c:	f002 f872 	bl	7814 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    5730:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    5734:	3301      	adds	r3, #1
    5736:	f8ad 300e 	strh.w	r3, [sp, #14]
    573a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    573e:	b29b      	uxth	r3, r3
    5740:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5744:	429a      	cmp	r2, r3
    5746:	d3c2      	bcc.n	56ce <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    5748:	9b01      	ldr	r3, [sp, #4]
    574a:	6a1b      	ldr	r3, [r3, #32]
    574c:	4619      	mov	r1, r3
    574e:	2001      	movs	r0, #1
    5750:	f7ff fd7c 	bl	524c <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    5754:	9801      	ldr	r0, [sp, #4]
    5756:	f7ff fe75 	bl	5444 <Port_Ipw_Init_UnusedPins>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    575a:	bf00      	nop
    575c:	b005      	add	sp, #20
    575e:	f85d fb04 	ldr.w	pc, [sp], #4
    5762:	bf00      	nop
    5764:	0000ad80 	.word	0x0000ad80

00005768 <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    5768:	b500      	push	{lr}
    576a:	b085      	sub	sp, #20
    576c:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    576e:	9b01      	ldr	r3, [sp, #4]
    5770:	881b      	ldrh	r3, [r3, #0]
    5772:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    5776:	2300      	movs	r3, #0
    5778:	f8ad 300e 	strh.w	r3, [sp, #14]
    577c:	e0d2      	b.n	5924 <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    577e:	9b01      	ldr	r3, [sp, #4]
    5780:	68d9      	ldr	r1, [r3, #12]
    5782:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5786:	4613      	mov	r3, r2
    5788:	009b      	lsls	r3, r3, #2
    578a:	4413      	add	r3, r2
    578c:	009b      	lsls	r3, r3, #2
    578e:	440b      	add	r3, r1
    5790:	7c5b      	ldrb	r3, [r3, #17]
    5792:	f083 0301 	eor.w	r3, r3, #1
    5796:	b2db      	uxtb	r3, r3
    5798:	2b00      	cmp	r3, #0
    579a:	f000 80be 	beq.w	591a <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    579e:	9b01      	ldr	r3, [sp, #4]
    57a0:	68d9      	ldr	r1, [r3, #12]
    57a2:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    57a6:	4613      	mov	r3, r2
    57a8:	009b      	lsls	r3, r3, #2
    57aa:	4413      	add	r3, r2
    57ac:	009b      	lsls	r3, r3, #2
    57ae:	440b      	add	r3, r1
    57b0:	7c1b      	ldrb	r3, [r3, #16]
    57b2:	2b00      	cmp	r3, #0
    57b4:	f000 80b1 	beq.w	591a <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    57b8:	9b01      	ldr	r3, [sp, #4]
    57ba:	68d9      	ldr	r1, [r3, #12]
    57bc:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    57c0:	4613      	mov	r3, r2
    57c2:	009b      	lsls	r3, r3, #2
    57c4:	4413      	add	r3, r2
    57c6:	009b      	lsls	r3, r3, #2
    57c8:	440b      	add	r3, r1
    57ca:	881b      	ldrh	r3, [r3, #0]
    57cc:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    57d0:	9b01      	ldr	r3, [sp, #4]
    57d2:	68d9      	ldr	r1, [r3, #12]
    57d4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    57d8:	4613      	mov	r3, r2
    57da:	009b      	lsls	r3, r3, #2
    57dc:	4413      	add	r3, r2
    57de:	009b      	lsls	r3, r3, #2
    57e0:	440b      	add	r3, r1
    57e2:	68db      	ldr	r3, [r3, #12]
    57e4:	2b02      	cmp	r3, #2
    57e6:	d11d      	bne.n	5824 <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    57e8:	f002 f930 	bl	7a4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    57ec:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    57f0:	095b      	lsrs	r3, r3, #5
    57f2:	b29b      	uxth	r3, r3
    57f4:	461a      	mov	r2, r3
    57f6:	4b51      	ldr	r3, [pc, #324]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    57f8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    57fc:	6959      	ldr	r1, [r3, #20]
    57fe:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5802:	f003 031f 	and.w	r3, r3, #31
    5806:	2201      	movs	r2, #1
    5808:	409a      	lsls	r2, r3
    580a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    580e:	095b      	lsrs	r3, r3, #5
    5810:	b29b      	uxth	r3, r3
    5812:	4618      	mov	r0, r3
    5814:	4b49      	ldr	r3, [pc, #292]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    5816:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    581a:	430a      	orrs	r2, r1
    581c:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    581e:	f002 f941 	bl	7aa4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    5822:	e07a      	b.n	591a <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    5824:	9b01      	ldr	r3, [sp, #4]
    5826:	68d9      	ldr	r1, [r3, #12]
    5828:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    582c:	4613      	mov	r3, r2
    582e:	009b      	lsls	r3, r3, #2
    5830:	4413      	add	r3, r2
    5832:	009b      	lsls	r3, r3, #2
    5834:	440b      	add	r3, r1
    5836:	68db      	ldr	r3, [r3, #12]
    5838:	2b01      	cmp	r3, #1
    583a:	d00b      	beq.n	5854 <Port_Ipw_RefreshPortDirection+0xec>
    583c:	9b01      	ldr	r3, [sp, #4]
    583e:	68d9      	ldr	r1, [r3, #12]
    5840:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5844:	4613      	mov	r3, r2
    5846:	009b      	lsls	r3, r3, #2
    5848:	4413      	add	r3, r2
    584a:	009b      	lsls	r3, r3, #2
    584c:	440b      	add	r3, r1
    584e:	68db      	ldr	r3, [r3, #12]
    5850:	2b03      	cmp	r3, #3
    5852:	d162      	bne.n	591a <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    5854:	f002 f8fa 	bl	7a4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    5858:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    585c:	095b      	lsrs	r3, r3, #5
    585e:	b29b      	uxth	r3, r3
    5860:	461a      	mov	r2, r3
    5862:	4b36      	ldr	r3, [pc, #216]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    5864:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5868:	6959      	ldr	r1, [r3, #20]
    586a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    586e:	f003 031f 	and.w	r3, r3, #31
    5872:	2201      	movs	r2, #1
    5874:	fa02 f303 	lsl.w	r3, r2, r3
    5878:	43da      	mvns	r2, r3
    587a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    587e:	095b      	lsrs	r3, r3, #5
    5880:	b29b      	uxth	r3, r3
    5882:	4618      	mov	r0, r3
    5884:	4b2d      	ldr	r3, [pc, #180]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    5886:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    588a:	400a      	ands	r2, r1
    588c:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    588e:	f002 f909 	bl	7aa4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    5892:	f002 f92d 	bl	7af0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    5896:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    589a:	095b      	lsrs	r3, r3, #5
    589c:	b29b      	uxth	r3, r3
    589e:	461a      	mov	r2, r3
    58a0:	4b26      	ldr	r3, [pc, #152]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    58a2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    58a6:	6999      	ldr	r1, [r3, #24]
    58a8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58ac:	f003 031f 	and.w	r3, r3, #31
    58b0:	2201      	movs	r2, #1
    58b2:	fa02 f303 	lsl.w	r3, r2, r3
    58b6:	43da      	mvns	r2, r3
    58b8:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58bc:	095b      	lsrs	r3, r3, #5
    58be:	b29b      	uxth	r3, r3
    58c0:	4618      	mov	r0, r3
    58c2:	4b1e      	ldr	r3, [pc, #120]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    58c4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    58c8:	400a      	ands	r2, r1
    58ca:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    58cc:	9b01      	ldr	r3, [sp, #4]
    58ce:	68d9      	ldr	r1, [r3, #12]
    58d0:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    58d4:	4613      	mov	r3, r2
    58d6:	009b      	lsls	r3, r3, #2
    58d8:	4413      	add	r3, r2
    58da:	009b      	lsls	r3, r3, #2
    58dc:	440b      	add	r3, r1
    58de:	68db      	ldr	r3, [r3, #12]
    58e0:	2b03      	cmp	r3, #3
    58e2:	d118      	bne.n	5916 <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    58e4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58e8:	095b      	lsrs	r3, r3, #5
    58ea:	b29b      	uxth	r3, r3
    58ec:	461a      	mov	r2, r3
    58ee:	4b13      	ldr	r3, [pc, #76]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    58f0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    58f4:	6999      	ldr	r1, [r3, #24]
    58f6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    58fa:	f003 031f 	and.w	r3, r3, #31
    58fe:	2201      	movs	r2, #1
    5900:	409a      	lsls	r2, r3
    5902:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    5906:	095b      	lsrs	r3, r3, #5
    5908:	b29b      	uxth	r3, r3
    590a:	4618      	mov	r0, r3
    590c:	4b0b      	ldr	r3, [pc, #44]	; (593c <Port_Ipw_RefreshPortDirection+0x1d4>)
    590e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    5912:	430a      	orrs	r2, r1
    5914:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    5916:	f002 f917 	bl	7b48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    591a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    591e:	3301      	adds	r3, #1
    5920:	f8ad 300e 	strh.w	r3, [sp, #14]
    5924:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    5928:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    592c:	429a      	cmp	r2, r3
    592e:	f4ff af26 	bcc.w	577e <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    5932:	bf00      	nop
    5934:	bf00      	nop
    5936:	b005      	add	sp, #20
    5938:	f85d fb04 	ldr.w	pc, [sp], #4
    593c:	0000ad94 	.word	0x0000ad94

00005940 <Dio_Ipw_ReadChannel>:
*/
Dio_LevelType Dio_Ipw_ReadChannel
(
    Dio_ChannelType ChannelId
)
{
    5940:	b500      	push	{lr}
    5942:	b087      	sub	sp, #28
    5944:	4603      	mov	r3, r0
    5946:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType) STD_LOW;
    594a:	2300      	movs	r3, #0
    594c:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;

    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    5950:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5954:	095b      	lsrs	r3, r3, #5
    5956:	b29b      	uxth	r3, r3
    5958:	9304      	str	r3, [sp, #16]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    595a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    595e:	f003 031f 	and.w	r3, r3, #31
    5962:	9303      	str	r3, [sp, #12]
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    5964:	4a08      	ldr	r2, [pc, #32]	; (5988 <Dio_Ipw_ReadChannel+0x48>)
    5966:	9b04      	ldr	r3, [sp, #16]
    5968:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    596c:	9302      	str	r3, [sp, #8]

    ChannelLevel = Gpio_Dio_Ip_ReadPin(GpioBase, u32PinIndex);
    596e:	9903      	ldr	r1, [sp, #12]
    5970:	9802      	ldr	r0, [sp, #8]
    5972:	f000 f940 	bl	5bf6 <Gpio_Dio_Ip_ReadPin>
    5976:	4603      	mov	r3, r0
    5978:	f88d 3017 	strb.w	r3, [sp, #23]
    return ChannelLevel;
    597c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    5980:	4618      	mov	r0, r3
    5982:	b007      	add	sp, #28
    5984:	f85d fb04 	ldr.w	pc, [sp], #4
    5988:	1fff8b24 	.word	0x1fff8b24

0000598c <Dio_Ipw_WriteChannel>:
void Dio_Ipw_WriteChannel
(
    Dio_ChannelType ChannelId,
    Dio_LevelType Level
)
{
    598c:	b500      	push	{lr}
    598e:	b087      	sub	sp, #28
    5990:	4603      	mov	r3, r0
    5992:	460a      	mov	r2, r1
    5994:	f8ad 3006 	strh.w	r3, [sp, #6]
    5998:	4613      	mov	r3, r2
    599a:	f88d 3005 	strb.w	r3, [sp, #5]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;

    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    599e:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    59a2:	095b      	lsrs	r3, r3, #5
    59a4:	b29b      	uxth	r3, r3
    59a6:	9305      	str	r3, [sp, #20]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    59a8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    59ac:	f003 031f 	and.w	r3, r3, #31
    59b0:	9304      	str	r3, [sp, #16]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    59b2:	4a08      	ldr	r2, [pc, #32]	; (59d4 <Dio_Ipw_WriteChannel+0x48>)
    59b4:	9b05      	ldr	r3, [sp, #20]
    59b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    59ba:	9303      	str	r3, [sp, #12]

    Gpio_Dio_Ip_WritePin(GpioBase, u32PinIndex, Level);
    59bc:	f89d 3005 	ldrb.w	r3, [sp, #5]
    59c0:	461a      	mov	r2, r3
    59c2:	9904      	ldr	r1, [sp, #16]
    59c4:	9803      	ldr	r0, [sp, #12]
    59c6:	f000 f8b7 	bl	5b38 <Gpio_Dio_Ip_WritePin>
}
    59ca:	bf00      	nop
    59cc:	b007      	add	sp, #28
    59ce:	f85d fb04 	ldr.w	pc, [sp], #4
    59d2:	bf00      	nop
    59d4:	1fff8b24 	.word	0x1fff8b24

000059d8 <Dio_Ipw_FlipChannel>:
*/
Dio_LevelType Dio_Ipw_FlipChannel
(
    Dio_ChannelType ChannelId
)
{
    59d8:	b500      	push	{lr}
    59da:	b089      	sub	sp, #36	; 0x24
    59dc:	4603      	mov	r3, r0
    59de:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    59e2:	2300      	movs	r3, #0
    59e4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 u32GpioInstance;
    uint32 u32PinIndex;
    uint32 u32PortOutPutLevel;
    u32GpioInstance = GPIO_DIO_IP_PORT_U32(ChannelId);
    59e8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    59ec:	095b      	lsrs	r3, r3, #5
    59ee:	b29b      	uxth	r3, r3
    59f0:	9306      	str	r3, [sp, #24]
    u32PinIndex = GPIO_DIO_IP_CHANNEL_U32(ChannelId);
    59f2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    59f6:	f003 031f 	and.w	r3, r3, #31
    59fa:	9305      	str	r3, [sp, #20]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[u32GpioInstance];
    59fc:	4a10      	ldr	r2, [pc, #64]	; (5a40 <Dio_Ipw_FlipChannel+0x68>)
    59fe:	9b06      	ldr	r3, [sp, #24]
    5a00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a04:	9304      	str	r3, [sp, #16]

    Gpio_Dio_Ip_TogglePins(GpioBase, ((uint32)1U << u32PinIndex));
    5a06:	2201      	movs	r2, #1
    5a08:	9b05      	ldr	r3, [sp, #20]
    5a0a:	fa02 f303 	lsl.w	r3, r2, r3
    5a0e:	4619      	mov	r1, r3
    5a10:	9804      	ldr	r0, [sp, #16]
    5a12:	f000 f8dc 	bl	5bce <Gpio_Dio_Ip_TogglePins>

    u32PortOutPutLevel = Gpio_Dio_Ip_GetPinsOutput(GpioBase);
    5a16:	9804      	ldr	r0, [sp, #16]
    5a18:	f000 f8bc 	bl	5b94 <Gpio_Dio_Ip_GetPinsOutput>
    5a1c:	9003      	str	r0, [sp, #12]
    ChannelLevel = (Dio_LevelType)((u32PortOutPutLevel & ((uint32)1U << u32PinIndex)) >> u32PinIndex);
    5a1e:	2201      	movs	r2, #1
    5a20:	9b05      	ldr	r3, [sp, #20]
    5a22:	409a      	lsls	r2, r3
    5a24:	9b03      	ldr	r3, [sp, #12]
    5a26:	401a      	ands	r2, r3
    5a28:	9b05      	ldr	r3, [sp, #20]
    5a2a:	fa22 f303 	lsr.w	r3, r2, r3
    5a2e:	f88d 301f 	strb.w	r3, [sp, #31]

    return ChannelLevel;
    5a32:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    5a36:	4618      	mov	r0, r3
    5a38:	b009      	add	sp, #36	; 0x24
    5a3a:	f85d fb04 	ldr.w	pc, [sp], #4
    5a3e:	bf00      	nop
    5a40:	1fff8b24 	.word	0x1fff8b24

00005a44 <Dio_Ipw_ReadPort>:
*/
Dio_PortLevelType Dio_Ipw_ReadPort
(
    Dio_PortType PortId
)
{
    5a44:	b500      	push	{lr}
    5a46:	b085      	sub	sp, #20
    5a48:	4603      	mov	r3, r0
    5a4a:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    5a4e:	2300      	movs	r3, #0
    5a50:	9303      	str	r3, [sp, #12]
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[PortId];
    5a52:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5a56:	4a06      	ldr	r2, [pc, #24]	; (5a70 <Dio_Ipw_ReadPort+0x2c>)
    5a58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a5c:	9302      	str	r3, [sp, #8]

    PortLevel = (Dio_PortLevelType)(Gpio_Dio_Ip_ReadPins(GpioBase));
    5a5e:	9802      	ldr	r0, [sp, #8]
    5a60:	f000 f8be 	bl	5be0 <Gpio_Dio_Ip_ReadPins>
    5a64:	9003      	str	r0, [sp, #12]
#endif
#if (STD_ON == DIO_REVERSEPORTBITS)
    PortLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(PortLevel));
#endif

    return PortLevel;
    5a66:	9b03      	ldr	r3, [sp, #12]
}
    5a68:	4618      	mov	r0, r3
    5a6a:	b005      	add	sp, #20
    5a6c:	f85d fb04 	ldr.w	pc, [sp], #4
    5a70:	1fff8b24 	.word	0x1fff8b24

00005a74 <Dio_Ipw_WritePort>:
void Dio_Ipw_WritePort
(
    Dio_PortType PortId,
    Dio_PortLevelType Level
)
{
    5a74:	b500      	push	{lr}
    5a76:	b085      	sub	sp, #20
    5a78:	4603      	mov	r3, r0
    5a7a:	9100      	str	r1, [sp, #0]
    5a7c:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType CrtLevel = Level;
    5a80:	9b00      	ldr	r3, [sp, #0]
    5a82:	9303      	str	r3, [sp, #12]
    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[PortId];
    5a84:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5a88:	4a05      	ldr	r2, [pc, #20]	; (5aa0 <Dio_Ipw_WritePort+0x2c>)
    5a8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5a8e:	9302      	str	r3, [sp, #8]

#if (STD_ON == DIO_REVERSEPORTBITS)
    CrtLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(CrtLevel));
#endif /* STD_ON == DIO_REVERSEPORTBITS */
    Gpio_Dio_Ip_WritePins(GpioBase, CrtLevel);
    5a90:	9903      	ldr	r1, [sp, #12]
    5a92:	9802      	ldr	r0, [sp, #8]
    5a94:	f000 f875 	bl	5b82 <Gpio_Dio_Ip_WritePins>
}
    5a98:	bf00      	nop
    5a9a:	b005      	add	sp, #20
    5a9c:	f85d fb04 	ldr.w	pc, [sp], #4
    5aa0:	1fff8b24 	.word	0x1fff8b24

00005aa4 <Dio_Ipw_ReadChannelGroup>:
*/
Dio_PortLevelType Dio_Ipw_ReadChannelGroup
(
    const Dio_ChannelGroupType * pChannelGroupIdPtr
)
{
    5aa4:	b500      	push	{lr}
    5aa6:	b087      	sub	sp, #28
    5aa8:	9001      	str	r0, [sp, #4]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    5aaa:	2300      	movs	r3, #0
    5aac:	9305      	str	r3, [sp, #20]
    Dio_PortLevelType pinsValue;
    const GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[pChannelGroupIdPtr->port];
    5aae:	9b01      	ldr	r3, [sp, #4]
    5ab0:	781b      	ldrb	r3, [r3, #0]
    5ab2:	461a      	mov	r2, r3
    5ab4:	4b0a      	ldr	r3, [pc, #40]	; (5ae0 <Dio_Ipw_ReadChannelGroup+0x3c>)
    5ab6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5aba:	9304      	str	r3, [sp, #16]

    pinsValue = (Dio_PortLevelType)(Gpio_Dio_Ip_ReadPins(GpioBase));
    5abc:	9804      	ldr	r0, [sp, #16]
    5abe:	f000 f88f 	bl	5be0 <Gpio_Dio_Ip_ReadPins>
    5ac2:	9003      	str	r0, [sp, #12]

#if (STD_ON == DIO_REVERSEPORTBITS)
    PortLevel = (Dio_PortLevelType)((pinsValue & (pChannelGroupIdPtr->mask)) << (pChannelGroupIdPtr->u8offset));
    PortLevel = (Dio_PortLevelType)(Dio_Ipw_ReverseBits(PortLevel));
#else
    PortLevel = (Dio_PortLevelType)((pinsValue & (pChannelGroupIdPtr->mask)) >> (pChannelGroupIdPtr->u8offset));
    5ac4:	9b01      	ldr	r3, [sp, #4]
    5ac6:	685a      	ldr	r2, [r3, #4]
    5ac8:	9b03      	ldr	r3, [sp, #12]
    5aca:	4013      	ands	r3, r2
    5acc:	9a01      	ldr	r2, [sp, #4]
    5ace:	7852      	ldrb	r2, [r2, #1]
    5ad0:	40d3      	lsrs	r3, r2
    5ad2:	9305      	str	r3, [sp, #20]
#endif

    return PortLevel;
    5ad4:	9b05      	ldr	r3, [sp, #20]
}
    5ad6:	4618      	mov	r0, r3
    5ad8:	b007      	add	sp, #28
    5ada:	f85d fb04 	ldr.w	pc, [sp], #4
    5ade:	bf00      	nop
    5ae0:	1fff8b24 	.word	0x1fff8b24

00005ae4 <Dio_Ipw_WriteChannelGroup>:
void Dio_Ipw_WriteChannelGroup
(
    const Dio_ChannelGroupType * pChannelGroupIdPtr,
    Dio_PortLevelType                 Level
)
{
    5ae4:	b500      	push	{lr}
    5ae6:	b087      	sub	sp, #28
    5ae8:	9001      	str	r0, [sp, #4]
    5aea:	9100      	str	r1, [sp, #0]
    Dio_PortLevelType ValueSet;
    Dio_PortLevelType ValueClear;

    GPIO_Type * GpioBase = (GPIO_Type *)GpioBaseAdresses[pChannelGroupIdPtr->port];
    5aec:	9b01      	ldr	r3, [sp, #4]
    5aee:	781b      	ldrb	r3, [r3, #0]
    5af0:	461a      	mov	r2, r3
    5af2:	4b10      	ldr	r3, [pc, #64]	; (5b34 <Dio_Ipw_WriteChannelGroup+0x50>)
    5af4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5af8:	9305      	str	r3, [sp, #20]

#if (STD_ON == DIO_REVERSEPORTBITS)
    ValueSet = (((Dio_PortLevelType)(Dio_Ipw_ReverseBits(Level)) >> (pChannelGroupIdPtr->u8offset)) & (((Dio_PortLevelType)(pChannelGroupIdPtr->mask) )));
#else
    ValueSet = (((Dio_PortLevelType)(Level) << (pChannelGroupIdPtr->u8offset)) & (((Dio_PortLevelType)(pChannelGroupIdPtr->mask) )));
    5afa:	9b01      	ldr	r3, [sp, #4]
    5afc:	785b      	ldrb	r3, [r3, #1]
    5afe:	461a      	mov	r2, r3
    5b00:	9b00      	ldr	r3, [sp, #0]
    5b02:	fa03 f202 	lsl.w	r2, r3, r2
    5b06:	9b01      	ldr	r3, [sp, #4]
    5b08:	685b      	ldr	r3, [r3, #4]
    5b0a:	4013      	ands	r3, r2
    5b0c:	9304      	str	r3, [sp, #16]
#endif

    Gpio_Dio_Ip_SetPins(GpioBase, ValueSet);
    5b0e:	9904      	ldr	r1, [sp, #16]
    5b10:	9805      	ldr	r0, [sp, #20]
    5b12:	f000 f84a 	bl	5baa <Gpio_Dio_Ip_SetPins>
    ValueClear = (~ValueSet) & pChannelGroupIdPtr->mask;
    5b16:	9b04      	ldr	r3, [sp, #16]
    5b18:	43da      	mvns	r2, r3
    5b1a:	9b01      	ldr	r3, [sp, #4]
    5b1c:	685b      	ldr	r3, [r3, #4]
    5b1e:	4013      	ands	r3, r2
    5b20:	9303      	str	r3, [sp, #12]
    Gpio_Dio_Ip_ClearPins(GpioBase, ValueClear);
    5b22:	9903      	ldr	r1, [sp, #12]
    5b24:	9805      	ldr	r0, [sp, #20]
    5b26:	f000 f849 	bl	5bbc <Gpio_Dio_Ip_ClearPins>

}
    5b2a:	bf00      	nop
    5b2c:	b007      	add	sp, #28
    5b2e:	f85d fb04 	ldr.w	pc, [sp], #4
    5b32:	bf00      	nop
    5b34:	1fff8b24 	.word	0x1fff8b24

00005b38 <Gpio_Dio_Ip_WritePin>:
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pin,
    Gpio_Dio_Ip_PinsLevelType value
)
{
    5b38:	b500      	push	{lr}
    5b3a:	b087      	sub	sp, #28
    5b3c:	9003      	str	r0, [sp, #12]
    5b3e:	9102      	str	r1, [sp, #8]
    5b40:	4613      	mov	r3, r2
    5b42:	f88d 3007 	strb.w	r3, [sp, #7]
    /* Enter critical region */
    SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00();
    5b46:	f004 fc01 	bl	a34c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00>
    Gpio_Dio_Ip_PinsChannelType pinsValues = (Gpio_Dio_Ip_PinsChannelType)base->PDOR;
    5b4a:	9b03      	ldr	r3, [sp, #12]
    5b4c:	681b      	ldr	r3, [r3, #0]
    5b4e:	9305      	str	r3, [sp, #20]
    pinsValues &= (Gpio_Dio_Ip_PinsChannelType)(~((Gpio_Dio_Ip_PinsChannelType)1U << pin));
    5b50:	2201      	movs	r2, #1
    5b52:	9b02      	ldr	r3, [sp, #8]
    5b54:	fa02 f303 	lsl.w	r3, r2, r3
    5b58:	43db      	mvns	r3, r3
    5b5a:	9a05      	ldr	r2, [sp, #20]
    5b5c:	4013      	ands	r3, r2
    5b5e:	9305      	str	r3, [sp, #20]
    pinsValues |= (Gpio_Dio_Ip_PinsChannelType)((Gpio_Dio_Ip_PinsChannelType)value << pin);
    5b60:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5b64:	9b02      	ldr	r3, [sp, #8]
    5b66:	fa02 f303 	lsl.w	r3, r2, r3
    5b6a:	9a05      	ldr	r2, [sp, #20]
    5b6c:	4313      	orrs	r3, r2
    5b6e:	9305      	str	r3, [sp, #20]
    base->PDOR = GPIO_PDOR_PDO(pinsValues);
    5b70:	9b03      	ldr	r3, [sp, #12]
    5b72:	9a05      	ldr	r2, [sp, #20]
    5b74:	601a      	str	r2, [r3, #0]
    /* Exit critical region */
    SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00();
    5b76:	f004 fc15 	bl	a3a4 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00>
}
    5b7a:	bf00      	nop
    5b7c:	b007      	add	sp, #28
    5b7e:	f85d fb04 	ldr.w	pc, [sp], #4

00005b82 <Gpio_Dio_Ip_WritePins>:
void Gpio_Dio_Ip_WritePins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5b82:	b082      	sub	sp, #8
    5b84:	9001      	str	r0, [sp, #4]
    5b86:	9100      	str	r1, [sp, #0]
    base->PDOR = GPIO_PDOR_PDO(pins);
    5b88:	9b01      	ldr	r3, [sp, #4]
    5b8a:	9a00      	ldr	r2, [sp, #0]
    5b8c:	601a      	str	r2, [r3, #0]
}
    5b8e:	bf00      	nop
    5b90:	b002      	add	sp, #8
    5b92:	4770      	bx	lr

00005b94 <Gpio_Dio_Ip_GetPinsOutput>:
 * that are configured as output will have meaningful values.
 *
 * @implements    Gpio_Dio_Ip_GetPinsOutput_Activity
 */
Gpio_Dio_Ip_PinsChannelType Gpio_Dio_Ip_GetPinsOutput(const GPIO_Type * const base)
{
    5b94:	b084      	sub	sp, #16
    5b96:	9001      	str	r0, [sp, #4]
    Gpio_Dio_Ip_PinsChannelType returnValue = 0U;
    5b98:	2300      	movs	r3, #0
    5b9a:	9303      	str	r3, [sp, #12]
    returnValue = (Gpio_Dio_Ip_PinsChannelType)(base->PDOR);
    5b9c:	9b01      	ldr	r3, [sp, #4]
    5b9e:	681b      	ldr	r3, [r3, #0]
    5ba0:	9303      	str	r3, [sp, #12]
    return returnValue;
    5ba2:	9b03      	ldr	r3, [sp, #12]
}
    5ba4:	4618      	mov	r0, r3
    5ba6:	b004      	add	sp, #16
    5ba8:	4770      	bx	lr

00005baa <Gpio_Dio_Ip_SetPins>:
void Gpio_Dio_Ip_SetPins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5baa:	b082      	sub	sp, #8
    5bac:	9001      	str	r0, [sp, #4]
    5bae:	9100      	str	r1, [sp, #0]
    base->PSOR = GPIO_PSOR_PTSO(pins);
    5bb0:	9b01      	ldr	r3, [sp, #4]
    5bb2:	9a00      	ldr	r2, [sp, #0]
    5bb4:	605a      	str	r2, [r3, #4]
}
    5bb6:	bf00      	nop
    5bb8:	b002      	add	sp, #8
    5bba:	4770      	bx	lr

00005bbc <Gpio_Dio_Ip_ClearPins>:
void Gpio_Dio_Ip_ClearPins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5bbc:	b082      	sub	sp, #8
    5bbe:	9001      	str	r0, [sp, #4]
    5bc0:	9100      	str	r1, [sp, #0]
    base->PCOR = GPIO_PCOR_PTCO(pins);
    5bc2:	9b01      	ldr	r3, [sp, #4]
    5bc4:	9a00      	ldr	r2, [sp, #0]
    5bc6:	609a      	str	r2, [r3, #8]
}
    5bc8:	bf00      	nop
    5bca:	b002      	add	sp, #8
    5bcc:	4770      	bx	lr

00005bce <Gpio_Dio_Ip_TogglePins>:
void Gpio_Dio_Ip_TogglePins
(
    GPIO_Type * const base,
    Gpio_Dio_Ip_PinsChannelType pins
)
{
    5bce:	b082      	sub	sp, #8
    5bd0:	9001      	str	r0, [sp, #4]
    5bd2:	9100      	str	r1, [sp, #0]
    base->PTOR = GPIO_PTOR_PTTO(pins);
    5bd4:	9b01      	ldr	r3, [sp, #4]
    5bd6:	9a00      	ldr	r2, [sp, #0]
    5bd8:	60da      	str	r2, [r3, #12]
}
    5bda:	bf00      	nop
    5bdc:	b002      	add	sp, #8
    5bde:	4770      	bx	lr

00005be0 <Gpio_Dio_Ip_ReadPins>:
 * configured as input will have meaningful values.
 *
 * @implements    Gpio_Dio_Ip_ReadPins_Activity
 */
Gpio_Dio_Ip_PinsChannelType Gpio_Dio_Ip_ReadPins(const GPIO_Type * const base)
{
    5be0:	b084      	sub	sp, #16
    5be2:	9001      	str	r0, [sp, #4]
    Gpio_Dio_Ip_PinsChannelType returnValue = 0U;
    5be4:	2300      	movs	r3, #0
    5be6:	9303      	str	r3, [sp, #12]
    returnValue = (Gpio_Dio_Ip_PinsChannelType)(base->PDIR);
    5be8:	9b01      	ldr	r3, [sp, #4]
    5bea:	691b      	ldr	r3, [r3, #16]
    5bec:	9303      	str	r3, [sp, #12]
    return returnValue;
    5bee:	9b03      	ldr	r3, [sp, #12]
}
    5bf0:	4618      	mov	r0, r3
    5bf2:	b004      	add	sp, #16
    5bf4:	4770      	bx	lr

00005bf6 <Gpio_Dio_Ip_ReadPin>:
 * configured as input will have meaningful value.
 *
 * @implements    Gpio_Dio_Ip_ReadPin_Activity
 */
Gpio_Dio_Ip_PinsLevelType Gpio_Dio_Ip_ReadPin(const GPIO_Type * const base, Gpio_Dio_Ip_PinsChannelType pin)
{
    5bf6:	b084      	sub	sp, #16
    5bf8:	9001      	str	r0, [sp, #4]
    5bfa:	9100      	str	r1, [sp, #0]
    Gpio_Dio_Ip_PinsLevelType returnValue = 0U;
    5bfc:	2300      	movs	r3, #0
    5bfe:	f88d 300f 	strb.w	r3, [sp, #15]
    returnValue  = (Gpio_Dio_Ip_PinsLevelType)(((base->PDIR)&((uint32)1<<pin))>>(pin));
    5c02:	9b01      	ldr	r3, [sp, #4]
    5c04:	691a      	ldr	r2, [r3, #16]
    5c06:	2101      	movs	r1, #1
    5c08:	9b00      	ldr	r3, [sp, #0]
    5c0a:	fa01 f303 	lsl.w	r3, r1, r3
    5c0e:	401a      	ands	r2, r3
    5c10:	9b00      	ldr	r3, [sp, #0]
    5c12:	fa22 f303 	lsr.w	r3, r2, r3
    5c16:	f88d 300f 	strb.w	r3, [sp, #15]

    return returnValue;
    5c1a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5c1e:	4618      	mov	r0, r3
    5c20:	b004      	add	sp, #16
    5c22:	4770      	bx	lr

00005c24 <Dio_ReadChannel>:
*/
Dio_LevelType Dio_ReadChannel
(
    Dio_ChannelType ChannelId
)
{
    5c24:	b500      	push	{lr}
    5c26:	b085      	sub	sp, #20
    5c28:	4603      	mov	r3, r0
    5c2a:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    5c2e:	2300      	movs	r3, #0
    5c30:	f88d 300f 	strb.w	r3, [sp, #15]
    Std_ReturnType Valid = Dio_ValidateChannelForRead(ChannelId, DIO_READCHANNEL_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        ChannelLevel = Dio_Ipw_ReadChannel(ChannelId);
    5c34:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5c38:	4618      	mov	r0, r3
    5c3a:	f7ff fe81 	bl	5940 <Dio_Ipw_ReadChannel>
    5c3e:	4603      	mov	r3, r0
    5c40:	f88d 300f 	strb.w	r3, [sp, #15]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

    return ChannelLevel;
    5c44:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5c48:	4618      	mov	r0, r3
    5c4a:	b005      	add	sp, #20
    5c4c:	f85d fb04 	ldr.w	pc, [sp], #4

00005c50 <Dio_WriteChannel>:
void Dio_WriteChannel
(
    Dio_ChannelType ChannelId,
    Dio_LevelType Level
)
{
    5c50:	b500      	push	{lr}
    5c52:	b083      	sub	sp, #12
    5c54:	4603      	mov	r3, r0
    5c56:	460a      	mov	r2, r1
    5c58:	f8ad 3006 	strh.w	r3, [sp, #6]
    5c5c:	4613      	mov	r3, r2
    5c5e:	f88d 3005 	strb.w	r3, [sp, #5]
    {
        Valid = Dio_ValidateChannelLevel(Level);
        if ((Std_ReturnType) E_OK == Valid)
        {
#endif
            Dio_Ipw_WriteChannel(ChannelId, Level);
    5c62:	f89d 2005 	ldrb.w	r2, [sp, #5]
    5c66:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5c6a:	4611      	mov	r1, r2
    5c6c:	4618      	mov	r0, r3
    5c6e:	f7ff fe8d 	bl	598c <Dio_Ipw_WriteChannel>
#if (STD_ON == DIO_DEV_ERROR_DETECT)
        }
    }
#endif

}
    5c72:	bf00      	nop
    5c74:	b003      	add	sp, #12
    5c76:	f85d fb04 	ldr.w	pc, [sp], #4

00005c7a <Dio_FlipChannel>:
*/
Dio_LevelType Dio_FlipChannel
(
    Dio_ChannelType ChannelId
)
{
    5c7a:	b500      	push	{lr}
    5c7c:	b085      	sub	sp, #20
    5c7e:	4603      	mov	r3, r0
    5c80:	f8ad 3006 	strh.w	r3, [sp, #6]
    Dio_LevelType ChannelLevel = (Dio_LevelType)STD_LOW;
    5c84:	2300      	movs	r3, #0
    5c86:	f88d 300f 	strb.w	r3, [sp, #15]
    Std_ReturnType Valid = Dio_ValidateChannelForWrite(ChannelId, DIO_FLIPCHANNEL_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        ChannelLevel = Dio_Ipw_FlipChannel(ChannelId);
    5c8a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    5c8e:	4618      	mov	r0, r3
    5c90:	f7ff fea2 	bl	59d8 <Dio_Ipw_FlipChannel>
    5c94:	4603      	mov	r3, r0
    5c96:	f88d 300f 	strb.w	r3, [sp, #15]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

   return ChannelLevel;
    5c9a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5c9e:	4618      	mov	r0, r3
    5ca0:	b005      	add	sp, #20
    5ca2:	f85d fb04 	ldr.w	pc, [sp], #4

00005ca6 <Dio_ReadPort>:
*/
Dio_PortLevelType Dio_ReadPort
(
    Dio_PortType PortId
)
{
    5ca6:	b500      	push	{lr}
    5ca8:	b085      	sub	sp, #20
    5caa:	4603      	mov	r3, r0
    5cac:	f88d 3007 	strb.w	r3, [sp, #7]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    5cb0:	2300      	movs	r3, #0
    5cb2:	9303      	str	r3, [sp, #12]
    Std_ReturnType Valid = Dio_ValidatePortForRead(PortId, DIO_READPORT_ID);

    if ((Std_ReturnType) E_OK == Valid)
    {
#endif
        PortLevel = Dio_Ipw_ReadPort(PortId);
    5cb4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5cb8:	4618      	mov	r0, r3
    5cba:	f7ff fec3 	bl	5a44 <Dio_Ipw_ReadPort>
    5cbe:	9003      	str	r0, [sp, #12]
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif

    return PortLevel;
    5cc0:	9b03      	ldr	r3, [sp, #12]
}
    5cc2:	4618      	mov	r0, r3
    5cc4:	b005      	add	sp, #20
    5cc6:	f85d fb04 	ldr.w	pc, [sp], #4

00005cca <Dio_WritePort>:
void Dio_WritePort
(
    Dio_PortType PortId,
    Dio_PortLevelType Level
)
{
    5cca:	b500      	push	{lr}
    5ccc:	b083      	sub	sp, #12
    5cce:	4603      	mov	r3, r0
    5cd0:	9100      	str	r1, [sp, #0]
    5cd2:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType Valid = Dio_ValidatePortForWrite(PortId, DIO_WRITEPORT_ID);

    if ((Std_ReturnType)E_OK == Valid)
    {
#endif
        Dio_Ipw_WritePort(PortId, Level);
    5cd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5cda:	9900      	ldr	r1, [sp, #0]
    5cdc:	4618      	mov	r0, r3
    5cde:	f7ff fec9 	bl	5a74 <Dio_Ipw_WritePort>
#if (STD_ON == DIO_DEV_ERROR_DETECT)
    }
#endif
}
    5ce2:	bf00      	nop
    5ce4:	b003      	add	sp, #12
    5ce6:	f85d fb04 	ldr.w	pc, [sp], #4

00005cea <Dio_ReadChannelGroup>:
*/
Dio_PortLevelType Dio_ReadChannelGroup
(
    const Dio_ChannelGroupType * ChannelGroupIdPtr
)
{
    5cea:	b500      	push	{lr}
    5cec:	b085      	sub	sp, #20
    5cee:	9001      	str	r0, [sp, #4]
    Dio_PortLevelType PortLevel = (Dio_PortLevelType)STD_LOW;
    5cf0:	2300      	movs	r3, #0
    5cf2:	9303      	str	r3, [sp, #12]
        }
        if ((uint8)1 == GroupAlocated)
        {
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
#endif /* DIO_DEV_ERROR_DETECT */
            PortLevel = Dio_Ipw_ReadChannelGroup(ChannelGroupIdPtr);
    5cf4:	9801      	ldr	r0, [sp, #4]
    5cf6:	f7ff fed5 	bl	5aa4 <Dio_Ipw_ReadChannelGroup>
    5cfa:	9003      	str	r0, [sp, #12]
        }
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
    }
#endif /* DIO_DEV_ERROR_DETECT */

    return PortLevel;
    5cfc:	9b03      	ldr	r3, [sp, #12]
}
    5cfe:	4618      	mov	r0, r3
    5d00:	b005      	add	sp, #20
    5d02:	f85d fb04 	ldr.w	pc, [sp], #4

00005d06 <Dio_WriteChannelGroup>:
void Dio_WriteChannelGroup
(
    const Dio_ChannelGroupType * ChannelGroupIdPtr,
    Dio_PortLevelType Level
)
{
    5d06:	b500      	push	{lr}
    5d08:	b083      	sub	sp, #12
    5d0a:	9001      	str	r0, [sp, #4]
    5d0c:	9100      	str	r1, [sp, #0]
        }
        if ((uint8)1 == GroupAlocated)
        {
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
#endif /* DIO_DEV_ERROR_DETECT */
            Dio_Ipw_WriteChannelGroup(ChannelGroupIdPtr, Level);
    5d0e:	9900      	ldr	r1, [sp, #0]
    5d10:	9801      	ldr	r0, [sp, #4]
    5d12:	f7ff fee7 	bl	5ae4 <Dio_Ipw_WriteChannelGroup>
            (void)Det_ReportError((uint16)DIO_MODULE_ID, DIO_INSTANCE_ID, DIO_WRITECHANNELGROUP_ID, DIO_E_PARAM_CONFIG);
        }
#endif /* DIO_CHANNEL_GROUPS_AVAILABLE */
    }
#endif /* DIO_DEV_ERROR_DETECT */
}
    5d16:	bf00      	nop
    5d18:	b003      	add	sp, #12
    5d1a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005d20 <Gpt_ValidateChannelStatus>:
(
    uint8 u8ServiceId,
    Gpt_ChannelType channel,
    uint32 coreID
)
{
    5d20:	b500      	push	{lr}
    5d22:	b085      	sub	sp, #20
    5d24:	4603      	mov	r3, r0
    5d26:	9200      	str	r2, [sp, #0]
    5d28:	f88d 3007 	strb.w	r3, [sp, #7]
    5d2c:	460b      	mov	r3, r1
    5d2e:	f88d 3006 	strb.w	r3, [sp, #6]
    Std_ReturnType returnValue = (Std_ReturnType)E_NOT_OK;
    5d32:	2301      	movs	r3, #1
    5d34:	f88d 300f 	strb.w	r3, [sp, #15]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(u8ServiceId, channel, coreID))
    {
#endif
        if(channel < GPT_HW_CHANNEL_NUM)
    5d38:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5d3c:	2b00      	cmp	r3, #0
    5d3e:	d113      	bne.n	5d68 <Gpt_ValidateChannelStatus+0x48>
                    );
                }
                else
                {
    #else
                    if (GPT_STATUS_RUNNING == Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    5d40:	f89d 2006 	ldrb.w	r2, [sp, #6]
    5d44:	490b      	ldr	r1, [pc, #44]	; (5d74 <Gpt_ValidateChannelStatus+0x54>)
    5d46:	9b00      	ldr	r3, [sp, #0]
    5d48:	4413      	add	r3, r2
    5d4a:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    5d4e:	2b04      	cmp	r3, #4
    5d50:	d107      	bne.n	5d62 <Gpt_ValidateChannelStatus+0x42>
                    {
                        (void)Det_ReportRuntimeError\
    5d52:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5d56:	230b      	movs	r3, #11
    5d58:	2100      	movs	r1, #0
    5d5a:	2064      	movs	r0, #100	; 0x64
    5d5c:	f004 fbd6 	bl	a50c <Det_ReportRuntimeError>
    5d60:	e002      	b.n	5d68 <Gpt_ValidateChannelStatus+0x48>
                        );
                    }
                    else
                    {
    #endif
                        returnValue = (Std_ReturnType)E_OK;
    5d62:	2300      	movs	r3, #0
    5d64:	f88d 300f 	strb.w	r3, [sp, #15]
    #endif
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
    return returnValue;
    5d68:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5d6c:	4618      	mov	r0, r3
    5d6e:	b005      	add	sp, #20
    5d70:	f85d fb04 	ldr.w	pc, [sp], #4
    5d74:	1fff8d20 	.word	0x1fff8d20

00005d78 <Gpt_ConvertChannelIndexToChannel>:
 *
 * */
static inline Gpt_ChannelType Gpt_ConvertChannelIndexToChannel(Gpt_ChannelType ChannelIndex,
                                                                              uint32 coreID
                                                                              )
{
    5d78:	b084      	sub	sp, #16
    5d7a:	4603      	mov	r3, r0
    5d7c:	9100      	str	r1, [sp, #0]
    5d7e:	f88d 3007 	strb.w	r3, [sp, #7]
    Gpt_ChannelType Channel;

    for (Channel = 0U; Channel < GPT_HW_CHANNEL_NUM; ++Channel)
    5d82:	2300      	movs	r3, #0
    5d84:	f88d 300f 	strb.w	r3, [sp, #15]
    5d88:	e010      	b.n	5dac <Gpt_ConvertChannelIndexToChannel+0x34>
    {
        if(ChannelIndex == (*Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap)[Channel])
    5d8a:	4a0e      	ldr	r2, [pc, #56]	; (5dc4 <Gpt_ConvertChannelIndexToChannel+0x4c>)
    5d8c:	9b00      	ldr	r3, [sp, #0]
    5d8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5d92:	691a      	ldr	r2, [r3, #16]
    5d94:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5d98:	5cd3      	ldrb	r3, [r2, r3]
    5d9a:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5d9e:	429a      	cmp	r2, r3
    5da0:	d009      	beq.n	5db6 <Gpt_ConvertChannelIndexToChannel+0x3e>
    for (Channel = 0U; Channel < GPT_HW_CHANNEL_NUM; ++Channel)
    5da2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5da6:	3301      	adds	r3, #1
    5da8:	f88d 300f 	strb.w	r3, [sp, #15]
    5dac:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5db0:	2b00      	cmp	r3, #0
    5db2:	d0ea      	beq.n	5d8a <Gpt_ConvertChannelIndexToChannel+0x12>
    5db4:	e000      	b.n	5db8 <Gpt_ConvertChannelIndexToChannel+0x40>
        {
            break;
    5db6:	bf00      	nop
        }
    }
    return Channel;
    5db8:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5dbc:	4618      	mov	r0, r3
    5dbe:	b004      	add	sp, #16
    5dc0:	4770      	bx	lr
    5dc2:	bf00      	nop
    5dc4:	1fff8d1c 	.word	0x1fff8d1c

00005dc8 <Gpt_Init>:
*
* @pre            The data structure including the configuration set required for initializing the GPT driver..
* @implements     Gpt_Init_Activity
*/
void Gpt_Init(const Gpt_ConfigType * configPtr)
{
    5dc8:	b500      	push	{lr}
    5dca:	b087      	sub	sp, #28
    5dcc:	9001      	str	r0, [sp, #4]
    Gpt_ChannelType ChannelIndex;
    Gpt_ChannelType channel;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    5dce:	2300      	movs	r3, #0
    5dd0:	9304      	str	r3, [sp, #16]
        #else
            Gpt_pConfig[coreID] = &Gpt_Config;
        #endif
            (void)configPtr;
    #else
            Gpt_pConfig[coreID] = configPtr;
    5dd2:	492f      	ldr	r1, [pc, #188]	; (5e90 <Gpt_Init+0xc8>)
    5dd4:	9b04      	ldr	r3, [sp, #16]
    5dd6:	9a01      	ldr	r2, [sp, #4]
    5dd8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

#if(GPT_PREDEFTIMER_FUNCTIONALITY_API == STD_ON)
            /*Initialize and Start Predef Timers.*/
            Gpt_Ipw_StartPredefTimer(Gpt_pConfig[coreID]);
#endif
            Gpt_Ipw_InitInstances(Gpt_pConfig[coreID]);
    5ddc:	4a2c      	ldr	r2, [pc, #176]	; (5e90 <Gpt_Init+0xc8>)
    5dde:	9b04      	ldr	r3, [sp, #16]
    5de0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5de4:	4618      	mov	r0, r3
    5de6:	f000 ff61 	bl	6cac <Gpt_Ipw_InitInstances>

            /*Initialize for each channel the runtime status informations.*/
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    5dea:	2300      	movs	r3, #0
    5dec:	f88d 3017 	strb.w	r3, [sp, #23]
    5df0:	e03b      	b.n	5e6a <Gpt_Init+0xa2>
            {
                channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    5df2:	f89d 3017 	ldrb.w	r3, [sp, #23]
    5df6:	9904      	ldr	r1, [sp, #16]
    5df8:	4618      	mov	r0, r3
    5dfa:	f7ff ffbd 	bl	5d78 <Gpt_ConvertChannelIndexToChannel>
    5dfe:	4603      	mov	r3, r0
    5e00:	f88d 300f 	strb.w	r3, [sp, #15]
                if(channel < GPT_HW_CHANNEL_NUM)
    5e04:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5e08:	2b00      	cmp	r3, #0
    5e0a:	d118      	bne.n	5e3e <Gpt_Init+0x76>
                {
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
                    /*Disable notification*/
                    Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = FALSE;
    5e0c:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5e10:	4920      	ldr	r1, [pc, #128]	; (5e94 <Gpt_Init+0xcc>)
    5e12:	9b04      	ldr	r3, [sp, #16]
    5e14:	4413      	add	r3, r2
    5e16:	00db      	lsls	r3, r3, #3
    5e18:	440b      	add	r3, r1
    5e1a:	2200      	movs	r2, #0
    5e1c:	711a      	strb	r2, [r3, #4]
                    Gpt_aChannelInfo[coreID][channel].bWakeupEnabled = FALSE;
                    /*Clear wakeup generation status*/
                    Gpt_aChannelInfo[coreID][channel].bWakeupGenerated = FALSE;
#endif
                    /* Initialize the running information of the channel*/
                    Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_INITIALIZED;
    5e1e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5e22:	491c      	ldr	r1, [pc, #112]	; (5e94 <Gpt_Init+0xcc>)
    5e24:	9b04      	ldr	r3, [sp, #16]
    5e26:	4413      	add	r3, r2
    5e28:	2201      	movs	r2, #1
    5e2a:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                    Gpt_aStopTime[coreID][channel] = 0U;
    5e2e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5e32:	4919      	ldr	r1, [pc, #100]	; (5e98 <Gpt_Init+0xd0>)
    5e34:	9b04      	ldr	r3, [sp, #16]
    5e36:	4413      	add	r3, r2
    5e38:	2200      	movs	r2, #0
    5e3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
                }

                /*Initialize hardware timer channel.*/
                Gpt_Ipw_Init(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig));
    5e3e:	4a14      	ldr	r2, [pc, #80]	; (5e90 <Gpt_Init+0xc8>)
    5e40:	9b04      	ldr	r3, [sp, #16]
    5e42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e46:	6859      	ldr	r1, [r3, #4]
    5e48:	f89d 2017 	ldrb.w	r2, [sp, #23]
    5e4c:	4613      	mov	r3, r2
    5e4e:	009b      	lsls	r3, r3, #2
    5e50:	4413      	add	r3, r2
    5e52:	009b      	lsls	r3, r3, #2
    5e54:	440b      	add	r3, r1
    5e56:	3310      	adds	r3, #16
    5e58:	681b      	ldr	r3, [r3, #0]
    5e5a:	4618      	mov	r0, r3
    5e5c:	f000 ff5d 	bl	6d1a <Gpt_Ipw_Init>
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    5e60:	f89d 3017 	ldrb.w	r3, [sp, #23]
    5e64:	3301      	adds	r3, #1
    5e66:	f88d 3017 	strb.w	r3, [sp, #23]
    5e6a:	4a09      	ldr	r2, [pc, #36]	; (5e90 <Gpt_Init+0xc8>)
    5e6c:	9b04      	ldr	r3, [sp, #16]
    5e6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5e72:	781b      	ldrb	r3, [r3, #0]
    5e74:	f89d 2017 	ldrb.w	r2, [sp, #23]
    5e78:	429a      	cmp	r2, r3
    5e7a:	d3ba      	bcc.n	5df2 <Gpt_Init+0x2a>
            }
#if (((GPT_WAKEUP_FUNCTIONALITY_API == STD_ON) && (GPT_REPORT_WAKEUP_SOURCE == STD_ON)) || \
     (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON) || \
     (GPT_PREDEFTIMER_FUNCTIONALITY_API == STD_ON))
            /*Set the driver to normal mode*/
            Gpt_eMode[coreID] = GPT_MODE_NORMAL;
    5e7c:	4a07      	ldr	r2, [pc, #28]	; (5e9c <Gpt_Init+0xd4>)
    5e7e:	9b04      	ldr	r3, [sp, #16]
    5e80:	2100      	movs	r1, #0
    5e82:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }
#endif
#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    }
#endif
    return;
    5e86:	bf00      	nop
}
    5e88:	b007      	add	sp, #28
    5e8a:	f85d fb04 	ldr.w	pc, [sp], #4
    5e8e:	bf00      	nop
    5e90:	1fff8d1c 	.word	0x1fff8d1c
    5e94:	1fff8d20 	.word	0x1fff8d20
    5e98:	1fff8d28 	.word	0x1fff8d28
    5e9c:	1fff8d18 	.word	0x1fff8d18

00005ea0 <Gpt_DeInit>:
* @return  void
*
* @implements   Gpt_DeInit_Activity
*/
void Gpt_DeInit(void)
{
    5ea0:	b500      	push	{lr}
    5ea2:	b085      	sub	sp, #20
    Gpt_ChannelType channel;
    Gpt_ChannelType ChannelIndex;

    Std_ReturnType allChannelStatus = (Std_ReturnType)E_OK;
    5ea4:	2300      	movs	r3, #0
    5ea6:	f88d 300e 	strb.w	r3, [sp, #14]
    uint32 coreID = (uint32)Gpt_GetCoreID();
    5eaa:	2300      	movs	r3, #0
    5eac:	9302      	str	r3, [sp, #8]
    /*Validate if the calling context is valid*/
    if((Std_ReturnType)E_OK == Gpt_ValidateGlobalCall(GPT_DEINIT_ID, coreID))
    {
#endif
        /* Initialize for each channel the runtime status informations.*/
        for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    5eae:	2300      	movs	r3, #0
    5eb0:	f88d 300f 	strb.w	r3, [sp, #15]
    5eb4:	e01b      	b.n	5eee <Gpt_DeInit+0x4e>
        {
            channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    5eb6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5eba:	9902      	ldr	r1, [sp, #8]
    5ebc:	4618      	mov	r0, r3
    5ebe:	f7ff ff5b 	bl	5d78 <Gpt_ConvertChannelIndexToChannel>
    5ec2:	4603      	mov	r3, r0
    5ec4:	f88d 3007 	strb.w	r3, [sp, #7]
            /*Check if the channel is not running.*/
            if((Std_ReturnType)E_NOT_OK == Gpt_ValidateChannelStatus(GPT_DEINIT_ID, channel, coreID))
    5ec8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5ecc:	9a02      	ldr	r2, [sp, #8]
    5ece:	4619      	mov	r1, r3
    5ed0:	2002      	movs	r0, #2
    5ed2:	f7ff ff25 	bl	5d20 <Gpt_ValidateChannelStatus>
    5ed6:	4603      	mov	r3, r0
    5ed8:	2b01      	cmp	r3, #1
    5eda:	d103      	bne.n	5ee4 <Gpt_DeInit+0x44>
            {
                allChannelStatus = (Std_ReturnType)E_NOT_OK;
    5edc:	2301      	movs	r3, #1
    5ede:	f88d 300e 	strb.w	r3, [sp, #14]
                break;
    5ee2:	e00d      	b.n	5f00 <Gpt_DeInit+0x60>
        for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    5ee4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5ee8:	3301      	adds	r3, #1
    5eea:	f88d 300f 	strb.w	r3, [sp, #15]
    5eee:	4a30      	ldr	r2, [pc, #192]	; (5fb0 <Gpt_DeInit+0x110>)
    5ef0:	9b02      	ldr	r3, [sp, #8]
    5ef2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ef6:	781b      	ldrb	r3, [r3, #0]
    5ef8:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5efc:	429a      	cmp	r2, r3
    5efe:	d3da      	bcc.n	5eb6 <Gpt_DeInit+0x16>
            }
        }

        if((Std_ReturnType)E_OK == allChannelStatus)
    5f00:	f89d 300e 	ldrb.w	r3, [sp, #14]
    5f04:	2b00      	cmp	r3, #0
    5f06:	d14e      	bne.n	5fa6 <Gpt_DeInit+0x106>
        {
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    5f08:	2300      	movs	r3, #0
    5f0a:	f88d 300f 	strb.w	r3, [sp, #15]
    5f0e:	e03b      	b.n	5f88 <Gpt_DeInit+0xe8>
            {
                channel = Gpt_ConvertChannelIndexToChannel(ChannelIndex, coreID);
    5f10:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f14:	9902      	ldr	r1, [sp, #8]
    5f16:	4618      	mov	r0, r3
    5f18:	f7ff ff2e 	bl	5d78 <Gpt_ConvertChannelIndexToChannel>
    5f1c:	4603      	mov	r3, r0
    5f1e:	f88d 3007 	strb.w	r3, [sp, #7]
                if(channel < GPT_HW_CHANNEL_NUM)
    5f22:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5f26:	2b00      	cmp	r3, #0
    5f28:	d129      	bne.n	5f7e <Gpt_DeInit+0xde>
                {
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
                    /*Disable notification*/
                    Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = FALSE;
    5f2a:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5f2e:	4921      	ldr	r1, [pc, #132]	; (5fb4 <Gpt_DeInit+0x114>)
    5f30:	9b02      	ldr	r3, [sp, #8]
    5f32:	4413      	add	r3, r2
    5f34:	00db      	lsls	r3, r3, #3
    5f36:	440b      	add	r3, r1
    5f38:	2200      	movs	r2, #0
    5f3a:	711a      	strb	r2, [r3, #4]
                    Gpt_aChannelInfo[coreID][channel].bWakeupEnabled = FALSE;
                    /*Clear wakeup generation status*/
                    Gpt_aChannelInfo[coreID][channel].bWakeupGenerated = FALSE;
#endif
                    /* De initialize the running information of the channel*/
                    Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_UNINITIALIZED;
    5f3c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5f40:	491c      	ldr	r1, [pc, #112]	; (5fb4 <Gpt_DeInit+0x114>)
    5f42:	9b02      	ldr	r3, [sp, #8]
    5f44:	4413      	add	r3, r2
    5f46:	2200      	movs	r2, #0
    5f48:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                    Gpt_aStopTime[coreID][channel] = 0U;
    5f4c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5f50:	4919      	ldr	r1, [pc, #100]	; (5fb8 <Gpt_DeInit+0x118>)
    5f52:	9b02      	ldr	r3, [sp, #8]
    5f54:	4413      	add	r3, r2
    5f56:	2200      	movs	r2, #0
    5f58:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
                    /*Initialize hardware timer channel.*/
                    Gpt_Ipw_DeInit
                    (
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    5f5c:	4a14      	ldr	r2, [pc, #80]	; (5fb0 <Gpt_DeInit+0x110>)
    5f5e:	9b02      	ldr	r3, [sp, #8]
    5f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f64:	6859      	ldr	r1, [r3, #4]
                    Gpt_Ipw_DeInit
    5f66:	f89d 200f 	ldrb.w	r2, [sp, #15]
                        ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    5f6a:	4613      	mov	r3, r2
    5f6c:	009b      	lsls	r3, r3, #2
    5f6e:	4413      	add	r3, r2
    5f70:	009b      	lsls	r3, r3, #2
    5f72:	440b      	add	r3, r1
    5f74:	3310      	adds	r3, #16
    5f76:	681b      	ldr	r3, [r3, #0]
                    Gpt_Ipw_DeInit
    5f78:	4618      	mov	r0, r3
    5f7a:	f000 ff36 	bl	6dea <Gpt_Ipw_DeInit>
            for (ChannelIndex = 0U; ChannelIndex < Gpt_pConfig[coreID]->channelCount; ChannelIndex++)
    5f7e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f82:	3301      	adds	r3, #1
    5f84:	f88d 300f 	strb.w	r3, [sp, #15]
    5f88:	4a09      	ldr	r2, [pc, #36]	; (5fb0 <Gpt_DeInit+0x110>)
    5f8a:	9b02      	ldr	r3, [sp, #8]
    5f8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f90:	781b      	ldrb	r3, [r3, #0]
    5f92:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5f96:	429a      	cmp	r2, r3
    5f98:	d3ba      	bcc.n	5f10 <Gpt_DeInit+0x70>
            /* Deinitialize and stop Predef timers.*/
            Gpt_Ipw_StopPredefTimer(Gpt_pConfig[coreID]);
#endif
            /* Writing NULL to configuration pointer is mandatory because that variable
            is used to test the initialization of the driver */
            Gpt_pConfig[coreID] = NULL_PTR;
    5f9a:	4a05      	ldr	r2, [pc, #20]	; (5fb0 <Gpt_DeInit+0x110>)
    5f9c:	9b02      	ldr	r3, [sp, #8]
    5f9e:	2100      	movs	r1, #0
    5fa0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }

#if (GPT_VALIDATE_GLOBAL_CALL == STD_ON)
    }
#endif
    return;
    5fa4:	bf00      	nop
    5fa6:	bf00      	nop
}
    5fa8:	b005      	add	sp, #20
    5faa:	f85d fb04 	ldr.w	pc, [sp], #4
    5fae:	bf00      	nop
    5fb0:	1fff8d1c 	.word	0x1fff8d1c
    5fb4:	1fff8d20 	.word	0x1fff8d20
    5fb8:	1fff8d28 	.word	0x1fff8d28

00005fbc <Gpt_GetTimeElapsed>:
*
* @pre     The driver needs to be initialized.
* @implements Gpt_GetTimeElapsed_Activity
*/
Gpt_ValueType Gpt_GetTimeElapsed(Gpt_ChannelType channel)
{
    5fbc:	b500      	push	{lr}
    5fbe:	b089      	sub	sp, #36	; 0x24
    5fc0:	4603      	mov	r3, r0
    5fc2:	f88d 3007 	strb.w	r3, [sp, #7]
	Gpt_HwChannelInfoType returnHwChannelInfo = {FALSE, 0U};
    5fc6:	2300      	movs	r3, #0
    5fc8:	f88d 3008 	strb.w	r3, [sp, #8]
    5fcc:	2300      	movs	r3, #0
    5fce:	9303      	str	r3, [sp, #12]
	Gpt_HwChannelInfoType * pRetHwChannelInfo = &returnHwChannelInfo;
    5fd0:	ab02      	add	r3, sp, #8
    5fd2:	9306      	str	r3, [sp, #24]
    Gpt_ChannelType ChannelIndex;

    Gpt_ValueType returnValue = 0U;
    5fd4:	2300      	movs	r3, #0
    5fd6:	9307      	str	r3, [sp, #28]
    uint32 coreID = (uint32)Gpt_GetCoreID();
    5fd8:	2300      	movs	r3, #0
    5fda:	9305      	str	r3, [sp, #20]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(GPT_TIMEELAPSED_ID, channel, coreID))
    {
#endif
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    5fdc:	4a2f      	ldr	r2, [pc, #188]	; (609c <Gpt_GetTimeElapsed+0xe0>)
    5fde:	9b05      	ldr	r3, [sp, #20]
    5fe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5fe4:	691a      	ldr	r2, [r3, #16]
    5fe6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5fea:	5cd3      	ldrb	r3, [r2, r3]
    5fec:	f88d 3013 	strb.w	r3, [sp, #19]
        /*Gpt_Ipw_GetTimeElapsed() shall be called first, because the occurred ISRs can change
        the logical channel state between the checking of logical channel state and timestamp
        retrieval*/
        returnValue = Gpt_Ipw_GetTimeElapsed((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)), pRetHwChannelInfo);
    5ff0:	4a2a      	ldr	r2, [pc, #168]	; (609c <Gpt_GetTimeElapsed+0xe0>)
    5ff2:	9b05      	ldr	r3, [sp, #20]
    5ff4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5ff8:	6859      	ldr	r1, [r3, #4]
    5ffa:	f89d 2013 	ldrb.w	r2, [sp, #19]
    5ffe:	4613      	mov	r3, r2
    6000:	009b      	lsls	r3, r3, #2
    6002:	4413      	add	r3, r2
    6004:	009b      	lsls	r3, r3, #2
    6006:	440b      	add	r3, r1
    6008:	3310      	adds	r3, #16
    600a:	681b      	ldr	r3, [r3, #0]
    600c:	9906      	ldr	r1, [sp, #24]
    600e:	4618      	mov	r0, r3
    6010:	f000 feb7 	bl	6d82 <Gpt_Ipw_GetTimeElapsed>
    6014:	9007      	str	r0, [sp, #28]

        /*Check the channel status*/
        switch(Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6016:	f89d 2007 	ldrb.w	r2, [sp, #7]
    601a:	4921      	ldr	r1, [pc, #132]	; (60a0 <Gpt_GetTimeElapsed+0xe4>)
    601c:	9b05      	ldr	r3, [sp, #20]
    601e:	4413      	add	r3, r2
    6020:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6024:	3b01      	subs	r3, #1
    6026:	2b03      	cmp	r3, #3
    6028:	d830      	bhi.n	608c <Gpt_GetTimeElapsed+0xd0>
    602a:	a201      	add	r2, pc, #4	; (adr r2, 6030 <Gpt_GetTimeElapsed+0x74>)
    602c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6030:	0000606f 	.word	0x0000606f
    6034:	00006075 	.word	0x00006075
    6038:	00006087 	.word	0x00006087
    603c:	00006041 	.word	0x00006041
        {
            case GPT_STATUS_RUNNING:
            {
                /*Check if channel counter has already rollover*/
                if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6040:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6044:	2b00      	cmp	r3, #0
    6046:	d023      	beq.n	6090 <Gpt_GetTimeElapsed+0xd4>
                    (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6048:	4a14      	ldr	r2, [pc, #80]	; (609c <Gpt_GetTimeElapsed+0xe0>)
    604a:	9b05      	ldr	r3, [sp, #20]
    604c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6050:	6859      	ldr	r1, [r3, #4]
    6052:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6056:	4613      	mov	r3, r2
    6058:	009b      	lsls	r3, r3, #2
    605a:	4413      	add	r3, r2
    605c:	009b      	lsls	r3, r3, #2
    605e:	440b      	add	r3, r1
    6060:	330c      	adds	r3, #12
    6062:	681b      	ldr	r3, [r3, #0]
                if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6064:	2b01      	cmp	r3, #1
    6066:	d113      	bne.n	6090 <Gpt_GetTimeElapsed+0xd4>
                   )
                {
                    /*The timer has already expired.The hardware timer status is not yet
                    synchronized with the logical timer status*/
                    returnValue = returnHwChannelInfo.uTargetTime;
    6068:	9b03      	ldr	r3, [sp, #12]
    606a:	9307      	str	r3, [sp, #28]
                }
            }
            break;
    606c:	e010      	b.n	6090 <Gpt_GetTimeElapsed+0xd4>
            case GPT_STATUS_INITIALIZED:
            {
                returnValue = 0U;
    606e:	2300      	movs	r3, #0
    6070:	9307      	str	r3, [sp, #28]
            }
            break;
    6072:	e00e      	b.n	6092 <Gpt_GetTimeElapsed+0xd6>
            case GPT_STATUS_STOPPED:
            {
                /*Return elapsed time at the when the channel was stopped*/
                returnValue = Gpt_aStopTime[coreID][channel];
    6074:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6078:	490a      	ldr	r1, [pc, #40]	; (60a4 <Gpt_GetTimeElapsed+0xe8>)
    607a:	9b05      	ldr	r3, [sp, #20]
    607c:	4413      	add	r3, r2
    607e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    6082:	9307      	str	r3, [sp, #28]
            }
            break;
    6084:	e005      	b.n	6092 <Gpt_GetTimeElapsed+0xd6>
            case GPT_STATUS_EXPIRED:
            {
                returnValue = returnHwChannelInfo.uTargetTime;
    6086:	9b03      	ldr	r3, [sp, #12]
    6088:	9307      	str	r3, [sp, #28]
            }
            break;
    608a:	e002      	b.n	6092 <Gpt_GetTimeElapsed+0xd6>
            default:
                /*Only the above four channel states are allowed when this function is called*/
                break;
    608c:	bf00      	nop
    608e:	e000      	b.n	6092 <Gpt_GetTimeElapsed+0xd6>
            break;
    6090:	bf00      	nop
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif

    return returnValue;
    6092:	9b07      	ldr	r3, [sp, #28]
}
    6094:	4618      	mov	r0, r3
    6096:	b009      	add	sp, #36	; 0x24
    6098:	f85d fb04 	ldr.w	pc, [sp], #4
    609c:	1fff8d1c 	.word	0x1fff8d1c
    60a0:	1fff8d20 	.word	0x1fff8d20
    60a4:	1fff8d28 	.word	0x1fff8d28

000060a8 <Gpt_GetTimeRemaining>:
*
* @pre           The driver needs to be initialized.
* @implements    Gpt_GetTimeRemaining_Activity
*/
Gpt_ValueType Gpt_GetTimeRemaining(Gpt_ChannelType channel)
{
    60a8:	b500      	push	{lr}
    60aa:	b089      	sub	sp, #36	; 0x24
    60ac:	4603      	mov	r3, r0
    60ae:	f88d 3007 	strb.w	r3, [sp, #7]
	Gpt_HwChannelInfoType returnHwChannelInfo = {FALSE, 0U};
    60b2:	2300      	movs	r3, #0
    60b4:	f88d 3008 	strb.w	r3, [sp, #8]
    60b8:	2300      	movs	r3, #0
    60ba:	9303      	str	r3, [sp, #12]
	Gpt_HwChannelInfoType * pRetHwChannelInfo = &returnHwChannelInfo;
    60bc:	ab02      	add	r3, sp, #8
    60be:	9306      	str	r3, [sp, #24]
    Gpt_ChannelType ChannelIndex;

    Gpt_ValueType returnValue = 0U;
    60c0:	2300      	movs	r3, #0
    60c2:	9307      	str	r3, [sp, #28]
    uint32 coreID = (uint32)Gpt_GetCoreID();
    60c4:	2300      	movs	r3, #0
    60c6:	9305      	str	r3, [sp, #20]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(GPT_TIMEREMAINING_ID, channel, coreID))
    {
#endif
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    60c8:	4a32      	ldr	r2, [pc, #200]	; (6194 <Gpt_GetTimeRemaining+0xec>)
    60ca:	9b05      	ldr	r3, [sp, #20]
    60cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    60d0:	691a      	ldr	r2, [r3, #16]
    60d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    60d6:	5cd3      	ldrb	r3, [r2, r3]
    60d8:	f88d 3013 	strb.w	r3, [sp, #19]
        /* Calculate the remaining time from the elapsed time*/
        /* Gpt_Ipw_GetTimeElapsed() shall be called first, because the occurred ISRs can
        change the logical channel state between the checking of logical channel state
        and timestamps retrieval*/
        returnValue = Gpt_Ipw_GetTimeElapsed((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)), pRetHwChannelInfo);
    60dc:	4a2d      	ldr	r2, [pc, #180]	; (6194 <Gpt_GetTimeRemaining+0xec>)
    60de:	9b05      	ldr	r3, [sp, #20]
    60e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    60e4:	6859      	ldr	r1, [r3, #4]
    60e6:	f89d 2013 	ldrb.w	r2, [sp, #19]
    60ea:	4613      	mov	r3, r2
    60ec:	009b      	lsls	r3, r3, #2
    60ee:	4413      	add	r3, r2
    60f0:	009b      	lsls	r3, r3, #2
    60f2:	440b      	add	r3, r1
    60f4:	3310      	adds	r3, #16
    60f6:	681b      	ldr	r3, [r3, #0]
    60f8:	9906      	ldr	r1, [sp, #24]
    60fa:	4618      	mov	r0, r3
    60fc:	f000 fe41 	bl	6d82 <Gpt_Ipw_GetTimeElapsed>
    6100:	9007      	str	r0, [sp, #28]

        /*Check the channel status*/
        switch(Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6102:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6106:	4924      	ldr	r1, [pc, #144]	; (6198 <Gpt_GetTimeRemaining+0xf0>)
    6108:	9b05      	ldr	r3, [sp, #20]
    610a:	4413      	add	r3, r2
    610c:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6110:	3b01      	subs	r3, #1
    6112:	2b03      	cmp	r3, #3
    6114:	d837      	bhi.n	6186 <Gpt_GetTimeRemaining+0xde>
    6116:	a201      	add	r2, pc, #4	; (adr r2, 611c <Gpt_GetTimeRemaining+0x74>)
    6118:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    611c:	00006165 	.word	0x00006165
    6120:	0000616b 	.word	0x0000616b
    6124:	00006181 	.word	0x00006181
    6128:	0000612d 	.word	0x0000612d
        {
            case GPT_STATUS_RUNNING:
            {
                /*Check if channel counter has already roll-over*/
                if((TRUE == returnHwChannelInfo.bChannelRollover) && \
    612c:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6130:	2b00      	cmp	r3, #0
    6132:	d012      	beq.n	615a <Gpt_GetTimeRemaining+0xb2>
                   (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6134:	4a17      	ldr	r2, [pc, #92]	; (6194 <Gpt_GetTimeRemaining+0xec>)
    6136:	9b05      	ldr	r3, [sp, #20]
    6138:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    613c:	6859      	ldr	r1, [r3, #4]
    613e:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6142:	4613      	mov	r3, r2
    6144:	009b      	lsls	r3, r3, #2
    6146:	4413      	add	r3, r2
    6148:	009b      	lsls	r3, r3, #2
    614a:	440b      	add	r3, r1
    614c:	330c      	adds	r3, #12
    614e:	681b      	ldr	r3, [r3, #0]
                if((TRUE == returnHwChannelInfo.bChannelRollover) && \
    6150:	2b01      	cmp	r3, #1
    6152:	d102      	bne.n	615a <Gpt_GetTimeRemaining+0xb2>
                  )
                {
                    /*The timer has already expired.The hardware timer status is not yet
                    synchronized with the logical timer status*/
                    returnValue = 0U;
    6154:	2300      	movs	r3, #0
    6156:	9307      	str	r3, [sp, #28]
                {
                    /*Calculate remaining time from elapsed time*/
                    returnValue = returnHwChannelInfo.uTargetTime - returnValue;
                }
            }
            break;
    6158:	e016      	b.n	6188 <Gpt_GetTimeRemaining+0xe0>
                    returnValue = returnHwChannelInfo.uTargetTime - returnValue;
    615a:	9a03      	ldr	r2, [sp, #12]
    615c:	9b07      	ldr	r3, [sp, #28]
    615e:	1ad3      	subs	r3, r2, r3
    6160:	9307      	str	r3, [sp, #28]
            break;
    6162:	e011      	b.n	6188 <Gpt_GetTimeRemaining+0xe0>
            case GPT_STATUS_INITIALIZED:
            {
                returnValue = 0U;
    6164:	2300      	movs	r3, #0
    6166:	9307      	str	r3, [sp, #28]
            }
            break;
    6168:	e00e      	b.n	6188 <Gpt_GetTimeRemaining+0xe0>
            case GPT_STATUS_STOPPED:
            {
                returnValue = returnHwChannelInfo.uTargetTime-Gpt_aStopTime[coreID][channel];
    616a:	9a03      	ldr	r2, [sp, #12]
    616c:	f89d 1007 	ldrb.w	r1, [sp, #7]
    6170:	480a      	ldr	r0, [pc, #40]	; (619c <Gpt_GetTimeRemaining+0xf4>)
    6172:	9b05      	ldr	r3, [sp, #20]
    6174:	440b      	add	r3, r1
    6176:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    617a:	1ad3      	subs	r3, r2, r3
    617c:	9307      	str	r3, [sp, #28]
            }
            break;
    617e:	e003      	b.n	6188 <Gpt_GetTimeRemaining+0xe0>
            case GPT_STATUS_EXPIRED:
            {
                returnValue = 0U;
    6180:	2300      	movs	r3, #0
    6182:	9307      	str	r3, [sp, #28]
            }
            break;
    6184:	e000      	b.n	6188 <Gpt_GetTimeRemaining+0xe0>
            default:
                /*Only the above four channel states are allowed when this function is called*/
                break;
    6186:	bf00      	nop
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif

    return returnValue;
    6188:	9b07      	ldr	r3, [sp, #28]
}
    618a:	4618      	mov	r0, r3
    618c:	b009      	add	sp, #36	; 0x24
    618e:	f85d fb04 	ldr.w	pc, [sp], #4
    6192:	bf00      	nop
    6194:	1fff8d1c 	.word	0x1fff8d1c
    6198:	1fff8d20 	.word	0x1fff8d20
    619c:	1fff8d28 	.word	0x1fff8d28

000061a0 <Gpt_StartTimer>:
void Gpt_StartTimer
(
    Gpt_ChannelType channel,
    Gpt_ValueType value
)
{
    61a0:	b500      	push	{lr}
    61a2:	b085      	sub	sp, #20
    61a4:	4603      	mov	r3, r0
    61a6:	9100      	str	r1, [sp, #0]
    61a8:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    Std_ReturnType returnValue;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    61ac:	2300      	movs	r3, #0
    61ae:	9303      	str	r3, [sp, #12]

    if ((Std_ReturnType)E_OK == Gpt_ValidateChannelStatus(GPT_STARTTIMER_ID, channel, coreID))
    61b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61b4:	9a03      	ldr	r2, [sp, #12]
    61b6:	4619      	mov	r1, r3
    61b8:	2005      	movs	r0, #5
    61ba:	f7ff fdb1 	bl	5d20 <Gpt_ValidateChannelStatus>
    61be:	4603      	mov	r3, r0
    61c0:	2b00      	cmp	r3, #0
    61c2:	d152      	bne.n	626a <Gpt_StartTimer+0xca>
    {
#if (GPT_VALIDATE_PARAM  == STD_ON)
        if ((Std_ReturnType)E_OK == Gpt_ValidateParamValue(GPT_STARTTIMER_ID, channel, value, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    61c4:	4a2b      	ldr	r2, [pc, #172]	; (6274 <Gpt_StartTimer+0xd4>)
    61c6:	9b03      	ldr	r3, [sp, #12]
    61c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    61cc:	691a      	ldr	r2, [r3, #16]
    61ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
    61d2:	5cd3      	ldrb	r3, [r2, r3]
    61d4:	f88d 300b 	strb.w	r3, [sp, #11]
            /*Enable hardware interrupts for the one-shot mode to set the status of  channel*/
            if (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    61d8:	4a26      	ldr	r2, [pc, #152]	; (6274 <Gpt_StartTimer+0xd4>)
    61da:	9b03      	ldr	r3, [sp, #12]
    61dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    61e0:	6859      	ldr	r1, [r3, #4]
    61e2:	f89d 200b 	ldrb.w	r2, [sp, #11]
    61e6:	4613      	mov	r3, r2
    61e8:	009b      	lsls	r3, r3, #2
    61ea:	4413      	add	r3, r2
    61ec:	009b      	lsls	r3, r3, #2
    61ee:	440b      	add	r3, r1
    61f0:	330c      	adds	r3, #12
    61f2:	681b      	ldr	r3, [r3, #0]
    61f4:	2b01      	cmp	r3, #1
    61f6:	d110      	bne.n	621a <Gpt_StartTimer+0x7a>
            {
                Gpt_Ipw_EnableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    61f8:	4a1e      	ldr	r2, [pc, #120]	; (6274 <Gpt_StartTimer+0xd4>)
    61fa:	9b03      	ldr	r3, [sp, #12]
    61fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6200:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_EnableInterrupt
    6202:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6206:	4613      	mov	r3, r2
    6208:	009b      	lsls	r3, r3, #2
    620a:	4413      	add	r3, r2
    620c:	009b      	lsls	r3, r3, #2
    620e:	440b      	add	r3, r1
    6210:	3310      	adds	r3, #16
    6212:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_EnableInterrupt
    6214:	4618      	mov	r0, r3
    6216:	f000 fddf 	bl	6dd8 <Gpt_Ipw_EnableInterrupt>
                );
            }

            /* Change GPT channel status.Channel status change shall be made before to start
            the hardware in order to not change the channel status from EXPIRED to RUNNING*/
            Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_RUNNING;
    621a:	f89d 2007 	ldrb.w	r2, [sp, #7]
    621e:	4916      	ldr	r1, [pc, #88]	; (6278 <Gpt_StartTimer+0xd8>)
    6220:	9b03      	ldr	r3, [sp, #12]
    6222:	4413      	add	r3, r2
    6224:	2204      	movs	r2, #4
    6226:	f841 2033 	str.w	r2, [r1, r3, lsl #3]

            /* Call low level API */
            returnValue = Gpt_Ipw_StartTimer(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig),value);
    622a:	4a12      	ldr	r2, [pc, #72]	; (6274 <Gpt_StartTimer+0xd4>)
    622c:	9b03      	ldr	r3, [sp, #12]
    622e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6232:	6859      	ldr	r1, [r3, #4]
    6234:	f89d 200b 	ldrb.w	r2, [sp, #11]
    6238:	4613      	mov	r3, r2
    623a:	009b      	lsls	r3, r3, #2
    623c:	4413      	add	r3, r2
    623e:	009b      	lsls	r3, r3, #2
    6240:	440b      	add	r3, r1
    6242:	3310      	adds	r3, #16
    6244:	681b      	ldr	r3, [r3, #0]
    6246:	9900      	ldr	r1, [sp, #0]
    6248:	4618      	mov	r0, r3
    624a:	f000 fd7b 	bl	6d44 <Gpt_Ipw_StartTimer>
    624e:	4603      	mov	r3, r0
    6250:	f88d 300a 	strb.w	r3, [sp, #10]

            if((Std_ReturnType)E_OK != returnValue)
    6254:	f89d 300a 	ldrb.w	r3, [sp, #10]
    6258:	2b00      	cmp	r3, #0
    625a:	d006      	beq.n	626a <Gpt_StartTimer+0xca>
            {
                (void)Det_ReportRuntimeError\
    625c:	232b      	movs	r3, #43	; 0x2b
    625e:	2205      	movs	r2, #5
    6260:	2100      	movs	r1, #0
    6262:	2064      	movs	r0, #100	; 0x64
    6264:	f004 f952 	bl	a50c <Det_ReportRuntimeError>
            }
#if (GPT_VALIDATE_PARAM  == STD_ON)
        }
#endif
    }
    return;
    6268:	bf00      	nop
    626a:	bf00      	nop
}
    626c:	b005      	add	sp, #20
    626e:	f85d fb04 	ldr.w	pc, [sp], #4
    6272:	bf00      	nop
    6274:	1fff8d1c 	.word	0x1fff8d1c
    6278:	1fff8d20 	.word	0x1fff8d20

0000627c <Gpt_StopTimer>:
*
* @pre          The driver needs to be initialized. Gpt_StartTimer must be called before.
* @implements   Gpt_StopTimer_Activity
*/
void Gpt_StopTimer(Gpt_ChannelType channel)
{
    627c:	b500      	push	{lr}
    627e:	b089      	sub	sp, #36	; 0x24
    6280:	4603      	mov	r3, r0
    6282:	f88d 3007 	strb.w	r3, [sp, #7]
	Gpt_HwChannelInfoType returnHwChannelInfo = {FALSE, 0U};
    6286:	2300      	movs	r3, #0
    6288:	f88d 3008 	strb.w	r3, [sp, #8]
    628c:	2300      	movs	r3, #0
    628e:	9303      	str	r3, [sp, #12]
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
	Gpt_HwChannelInfoType * pRetHwChannelInfo = &returnHwChannelInfo;
    6290:	ab02      	add	r3, sp, #8
    6292:	9307      	str	r3, [sp, #28]
    Gpt_ValueType uElapsedTime = 0U;
    6294:	2300      	movs	r3, #0
    6296:	9306      	str	r3, [sp, #24]
#endif
    Gpt_ChannelType ChannelIndex;

    uint32 coreID = (uint32)Gpt_GetCoreID();
    6298:	2300      	movs	r3, #0
    629a:	9305      	str	r3, [sp, #20]

#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    if((Std_ReturnType)E_OK == Gpt_ValidateChannelCall(GPT_STOPTIMER_ID, channel, coreID))
    {
#endif
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    629c:	4a34      	ldr	r2, [pc, #208]	; (6370 <Gpt_StopTimer+0xf4>)
    629e:	9b05      	ldr	r3, [sp, #20]
    62a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62a4:	691a      	ldr	r2, [r3, #16]
    62a6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    62aa:	5cd3      	ldrb	r3, [r2, r3]
    62ac:	f88d 3013 	strb.w	r3, [sp, #19]
        /*Gpt_Ipw_GetTimeElapsed() shall be called first, because the occurred ISRs can change
        the logical channel state between the checking of logical channel state and timestamps
        retrieval*/
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
        /* Get the elapsed  time  for later use by other API calls*/
        uElapsedTime = Gpt_Ipw_GetTimeElapsed((((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)), pRetHwChannelInfo);
    62b0:	4a2f      	ldr	r2, [pc, #188]	; (6370 <Gpt_StopTimer+0xf4>)
    62b2:	9b05      	ldr	r3, [sp, #20]
    62b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62b8:	6859      	ldr	r1, [r3, #4]
    62ba:	f89d 2013 	ldrb.w	r2, [sp, #19]
    62be:	4613      	mov	r3, r2
    62c0:	009b      	lsls	r3, r3, #2
    62c2:	4413      	add	r3, r2
    62c4:	009b      	lsls	r3, r3, #2
    62c6:	440b      	add	r3, r1
    62c8:	3310      	adds	r3, #16
    62ca:	681b      	ldr	r3, [r3, #0]
    62cc:	9907      	ldr	r1, [sp, #28]
    62ce:	4618      	mov	r0, r3
    62d0:	f000 fd57 	bl	6d82 <Gpt_Ipw_GetTimeElapsed>
    62d4:	9006      	str	r0, [sp, #24]
#endif

        /*Check the logical channel status*/
        if (GPT_STATUS_RUNNING == Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    62d6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    62da:	4926      	ldr	r1, [pc, #152]	; (6374 <Gpt_StopTimer+0xf8>)
    62dc:	9b05      	ldr	r3, [sp, #20]
    62de:	4413      	add	r3, r2
    62e0:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    62e4:	2b04      	cmp	r3, #4
    62e6:	d13e      	bne.n	6366 <Gpt_StopTimer+0xea>
        {
            /* Call low level stop timer */
            Gpt_Ipw_StopTimer(((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig));
    62e8:	4a21      	ldr	r2, [pc, #132]	; (6370 <Gpt_StopTimer+0xf4>)
    62ea:	9b05      	ldr	r3, [sp, #20]
    62ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    62f0:	6859      	ldr	r1, [r3, #4]
    62f2:	f89d 2013 	ldrb.w	r2, [sp, #19]
    62f6:	4613      	mov	r3, r2
    62f8:	009b      	lsls	r3, r3, #2
    62fa:	4413      	add	r3, r2
    62fc:	009b      	lsls	r3, r3, #2
    62fe:	440b      	add	r3, r1
    6300:	3310      	adds	r3, #16
    6302:	681b      	ldr	r3, [r3, #0]
    6304:	4618      	mov	r0, r3
    6306:	f000 fd52 	bl	6dae <Gpt_Ipw_StopTimer>

            if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    630a:	f89d 3008 	ldrb.w	r3, [sp, #8]
    630e:	2b00      	cmp	r3, #0
    6310:	d018      	beq.n	6344 <Gpt_StopTimer+0xc8>
                (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    6312:	4a17      	ldr	r2, [pc, #92]	; (6370 <Gpt_StopTimer+0xf4>)
    6314:	9b05      	ldr	r3, [sp, #20]
    6316:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    631a:	6859      	ldr	r1, [r3, #4]
    631c:	f89d 2013 	ldrb.w	r2, [sp, #19]
    6320:	4613      	mov	r3, r2
    6322:	009b      	lsls	r3, r3, #2
    6324:	4413      	add	r3, r2
    6326:	009b      	lsls	r3, r3, #2
    6328:	440b      	add	r3, r1
    632a:	330c      	adds	r3, #12
    632c:	681b      	ldr	r3, [r3, #0]
            if ((TRUE == returnHwChannelInfo.bChannelRollover) && \
    632e:	2b01      	cmp	r3, #1
    6330:	d108      	bne.n	6344 <Gpt_StopTimer+0xc8>
            )
            {
                /*This action could be executed only when the function is called during a critical
                section implemented by disabling all interrupts*/
                /*Set channel status to EXPIRED*/
                Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_EXPIRED;
    6332:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6336:	490f      	ldr	r1, [pc, #60]	; (6374 <Gpt_StopTimer+0xf8>)
    6338:	9b05      	ldr	r3, [sp, #20]
    633a:	4413      	add	r3, r2
    633c:	2203      	movs	r2, #3
    633e:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
    6342:	e00f      	b.n	6364 <Gpt_StopTimer+0xe8>
            }
            else
            {
#if ((GPT_TIME_REMAINING_API == STD_ON) || (GPT_TIME_ELAPSED_API == STD_ON))
                /* Store the stopping time for later use by other API calls*/
                Gpt_aStopTime[coreID][channel] = uElapsedTime;
    6344:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6348:	490b      	ldr	r1, [pc, #44]	; (6378 <Gpt_StopTimer+0xfc>)
    634a:	9b05      	ldr	r3, [sp, #20]
    634c:	4413      	add	r3, r2
    634e:	9a06      	ldr	r2, [sp, #24]
    6350:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

                /* Set GPT channel status to stopped*/
                Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_STOPPED;
    6354:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6358:	4906      	ldr	r1, [pc, #24]	; (6374 <Gpt_StopTimer+0xf8>)
    635a:	9b05      	ldr	r3, [sp, #20]
    635c:	4413      	add	r3, r2
    635e:	2202      	movs	r2, #2
    6360:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
            }
        }
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
    return;
    6364:	bf00      	nop
    6366:	bf00      	nop
}
    6368:	b009      	add	sp, #36	; 0x24
    636a:	f85d fb04 	ldr.w	pc, [sp], #4
    636e:	bf00      	nop
    6370:	1fff8d1c 	.word	0x1fff8d1c
    6374:	1fff8d20 	.word	0x1fff8d20
    6378:	1fff8d28 	.word	0x1fff8d28

0000637c <Gpt_EnableNotification>:
*
* @pre          The driver needs to be initialized.
* @implements   Gpt_EnableNotification_Activity
*/
void Gpt_EnableNotification(Gpt_ChannelType channel)
{
    637c:	b500      	push	{lr}
    637e:	b085      	sub	sp, #20
    6380:	4603      	mov	r3, r0
    6382:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    6386:	2300      	movs	r3, #0
    6388:	9303      	str	r3, [sp, #12]
#endif
#if (GPT_VALIDATE_PARAM == STD_ON)
        if ((Std_ReturnType)E_OK == Gpt_ValidateChannelNotification(GPT_ENABLENOTIFICATION_ID, channel, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    638a:	4a17      	ldr	r2, [pc, #92]	; (63e8 <Gpt_EnableNotification+0x6c>)
    638c:	9b03      	ldr	r3, [sp, #12]
    638e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6392:	691a      	ldr	r2, [r3, #16]
    6394:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6398:	5cd3      	ldrb	r3, [r2, r3]
    639a:	f88d 300b 	strb.w	r3, [sp, #11]
            /* Set the enable notification attribute */
            Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = TRUE;
    639e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    63a2:	4912      	ldr	r1, [pc, #72]	; (63ec <Gpt_EnableNotification+0x70>)
    63a4:	9b03      	ldr	r3, [sp, #12]
    63a6:	4413      	add	r3, r2
    63a8:	00db      	lsls	r3, r3, #3
    63aa:	440b      	add	r3, r1
    63ac:	2201      	movs	r2, #1
    63ae:	711a      	strb	r2, [r3, #4]

            if (GPT_MODE_NORMAL == Gpt_eMode[coreID])
    63b0:	4a0f      	ldr	r2, [pc, #60]	; (63f0 <Gpt_EnableNotification+0x74>)
    63b2:	9b03      	ldr	r3, [sp, #12]
    63b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63b8:	2b00      	cmp	r3, #0
    63ba:	d111      	bne.n	63e0 <Gpt_EnableNotification+0x64>
            {
                /*Enable hardware interrupts*/
                Gpt_Ipw_EnableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    63bc:	4a0a      	ldr	r2, [pc, #40]	; (63e8 <Gpt_EnableNotification+0x6c>)
    63be:	9b03      	ldr	r3, [sp, #12]
    63c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    63c4:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_EnableInterrupt
    63c6:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    63ca:	4613      	mov	r3, r2
    63cc:	009b      	lsls	r3, r3, #2
    63ce:	4413      	add	r3, r2
    63d0:	009b      	lsls	r3, r3, #2
    63d2:	440b      	add	r3, r1
    63d4:	3310      	adds	r3, #16
    63d6:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_EnableInterrupt
    63d8:	4618      	mov	r0, r3
    63da:	f000 fcfd 	bl	6dd8 <Gpt_Ipw_EnableInterrupt>
#endif
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif

    return;
    63de:	bf00      	nop
    63e0:	bf00      	nop
}
    63e2:	b005      	add	sp, #20
    63e4:	f85d fb04 	ldr.w	pc, [sp], #4
    63e8:	1fff8d1c 	.word	0x1fff8d1c
    63ec:	1fff8d20 	.word	0x1fff8d20
    63f0:	1fff8d18 	.word	0x1fff8d18

000063f4 <Gpt_DisableNotification>:
*
* @pre          The driver needs to be initialized.
* @implements   Gpt_DisableNotification_Activity
*/
void Gpt_DisableNotification(Gpt_ChannelType channel)
{
    63f4:	b500      	push	{lr}
    63f6:	b085      	sub	sp, #20
    63f8:	4603      	mov	r3, r0
    63fa:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    63fe:	2300      	movs	r3, #0
    6400:	9303      	str	r3, [sp, #12]
#endif
#if (GPT_VALIDATE_PARAM == STD_ON)
        if ((Std_ReturnType)E_OK == Gpt_ValidateChannelNotification(GPT_DISABLENOTIFICATION_ID, channel, coreID))
        {
#endif
            ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    6402:	4a24      	ldr	r2, [pc, #144]	; (6494 <Gpt_DisableNotification+0xa0>)
    6404:	9b03      	ldr	r3, [sp, #12]
    6406:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    640a:	691a      	ldr	r2, [r3, #16]
    640c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6410:	5cd3      	ldrb	r3, [r2, r3]
    6412:	f88d 300b 	strb.w	r3, [sp, #11]
            /* Set the enable notification attribute */
            Gpt_aChannelInfo[coreID][channel].bNotificationEnabled = FALSE;
    6416:	f89d 2007 	ldrb.w	r2, [sp, #7]
    641a:	491f      	ldr	r1, [pc, #124]	; (6498 <Gpt_DisableNotification+0xa4>)
    641c:	9b03      	ldr	r3, [sp, #12]
    641e:	4413      	add	r3, r2
    6420:	00db      	lsls	r3, r3, #3
    6422:	440b      	add	r3, r1
    6424:	2200      	movs	r2, #0
    6426:	711a      	strb	r2, [r3, #4]

            /* Disable hardware interrupts if the channel is not running in the ONE-SHOT mode.
            This is needed because the channel state is updated by ISR for ONE-SHOT mode */
            if ((GPT_MODE_NORMAL == Gpt_eMode[coreID]) && \
    6428:	4a1c      	ldr	r2, [pc, #112]	; (649c <Gpt_DisableNotification+0xa8>)
    642a:	9b03      	ldr	r3, [sp, #12]
    642c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6430:	2b00      	cmp	r3, #0
    6432:	d12a      	bne.n	648a <Gpt_DisableNotification+0x96>
                ((GPT_CH_MODE_CONTINUOUS == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode) \
    6434:	4a17      	ldr	r2, [pc, #92]	; (6494 <Gpt_DisableNotification+0xa0>)
    6436:	9b03      	ldr	r3, [sp, #12]
    6438:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    643c:	6859      	ldr	r1, [r3, #4]
    643e:	f89d 200b 	ldrb.w	r2, [sp, #11]
    6442:	4613      	mov	r3, r2
    6444:	009b      	lsls	r3, r3, #2
    6446:	4413      	add	r3, r2
    6448:	009b      	lsls	r3, r3, #2
    644a:	440b      	add	r3, r1
    644c:	330c      	adds	r3, #12
    644e:	681b      	ldr	r3, [r3, #0]
            if ((GPT_MODE_NORMAL == Gpt_eMode[coreID]) && \
    6450:	2b00      	cmp	r3, #0
    6452:	d008      	beq.n	6466 <Gpt_DisableNotification+0x72>
                 || (GPT_STATUS_RUNNING != Gpt_aChannelInfo[coreID][channel].eChannelStatus)
    6454:	f89d 2007 	ldrb.w	r2, [sp, #7]
    6458:	490f      	ldr	r1, [pc, #60]	; (6498 <Gpt_DisableNotification+0xa4>)
    645a:	9b03      	ldr	r3, [sp, #12]
    645c:	4413      	add	r3, r2
    645e:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
    6462:	2b04      	cmp	r3, #4
    6464:	d011      	beq.n	648a <Gpt_DisableNotification+0x96>
               )
            {
                /*Disable hardware interrupts*/
                Gpt_Ipw_DisableInterrupt
                (
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6466:	4a0b      	ldr	r2, [pc, #44]	; (6494 <Gpt_DisableNotification+0xa0>)
    6468:	9b03      	ldr	r3, [sp, #12]
    646a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    646e:	6859      	ldr	r1, [r3, #4]
                Gpt_Ipw_DisableInterrupt
    6470:	f89d 200b 	ldrb.w	r2, [sp, #11]
                    ((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_Ipw_HwChannelConfig)
    6474:	4613      	mov	r3, r2
    6476:	009b      	lsls	r3, r3, #2
    6478:	4413      	add	r3, r2
    647a:	009b      	lsls	r3, r3, #2
    647c:	440b      	add	r3, r1
    647e:	3310      	adds	r3, #16
    6480:	681b      	ldr	r3, [r3, #0]
                Gpt_Ipw_DisableInterrupt
    6482:	4618      	mov	r0, r3
    6484:	f000 fcc3 	bl	6e0e <Gpt_Ipw_DisableInterrupt>
        }
#endif
#if (GPT_VALIDATE_CHANNEL_CALL == STD_ON)
    }
#endif
    return;
    6488:	bf00      	nop
    648a:	bf00      	nop
}
    648c:	b005      	add	sp, #20
    648e:	f85d fb04 	ldr.w	pc, [sp], #4
    6492:	bf00      	nop
    6494:	1fff8d1c 	.word	0x1fff8d1c
    6498:	1fff8d20 	.word	0x1fff8d20
    649c:	1fff8d18 	.word	0x1fff8d18

000064a0 <Gpt_ProcessCommonInterrupt>:
* @return       void
* @pre          The driver needs to be initialized.
* @implements   Gpt_ProcessCommonInterrupt_Activity
*/
void Gpt_ProcessCommonInterrupt(uint8 channel)
{
    64a0:	b500      	push	{lr}
    64a2:	b085      	sub	sp, #20
    64a4:	4603      	mov	r3, r0
    64a6:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ChannelIndex;
    uint32 coreID = (uint32)Gpt_GetCoreID();
    64aa:	2300      	movs	r3, #0
    64ac:	9303      	str	r3, [sp, #12]

    if (Gpt_pConfig[coreID] != NULL_PTR)
    64ae:	4a26      	ldr	r2, [pc, #152]	; (6548 <Gpt_ProcessCommonInterrupt+0xa8>)
    64b0:	9b03      	ldr	r3, [sp, #12]
    64b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    64b6:	2b00      	cmp	r3, #0
    64b8:	d041      	beq.n	653e <Gpt_ProcessCommonInterrupt+0x9e>
    {
        /* Extract the logical channel from the hardware to logic map table */
        ChannelIndex = (*(Gpt_pConfig[coreID]->u8GptChannelIdToIndexMap))[channel];
    64ba:	4a23      	ldr	r2, [pc, #140]	; (6548 <Gpt_ProcessCommonInterrupt+0xa8>)
    64bc:	9b03      	ldr	r3, [sp, #12]
    64be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    64c2:	691a      	ldr	r2, [r3, #16]
    64c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64c8:	5cd3      	ldrb	r3, [r2, r3]
    64ca:	f88d 300b 	strb.w	r3, [sp, #11]

        /* Change the channel status for one-shot mode */
        if (GPT_CH_MODE_ONESHOT == (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_eChannelMode)
    64ce:	4a1e      	ldr	r2, [pc, #120]	; (6548 <Gpt_ProcessCommonInterrupt+0xa8>)
    64d0:	9b03      	ldr	r3, [sp, #12]
    64d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    64d6:	6859      	ldr	r1, [r3, #4]
    64d8:	f89d 200b 	ldrb.w	r2, [sp, #11]
    64dc:	4613      	mov	r3, r2
    64de:	009b      	lsls	r3, r3, #2
    64e0:	4413      	add	r3, r2
    64e2:	009b      	lsls	r3, r3, #2
    64e4:	440b      	add	r3, r1
    64e6:	330c      	adds	r3, #12
    64e8:	681b      	ldr	r3, [r3, #0]
    64ea:	2b01      	cmp	r3, #1
    64ec:	d107      	bne.n	64fe <Gpt_ProcessCommonInterrupt+0x5e>
        {
            /* Change the channel status to expired */
            Gpt_aChannelInfo[coreID][channel].eChannelStatus = GPT_STATUS_EXPIRED;
    64ee:	f89d 2007 	ldrb.w	r2, [sp, #7]
    64f2:	4916      	ldr	r1, [pc, #88]	; (654c <Gpt_ProcessCommonInterrupt+0xac>)
    64f4:	9b03      	ldr	r3, [sp, #12]
    64f6:	4413      	add	r3, r2
    64f8:	2203      	movs	r2, #3
    64fa:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        }
#if (GPT_ENABLE_DISABLE_NOTIFICATION_API == STD_ON)
        if ((GPT_MODE_NORMAL == Gpt_eMode[coreID]) && (TRUE == Gpt_aChannelInfo[coreID][channel].bNotificationEnabled))
    64fe:	4a14      	ldr	r2, [pc, #80]	; (6550 <Gpt_ProcessCommonInterrupt+0xb0>)
    6500:	9b03      	ldr	r3, [sp, #12]
    6502:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6506:	2b00      	cmp	r3, #0
    6508:	d119      	bne.n	653e <Gpt_ProcessCommonInterrupt+0x9e>
    650a:	f89d 2007 	ldrb.w	r2, [sp, #7]
    650e:	490f      	ldr	r1, [pc, #60]	; (654c <Gpt_ProcessCommonInterrupt+0xac>)
    6510:	9b03      	ldr	r3, [sp, #12]
    6512:	4413      	add	r3, r2
    6514:	00db      	lsls	r3, r3, #3
    6516:	440b      	add	r3, r1
    6518:	791b      	ldrb	r3, [r3, #4]
    651a:	2b00      	cmp	r3, #0
    651c:	d00f      	beq.n	653e <Gpt_ProcessCommonInterrupt+0x9e>
        {
            (*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_pfNotification();
    651e:	4a0a      	ldr	r2, [pc, #40]	; (6548 <Gpt_ProcessCommonInterrupt+0xa8>)
    6520:	9b03      	ldr	r3, [sp, #12]
    6522:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6526:	6859      	ldr	r1, [r3, #4]
    6528:	f89d 200b 	ldrb.w	r2, [sp, #11]
    652c:	4613      	mov	r3, r2
    652e:	009b      	lsls	r3, r3, #2
    6530:	4413      	add	r3, r2
    6532:	009b      	lsls	r3, r3, #2
    6534:	440b      	add	r3, r1
    6536:	3304      	adds	r3, #4
    6538:	681b      	ldr	r3, [r3, #0]
    653a:	4798      	blx	r3
            EcuM_CheckWakeup((*(Gpt_pConfig[coreID]->Gpt_pChannelConfig))[ChannelIndex].Gpt_uWakeupSource);
        }
#endif
#endif
    }
    return;
    653c:	bf00      	nop
    653e:	bf00      	nop
}
    6540:	b005      	add	sp, #20
    6542:	f85d fb04 	ldr.w	pc, [sp], #4
    6546:	bf00      	nop
    6548:	1fff8d1c 	.word	0x1fff8d1c
    654c:	1fff8d20 	.word	0x1fff8d20
    6550:	1fff8d18 	.word	0x1fff8d18

00006554 <Ftm_Gpt_Ip_GetCntValue>:
*
* @return   current counter value
*
*/
static inline uint32 Ftm_Gpt_Ip_GetCntValue(uint8 instance)
{
    6554:	b082      	sub	sp, #8
    6556:	4603      	mov	r3, r0
    6558:	f88d 3007 	strb.w	r3, [sp, #7]
    return ftmGptBase[instance]->CNT;
    655c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6560:	4a03      	ldr	r2, [pc, #12]	; (6570 <Ftm_Gpt_Ip_GetCntValue+0x1c>)
    6562:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6566:	685b      	ldr	r3, [r3, #4]
}
    6568:	4618      	mov	r0, r3
    656a:	b002      	add	sp, #8
    656c:	4770      	bx	lr
    656e:	bf00      	nop
    6570:	0000ada8 	.word	0x0000ada8

00006574 <Ftm_Gpt_Ip_SetFreezeBits>:
 *
 * @return      void
 *
 */
static inline void Ftm_Gpt_Ip_SetFreezeBits(uint8 instance, boolean freezeBits)
{
    6574:	b500      	push	{lr}
    6576:	b085      	sub	sp, #20
    6578:	4603      	mov	r3, r0
    657a:	460a      	mov	r2, r1
    657c:	f88d 3007 	strb.w	r3, [sp, #7]
    6580:	4613      	mov	r3, r2
    6582:	f88d 3006 	strb.w	r3, [sp, #6]
    uint32 freezeVal = (TRUE == freezeBits) ? 0UL : 3UL;
    6586:	f89d 3006 	ldrb.w	r3, [sp, #6]
    658a:	2b00      	cmp	r3, #0
    658c:	d001      	beq.n	6592 <Ftm_Gpt_Ip_SetFreezeBits+0x1e>
    658e:	2300      	movs	r3, #0
    6590:	e000      	b.n	6594 <Ftm_Gpt_Ip_SetFreezeBits+0x20>
    6592:	2303      	movs	r3, #3
    6594:	9303      	str	r3, [sp, #12]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17();
    6596:	f002 f86f 	bl	8678 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17>
    ftmGptBase[instance]->CONF = (ftmGptBase[instance]->CONF & ~FTM_CONF_BDMMODE_MASK) | FTM_CONF_BDMMODE(freezeVal);
    659a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    659e:	4a0c      	ldr	r2, [pc, #48]	; (65d0 <Ftm_Gpt_Ip_SetFreezeBits+0x5c>)
    65a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    65a4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
    65a8:	f023 01c0 	bic.w	r1, r3, #192	; 0xc0
    65ac:	9b03      	ldr	r3, [sp, #12]
    65ae:	019b      	lsls	r3, r3, #6
    65b0:	b2da      	uxtb	r2, r3
    65b2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    65b6:	4806      	ldr	r0, [pc, #24]	; (65d0 <Ftm_Gpt_Ip_SetFreezeBits+0x5c>)
    65b8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    65bc:	430a      	orrs	r2, r1
    65be:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17();
    65c2:	f002 f885 	bl	86d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17>
}
    65c6:	bf00      	nop
    65c8:	b005      	add	sp, #20
    65ca:	f85d fb04 	ldr.w	pc, [sp], #4
    65ce:	bf00      	nop
    65d0:	0000ada8 	.word	0x0000ada8

000065d4 <Ftm_Gpt_Ip_SetCounterInitVal>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetCounterInitVal(uint8 instance, uint16 value)
{
    65d4:	b082      	sub	sp, #8
    65d6:	4603      	mov	r3, r0
    65d8:	460a      	mov	r2, r1
    65da:	f88d 3007 	strb.w	r3, [sp, #7]
    65de:	4613      	mov	r3, r2
    65e0:	f8ad 3004 	strh.w	r3, [sp, #4]
    ftmGptBase[instance]->CNTIN = (uint32)(((uint32)value << FTM_CNTIN_INIT_SHIFT) & FTM_CNTIN_INIT_MASK);
    65e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    65e8:	4a04      	ldr	r2, [pc, #16]	; (65fc <Ftm_Gpt_Ip_SetCounterInitVal+0x28>)
    65ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    65ee:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    65f2:	64da      	str	r2, [r3, #76]	; 0x4c
}
    65f4:	bf00      	nop
    65f6:	b002      	add	sp, #8
    65f8:	4770      	bx	lr
    65fa:	bf00      	nop
    65fc:	0000ada8 	.word	0x0000ada8

00006600 <Ftm_Gpt_Ip_SetCounter>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetCounter(uint8 instance, uint16 value)
{
    6600:	b082      	sub	sp, #8
    6602:	4603      	mov	r3, r0
    6604:	460a      	mov	r2, r1
    6606:	f88d 3007 	strb.w	r3, [sp, #7]
    660a:	4613      	mov	r3, r2
    660c:	f8ad 3004 	strh.w	r3, [sp, #4]
    ftmGptBase[instance]->CNT = (uint32)(((uint32)value << FTM_CNT_COUNT_SHIFT) & FTM_CNT_COUNT_MASK);
    6610:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6614:	4a04      	ldr	r2, [pc, #16]	; (6628 <Ftm_Gpt_Ip_SetCounter+0x28>)
    6616:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    661a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    661e:	605a      	str	r2, [r3, #4]
}
    6620:	bf00      	nop
    6622:	b002      	add	sp, #8
    6624:	4770      	bx	lr
    6626:	bf00      	nop
    6628:	0000ada8 	.word	0x0000ada8

0000662c <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>:
 *
 * @return      void
 * @pre         The driver needs to be initialized.
 */
static inline void Ftm_Gpt_Ip_ClearChInterruptStatusFlag(uint8 instance, uint8 channel)
{
    662c:	b082      	sub	sp, #8
    662e:	4603      	mov	r3, r0
    6630:	460a      	mov	r2, r1
    6632:	f88d 3007 	strb.w	r3, [sp, #7]
    6636:	4613      	mov	r3, r2
    6638:	f88d 3006 	strb.w	r3, [sp, #6]
    ftmGptBase[instance]-> CONTROLS[channel].CSC &= ~(FTM_CSC_CHF_MASK);
    663c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6640:	4a0c      	ldr	r2, [pc, #48]	; (6674 <Ftm_Gpt_Ip_ClearChInterruptStatusFlag+0x48>)
    6642:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6646:	f89d 3006 	ldrb.w	r3, [sp, #6]
    664a:	3301      	adds	r3, #1
    664c:	00db      	lsls	r3, r3, #3
    664e:	4413      	add	r3, r2
    6650:	685a      	ldr	r2, [r3, #4]
    6652:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6656:	4907      	ldr	r1, [pc, #28]	; (6674 <Ftm_Gpt_Ip_ClearChInterruptStatusFlag+0x48>)
    6658:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    665c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    6660:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    6664:	3301      	adds	r3, #1
    6666:	00db      	lsls	r3, r3, #3
    6668:	440b      	add	r3, r1
    666a:	605a      	str	r2, [r3, #4]
}
    666c:	bf00      	nop
    666e:	b002      	add	sp, #8
    6670:	4770      	bx	lr
    6672:	bf00      	nop
    6674:	0000ada8 	.word	0x0000ada8

00006678 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>:
 * @param[in]   aboEn - Enables the FTM channel(n) interrupt
 *              - True : Enable the FTM channel(n) interrupt.
 *              - False: Disable the FTM channel(n) interrupt.
 */
static inline void Ftm_Gpt_Ip_SetChannelEnableInterrupt(uint8 instance, uint8 channel, boolean aboEn)
{
    6678:	b082      	sub	sp, #8
    667a:	4603      	mov	r3, r0
    667c:	f88d 3007 	strb.w	r3, [sp, #7]
    6680:	460b      	mov	r3, r1
    6682:	f88d 3006 	strb.w	r3, [sp, #6]
    6686:	4613      	mov	r3, r2
    6688:	f88d 3005 	strb.w	r3, [sp, #5]
    ftmGptBase[instance]-> CONTROLS[channel].CSC = (ftmGptBase[instance]-> CONTROLS[channel].CSC & ~(FTM_CSC_CHIE_MASK)) | FTM_CSC_CHIE((TRUE == aboEn) ? 1UL : 0UL);
    668c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6690:	4a10      	ldr	r2, [pc, #64]	; (66d4 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x5c>)
    6692:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6696:	f89d 3006 	ldrb.w	r3, [sp, #6]
    669a:	3301      	adds	r3, #1
    669c:	00db      	lsls	r3, r3, #3
    669e:	4413      	add	r3, r2
    66a0:	685b      	ldr	r3, [r3, #4]
    66a2:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    66a6:	f89d 3005 	ldrb.w	r3, [sp, #5]
    66aa:	2b00      	cmp	r3, #0
    66ac:	d001      	beq.n	66b2 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x3a>
    66ae:	2040      	movs	r0, #64	; 0x40
    66b0:	e000      	b.n	66b4 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x3c>
    66b2:	2000      	movs	r0, #0
    66b4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    66b8:	4906      	ldr	r1, [pc, #24]	; (66d4 <Ftm_Gpt_Ip_SetChannelEnableInterrupt+0x5c>)
    66ba:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    66be:	f89d 3006 	ldrb.w	r3, [sp, #6]
    66c2:	4302      	orrs	r2, r0
    66c4:	3301      	adds	r3, #1
    66c6:	00db      	lsls	r3, r3, #3
    66c8:	440b      	add	r3, r1
    66ca:	605a      	str	r2, [r3, #4]
}
    66cc:	bf00      	nop
    66ce:	b002      	add	sp, #8
    66d0:	4770      	bx	lr
    66d2:	bf00      	nop
    66d4:	0000ada8 	.word	0x0000ada8

000066d8 <Ftm_Gpt_Ip_SetClockSource>:
 * @param[in]       instance    FTM hardware instance number
 *
 * @return      void
 */
static inline void Ftm_Gpt_Ip_SetClockSource(uint8 instance, Ftm_Gpt_Ip_ClockSource clocksource)
{
    66d8:	b500      	push	{lr}
    66da:	b083      	sub	sp, #12
    66dc:	4603      	mov	r3, r0
    66de:	9100      	str	r1, [sp, #0]
    66e0:	f88d 3007 	strb.w	r3, [sp, #7]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21();
    66e4:	f002 f81a 	bl	871c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21>
    ftmGptBase[instance]->SC = (ftmGptBase[instance]->SC & ~FTM_SC_CLKS_MASK) | FTM_SC_CLKS(clocksource);
    66e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    66ec:	4a0b      	ldr	r2, [pc, #44]	; (671c <Ftm_Gpt_Ip_SetClockSource+0x44>)
    66ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    66f2:	681b      	ldr	r3, [r3, #0]
    66f4:	f023 0118 	bic.w	r1, r3, #24
    66f8:	9b00      	ldr	r3, [sp, #0]
    66fa:	00db      	lsls	r3, r3, #3
    66fc:	f003 0218 	and.w	r2, r3, #24
    6700:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6704:	4805      	ldr	r0, [pc, #20]	; (671c <Ftm_Gpt_Ip_SetClockSource+0x44>)
    6706:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    670a:	430a      	orrs	r2, r1
    670c:	601a      	str	r2, [r3, #0]
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21();
    670e:	f002 f831 	bl	8774 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21>
}
    6712:	bf00      	nop
    6714:	b003      	add	sp, #12
    6716:	f85d fb04 	ldr.w	pc, [sp], #4
    671a:	bf00      	nop
    671c:	0000ada8 	.word	0x0000ada8

00006720 <Ftm_Gpt_Ip_SetPrescaler>:
 *
 * @return        void
 *
 */
static inline void Ftm_Gpt_Ip_SetPrescaler(uint8 instance, uint8 prescalerValue)
{
    6720:	b500      	push	{lr}
    6722:	b083      	sub	sp, #12
    6724:	4603      	mov	r3, r0
    6726:	460a      	mov	r2, r1
    6728:	f88d 3007 	strb.w	r3, [sp, #7]
    672c:	4613      	mov	r3, r2
    672e:	f88d 3006 	strb.w	r3, [sp, #6]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22();
    6732:	f002 f845 	bl	87c0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22>
    ftmGptBase[instance]->SC = (ftmGptBase[instance]->SC & ~FTM_SC_PS_MASK) | FTM_SC_PS(prescalerValue);
    6736:	f89d 3007 	ldrb.w	r3, [sp, #7]
    673a:	4a0b      	ldr	r2, [pc, #44]	; (6768 <Ftm_Gpt_Ip_SetPrescaler+0x48>)
    673c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6740:	681b      	ldr	r3, [r3, #0]
    6742:	f023 0107 	bic.w	r1, r3, #7
    6746:	f89d 3006 	ldrb.w	r3, [sp, #6]
    674a:	f003 0207 	and.w	r2, r3, #7
    674e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6752:	4805      	ldr	r0, [pc, #20]	; (6768 <Ftm_Gpt_Ip_SetPrescaler+0x48>)
    6754:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    6758:	430a      	orrs	r2, r1
    675a:	601a      	str	r2, [r3, #0]
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22();
    675c:	f002 f85c 	bl	8818 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22>
}
    6760:	bf00      	nop
    6762:	b003      	add	sp, #12
    6764:	f85d fb04 	ldr.w	pc, [sp], #4
    6768:	0000ada8 	.word	0x0000ada8

0000676c <Ftm_Gpt_Ip_SetEnFtmModule>:
 * @param[in]   enable
 *
 * @return      void
 */
static inline void Ftm_Gpt_Ip_SetEnFtmModule(uint8 instance, boolean enable)
{
    676c:	b500      	push	{lr}
    676e:	b083      	sub	sp, #12
    6770:	4603      	mov	r3, r0
    6772:	460a      	mov	r2, r1
    6774:	f88d 3007 	strb.w	r3, [sp, #7]
    6778:	4613      	mov	r3, r2
    677a:	f88d 3006 	strb.w	r3, [sp, #6]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23();
    677e:	f002 f871 	bl	8864 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23>
    {
        ftmGptBase[instance]->MODE &= ~(FTM_MODE_FTMEN_MASK);
    6782:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6786:	4a13      	ldr	r2, [pc, #76]	; (67d4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    6788:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    678c:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    678e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6792:	4910      	ldr	r1, [pc, #64]	; (67d4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    6794:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    6798:	f022 0201 	bic.w	r2, r2, #1
    679c:	655a      	str	r2, [r3, #84]	; 0x54
        ftmGptBase[instance]->MODE |= FTM_MODE_FTMEN(enable ? 1UL : 0UL);
    679e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    67a2:	4a0c      	ldr	r2, [pc, #48]	; (67d4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    67a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    67a8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    67aa:	f89d 3006 	ldrb.w	r3, [sp, #6]
    67ae:	2b00      	cmp	r3, #0
    67b0:	d001      	beq.n	67b6 <Ftm_Gpt_Ip_SetEnFtmModule+0x4a>
    67b2:	2101      	movs	r1, #1
    67b4:	e000      	b.n	67b8 <Ftm_Gpt_Ip_SetEnFtmModule+0x4c>
    67b6:	2100      	movs	r1, #0
    67b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    67bc:	4805      	ldr	r0, [pc, #20]	; (67d4 <Ftm_Gpt_Ip_SetEnFtmModule+0x68>)
    67be:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    67c2:	430a      	orrs	r2, r1
    67c4:	655a      	str	r2, [r3, #84]	; 0x54
    }
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23();
    67c6:	f002 f879 	bl	88bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23>
}
    67ca:	bf00      	nop
    67cc:	b003      	add	sp, #12
    67ce:	f85d fb04 	ldr.w	pc, [sp], #4
    67d2:	bf00      	nop
    67d4:	0000ada8 	.word	0x0000ada8

000067d8 <Ftm_Gpt_Ip_SetCompareValue>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetCompareValue(uint8 instance, uint8 channel, uint32 value)
{
    67d8:	b082      	sub	sp, #8
    67da:	4603      	mov	r3, r0
    67dc:	9200      	str	r2, [sp, #0]
    67de:	f88d 3007 	strb.w	r3, [sp, #7]
    67e2:	460b      	mov	r3, r1
    67e4:	f88d 3006 	strb.w	r3, [sp, #6]
    ftmGptBase[instance]-> CONTROLS[channel].CV = (uint32)((((uint32)value << FTM_CV_VAL_SHIFT) & FTM_CV_VAL_MASK));
    67e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    67ec:	4a06      	ldr	r2, [pc, #24]	; (6808 <Ftm_Gpt_Ip_SetCompareValue+0x30>)
    67ee:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    67f2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    67f6:	9a00      	ldr	r2, [sp, #0]
    67f8:	b292      	uxth	r2, r2
    67fa:	3301      	adds	r3, #1
    67fc:	00db      	lsls	r3, r3, #3
    67fe:	440b      	add	r3, r1
    6800:	609a      	str	r2, [r3, #8]

}
    6802:	bf00      	nop
    6804:	b002      	add	sp, #8
    6806:	4770      	bx	lr
    6808:	0000ada8 	.word	0x0000ada8

0000680c <Ftm_Gpt_Ip_WriteModulo>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_WriteModulo(uint8 instance, uint16 value)
{
    680c:	b082      	sub	sp, #8
    680e:	4603      	mov	r3, r0
    6810:	460a      	mov	r2, r1
    6812:	f88d 3007 	strb.w	r3, [sp, #7]
    6816:	4613      	mov	r3, r2
    6818:	f8ad 3004 	strh.w	r3, [sp, #4]
    ftmGptBase[instance]-> MOD = value;
    681c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6820:	4a04      	ldr	r2, [pc, #16]	; (6834 <Ftm_Gpt_Ip_WriteModulo+0x28>)
    6822:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6826:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    682a:	609a      	str	r2, [r3, #8]

}
    682c:	bf00      	nop
    682e:	b002      	add	sp, #8
    6830:	4770      	bx	lr
    6832:	bf00      	nop
    6834:	0000ada8 	.word	0x0000ada8

00006838 <Ftm_Gpt_Ip_ModeSelectA>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_ModeSelectA(uint8 instance, uint8 channel, boolean enable)
{
    6838:	b500      	push	{lr}
    683a:	b083      	sub	sp, #12
    683c:	4603      	mov	r3, r0
    683e:	f88d 3007 	strb.w	r3, [sp, #7]
    6842:	460b      	mov	r3, r1
    6844:	f88d 3006 	strb.w	r3, [sp, #6]
    6848:	4613      	mov	r3, r2
    684a:	f88d 3005 	strb.w	r3, [sp, #5]
    SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24();
    684e:	f002 f85b 	bl	8908 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24>
    if (TRUE == enable)
    6852:	f89d 3005 	ldrb.w	r3, [sp, #5]
    6856:	2b00      	cmp	r3, #0
    6858:	d018      	beq.n	688c <Ftm_Gpt_Ip_ModeSelectA+0x54>
    {
        ftmGptBase[instance]->CONTROLS[channel].CSC |= FTM_CSC_MSA_MASK;
    685a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    685e:	4a1a      	ldr	r2, [pc, #104]	; (68c8 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    6860:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6864:	f89d 3006 	ldrb.w	r3, [sp, #6]
    6868:	3301      	adds	r3, #1
    686a:	00db      	lsls	r3, r3, #3
    686c:	4413      	add	r3, r2
    686e:	685a      	ldr	r2, [r3, #4]
    6870:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6874:	4914      	ldr	r1, [pc, #80]	; (68c8 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    6876:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    687a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    687e:	f042 0210 	orr.w	r2, r2, #16
    6882:	3301      	adds	r3, #1
    6884:	00db      	lsls	r3, r3, #3
    6886:	440b      	add	r3, r1
    6888:	605a      	str	r2, [r3, #4]
    688a:	e017      	b.n	68bc <Ftm_Gpt_Ip_ModeSelectA+0x84>
    }
    else
    {
        ftmGptBase[instance]->CONTROLS[channel].CSC &= (~(FTM_CSC_MSA_MASK));
    688c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6890:	4a0d      	ldr	r2, [pc, #52]	; (68c8 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    6892:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6896:	f89d 3006 	ldrb.w	r3, [sp, #6]
    689a:	3301      	adds	r3, #1
    689c:	00db      	lsls	r3, r3, #3
    689e:	4413      	add	r3, r2
    68a0:	685a      	ldr	r2, [r3, #4]
    68a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    68a6:	4908      	ldr	r1, [pc, #32]	; (68c8 <Ftm_Gpt_Ip_ModeSelectA+0x90>)
    68a8:	f851 1023 	ldr.w	r1, [r1, r3, lsl #2]
    68ac:	f89d 3006 	ldrb.w	r3, [sp, #6]
    68b0:	f022 0210 	bic.w	r2, r2, #16
    68b4:	3301      	adds	r3, #1
    68b6:	00db      	lsls	r3, r3, #3
    68b8:	440b      	add	r3, r1
    68ba:	605a      	str	r2, [r3, #4]
    }
    SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24();
    68bc:	f002 f850 	bl	8960 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24>
}
    68c0:	bf00      	nop
    68c2:	b003      	add	sp, #12
    68c4:	f85d fb04 	ldr.w	pc, [sp], #4
    68c8:	0000ada8 	.word	0x0000ada8

000068cc <Ftm_Gpt_Ip_SetHalfCycleValue>:
*
* @return        void
*
*/
static inline void Ftm_Gpt_Ip_SetHalfCycleValue(FTM_Type * const base, uint16 value)
{
    68cc:	b082      	sub	sp, #8
    68ce:	9001      	str	r0, [sp, #4]
    68d0:	460b      	mov	r3, r1
    68d2:	f8ad 3002 	strh.w	r3, [sp, #2]
    ((base)->HCR) = value;
    68d6:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    68da:	9b01      	ldr	r3, [sp, #4]
    68dc:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
}
    68e0:	bf00      	nop
    68e2:	b002      	add	sp, #8
    68e4:	4770      	bx	lr

000068e6 <Ftm_Gpt_Ip_Init>:
* @return        void
* @pre           The data structure including the configuration set required for initializing the GPT driver
* @implements    Ftm_Gpt_Ip_Init_Activity
*/
void Ftm_Gpt_Ip_Init(uint8 instance, const Ftm_Gpt_Ip_InstanceConfigType *configPtr)
{
    68e6:	b500      	push	{lr}
    68e8:	b083      	sub	sp, #12
    68ea:	4603      	mov	r3, r0
    68ec:	9100      	str	r1, [sp, #0]
    68ee:	f88d 3007 	strb.w	r3, [sp, #7]
#endif
    /* Enable register access from user mode, if enabled from configuration file */
    Call_Ftm_Gpt_Ip_SetUserAccessAllowed((uint32)ftmGptBase[instance]);

    /* Check the FTM counter modes */
    if (FTM_GPT_IP_MODE_UP_TIMER == configPtr->mode)
    68f2:	9b00      	ldr	r3, [sp, #0]
    68f4:	68db      	ldr	r3, [r3, #12]
    68f6:	2b01      	cmp	r3, #1
    68f8:	d12a      	bne.n	6950 <Ftm_Gpt_Ip_Init+0x6a>
    {
        /* Set clock and prescalerValue FTM */
        Ftm_Gpt_Ip_SetPrescaler(instance, configPtr->clockPrescaler);
    68fa:	9b00      	ldr	r3, [sp, #0]
    68fc:	7a1a      	ldrb	r2, [r3, #8]
    68fe:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6902:	4611      	mov	r1, r2
    6904:	4618      	mov	r0, r3
    6906:	f7ff ff0b 	bl	6720 <Ftm_Gpt_Ip_SetPrescaler>
        /* Set FTM counter clock source */
        Ftm_Gpt_Ip_SetClockSource(instance, configPtr->clocksource);
    690a:	9b00      	ldr	r3, [sp, #0]
    690c:	685a      	ldr	r2, [r3, #4]
    690e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6912:	4611      	mov	r1, r2
    6914:	4618      	mov	r0, r3
    6916:	f7ff fedf 	bl	66d8 <Ftm_Gpt_Ip_SetClockSource>

        /* Set freeze bits */
        Ftm_Gpt_Ip_SetFreezeBits(instance, configPtr->freezeBits);
    691a:	9b00      	ldr	r3, [sp, #0]
    691c:	781a      	ldrb	r2, [r3, #0]
    691e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6922:	4611      	mov	r1, r2
    6924:	4618      	mov	r0, r3
    6926:	f7ff fe25 	bl	6574 <Ftm_Gpt_Ip_SetFreezeBits>

        /*Set Counter register and Initial Counter Value*/
        Ftm_Gpt_Ip_SetCounterInitVal(instance, 1U);
    692a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    692e:	2101      	movs	r1, #1
    6930:	4618      	mov	r0, r3
    6932:	f7ff fe4f 	bl	65d4 <Ftm_Gpt_Ip_SetCounterInitVal>

        /* write the Ftm Modulo Register with 0xFFFF */
        Ftm_Gpt_Ip_WriteModulo(instance, 0xFFFFU);
    6936:	f89d 3007 	ldrb.w	r3, [sp, #7]
    693a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    693e:	4618      	mov	r0, r3
    6940:	f7ff ff64 	bl	680c <Ftm_Gpt_Ip_WriteModulo>

        /* set FTM Enable bit */
        Ftm_Gpt_Ip_SetEnFtmModule(instance, TRUE);
    6944:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6948:	2101      	movs	r1, #1
    694a:	4618      	mov	r0, r3
    694c:	f7ff ff0e 	bl	676c <Ftm_Gpt_Ip_SetEnFtmModule>
#if (FTM_GPT_IP_SET_CLOCK_MODE == STD_ON)
    Ftm_Gpt_Ip_u32InstancePrescaler[instance].clockPrescaler = configPtr->clockPrescaler;
    Ftm_Gpt_Ip_u32InstancePrescaler[instance].clockAlternatePrescaler = configPtr->clockAlternatePrescaler;
#endif
    /* set FTM instance status to initialized */
    Ftm_Gpt_Ip_u32InstanceState[instance] = FTM_GPT_IP_STATUS_INITIALIZED;
    6950:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6954:	4a03      	ldr	r2, [pc, #12]	; (6964 <Ftm_Gpt_Ip_Init+0x7e>)
    6956:	2101      	movs	r1, #1
    6958:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
    695c:	bf00      	nop
    695e:	b003      	add	sp, #12
    6960:	f85d fb04 	ldr.w	pc, [sp], #4
    6964:	1fff8dac 	.word	0x1fff8dac

00006968 <Ftm_Gpt_Ip_InitChannel>:
* @return        void
* @pre           The data structure including the configuration set required for initializing the GPT driver
* @implements    Ftm_Gpt_Ip_InitChannel_Activity
*/
void Ftm_Gpt_Ip_InitChannel(uint8 instance, const Ftm_Gpt_Ip_ChannelConfigType *configPtr)
{
    6968:	b500      	push	{lr}
    696a:	b083      	sub	sp, #12
    696c:	4603      	mov	r3, r0
    696e:	9100      	str	r1, [sp, #0]
    6970:	f88d 3007 	strb.w	r3, [sp, #7]
    DevAssert(FTM_INSTANCE_COUNT > instance);
    DevAssert(FTM_CONTROLS_COUNT > configPtr->hwChannel);
#endif

    /* Disable channels interrupt bit */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, configPtr->hwChannel, FALSE);
    6974:	9b00      	ldr	r3, [sp, #0]
    6976:	7819      	ldrb	r1, [r3, #0]
    6978:	f89d 3007 	ldrb.w	r3, [sp, #7]
    697c:	2200      	movs	r2, #0
    697e:	4618      	mov	r0, r3
    6980:	f7ff fe7a 	bl	6678 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
    /* Clear ClearInterruptFlag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, configPtr->hwChannel);
    6984:	9b00      	ldr	r3, [sp, #0]
    6986:	781a      	ldrb	r2, [r3, #0]
    6988:	f89d 3007 	ldrb.w	r3, [sp, #7]
    698c:	4611      	mov	r1, r2
    698e:	4618      	mov	r0, r3
    6990:	f7ff fe4c 	bl	662c <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* Set Compare Value register to 0xFFFF */
    Ftm_Gpt_Ip_SetCompareValue(instance, configPtr->hwChannel, 0xFFFFU);
    6994:	9b00      	ldr	r3, [sp, #0]
    6996:	7819      	ldrb	r1, [r3, #0]
    6998:	f89d 3007 	ldrb.w	r3, [sp, #7]
    699c:	f64f 72ff 	movw	r2, #65535	; 0xffff
    69a0:	4618      	mov	r0, r3
    69a2:	f7ff ff19 	bl	67d8 <Ftm_Gpt_Ip_SetCompareValue>
    /* Set bit MSA */
    Ftm_Gpt_Ip_ModeSelectA(instance, configPtr->hwChannel, TRUE);
    69a6:	9b00      	ldr	r3, [sp, #0]
    69a8:	7819      	ldrb	r1, [r3, #0]
    69aa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    69ae:	2201      	movs	r2, #1
    69b0:	4618      	mov	r0, r3
    69b2:	f7ff ff41 	bl	6838 <Ftm_Gpt_Ip_ModeSelectA>
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].chInit = TRUE;
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].callback = configPtr->callback;
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].callbackParam = configPtr->callbackParam;
    Ftm_Gpt_Ip_u32ChState[instance][configPtr->hwChannel].channelMode = configPtr->channelMode;
#endif
}
    69b6:	bf00      	nop
    69b8:	b003      	add	sp, #12
    69ba:	f85d fb04 	ldr.w	pc, [sp], #4

000069be <Ftm_Gpt_Ip_Deinit>:
* @return        void
* @pre           The data structure including the configuration set required for initializing the GPT driver.
* @implements    Ftm_Gpt_Ip_Deinit_Activity
*/
void Ftm_Gpt_Ip_Deinit(uint8 instance)
{
    69be:	b500      	push	{lr}
    69c0:	b085      	sub	sp, #20
    69c2:	4603      	mov	r3, r0
    69c4:	f88d 3007 	strb.w	r3, [sp, #7]
    #endif

    uint8 channelIndex;

    /* Reset all channels to default */
    for (channelIndex = 0; channelIndex < FTM_CONTROLS_COUNT; channelIndex++)
    69c8:	2300      	movs	r3, #0
    69ca:	f88d 300f 	strb.w	r3, [sp, #15]
    69ce:	e014      	b.n	69fa <Ftm_Gpt_Ip_Deinit+0x3c>
    {
        /* Disable interrupts */
        Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channelIndex, FALSE );
    69d0:	f89d 100f 	ldrb.w	r1, [sp, #15]
    69d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    69d8:	2200      	movs	r2, #0
    69da:	4618      	mov	r0, r3
    69dc:	f7ff fe4c 	bl	6678 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
        /*Clear interrupt flags*/
        Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channelIndex);
    69e0:	f89d 200f 	ldrb.w	r2, [sp, #15]
    69e4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    69e8:	4611      	mov	r1, r2
    69ea:	4618      	mov	r0, r3
    69ec:	f7ff fe1e 	bl	662c <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    for (channelIndex = 0; channelIndex < FTM_CONTROLS_COUNT; channelIndex++)
    69f0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    69f4:	3301      	adds	r3, #1
    69f6:	f88d 300f 	strb.w	r3, [sp, #15]
    69fa:	f89d 300f 	ldrb.w	r3, [sp, #15]
    69fe:	2b07      	cmp	r3, #7
    6a00:	d9e6      	bls.n	69d0 <Ftm_Gpt_Ip_Deinit+0x12>
    }
    /* Set clock source as 'No clock'. This in effect disables the FTM counter */
    Ftm_Gpt_Ip_SetClockSource(instance, FTM_GPT_IP_CLOCK_SOURCE_NONE);
    6a02:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a06:	2100      	movs	r1, #0
    6a08:	4618      	mov	r0, r3
    6a0a:	f7ff fe65 	bl	66d8 <Ftm_Gpt_Ip_SetClockSource>
    /* clear FTM Enable bit */
    Ftm_Gpt_Ip_SetEnFtmModule(instance, FALSE);
    6a0e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a12:	2100      	movs	r1, #0
    6a14:	4618      	mov	r0, r3
    6a16:	f7ff fea9 	bl	676c <Ftm_Gpt_Ip_SetEnFtmModule>
    /* clearde freeze bits */
    Ftm_Gpt_Ip_SetFreezeBits(instance, FALSE);
    6a1a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a1e:	2100      	movs	r1, #0
    6a20:	4618      	mov	r0, r3
    6a22:	f7ff fda7 	bl	6574 <Ftm_Gpt_Ip_SetFreezeBits>
    /* Set Counter register to 0 and Initial Counter Value to 0 */
    Ftm_Gpt_Ip_SetCounterInitVal(instance, 0U);
    6a26:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a2a:	2100      	movs	r1, #0
    6a2c:	4618      	mov	r0, r3
    6a2e:	f7ff fdd1 	bl	65d4 <Ftm_Gpt_Ip_SetCounterInitVal>
    Ftm_Gpt_Ip_SetCounter(instance, 0U);
    6a32:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a36:	2100      	movs	r1, #0
    6a38:	4618      	mov	r0, r3
    6a3a:	f7ff fde1 	bl	6600 <Ftm_Gpt_Ip_SetCounter>
    /* set FTM instance status to uninitialized */
    Ftm_Gpt_Ip_u32InstanceState[instance] = FTM_GPT_IP_STATUS_UNINITIALIZED;
    6a3e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a42:	4a04      	ldr	r2, [pc, #16]	; (6a54 <Ftm_Gpt_Ip_Deinit+0x96>)
    6a44:	2100      	movs	r1, #0
    6a46:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
    6a4a:	bf00      	nop
    6a4c:	b005      	add	sp, #20
    6a4e:	f85d fb04 	ldr.w	pc, [sp], #4
    6a52:	bf00      	nop
    6a54:	1fff8dac 	.word	0x1fff8dac

00006a58 <Ftm_Gpt_Ip_StartCounting>:
* @return        void
* @pre           The driver needs to be initialized. This function is called for starting the FTM timer channel.
* @implements    Ftm_Gpt_Ip_StartCounting_Activity
*/
void Ftm_Gpt_Ip_StartCounting(uint8 instance, uint8 channel, uint16 compareValue)
{
    6a58:	b500      	push	{lr}
    6a5a:	b085      	sub	sp, #20
    6a5c:	4603      	mov	r3, r0
    6a5e:	f88d 3007 	strb.w	r3, [sp, #7]
    6a62:	460b      	mov	r3, r1
    6a64:	f88d 3006 	strb.w	r3, [sp, #6]
    6a68:	4613      	mov	r3, r2
    6a6a:	f8ad 3004 	strh.w	r3, [sp, #4]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
    DevAssert(FTM_INSTANCE_COUNT > instance);
    DevAssert(FTM_CONTROLS_COUNT > channel);
#endif
    uint32 counterValue;
    uint32 currentCntValue = Ftm_Gpt_Ip_GetCntValue(instance);
    6a6e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6a72:	4618      	mov	r0, r3
    6a74:	f7ff fd6e 	bl	6554 <Ftm_Gpt_Ip_GetCntValue>
    6a78:	9002      	str	r0, [sp, #8]

    if ((uint32)(currentCntValue + compareValue) > FTM_CNT_MAX_VALUE)
    6a7a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    6a7e:	9b02      	ldr	r3, [sp, #8]
    6a80:	4413      	add	r3, r2
    6a82:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
    6a86:	d308      	bcc.n	6a9a <Ftm_Gpt_Ip_StartCounting+0x42>
    {
        counterValue = (uint32)(compareValue - (FTM_CNT_MAX_VALUE - currentCntValue));
    6a88:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    6a8c:	9b02      	ldr	r3, [sp, #8]
    6a8e:	4413      	add	r3, r2
    6a90:	f5a3 437f 	sub.w	r3, r3, #65280	; 0xff00
    6a94:	3bff      	subs	r3, #255	; 0xff
    6a96:	9303      	str	r3, [sp, #12]
    6a98:	e004      	b.n	6aa4 <Ftm_Gpt_Ip_StartCounting+0x4c>
    }
    else
    {
        counterValue = (uint32)(currentCntValue + compareValue);
    6a9a:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    6a9e:	9a02      	ldr	r2, [sp, #8]
    6aa0:	4413      	add	r3, r2
    6aa2:	9303      	str	r3, [sp, #12]
    }
    /* Set new compare value */
    Ftm_Gpt_Ip_SetCompareValue(instance, channel, counterValue);
    6aa4:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6aa8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6aac:	9a03      	ldr	r2, [sp, #12]
    6aae:	4618      	mov	r0, r3
    6ab0:	f7ff fe92 	bl	67d8 <Ftm_Gpt_Ip_SetCompareValue>
    /* Save compare value */
    Ftm_Gpt_Ip_u32TargetValue[instance][channel] = compareValue;
    6ab4:	f89d 1007 	ldrb.w	r1, [sp, #7]
    6ab8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    6abc:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    6ac0:	480c      	ldr	r0, [pc, #48]	; (6af4 <Ftm_Gpt_Ip_StartCounting+0x9c>)
    6ac2:	00c9      	lsls	r1, r1, #3
    6ac4:	440b      	add	r3, r1
    6ac6:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    /* Clear CHF flag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance,channel);
    6aca:	f89d 2006 	ldrb.w	r2, [sp, #6]
    6ace:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6ad2:	4611      	mov	r1, r2
    6ad4:	4618      	mov	r0, r3
    6ad6:	f7ff fda9 	bl	662c <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* Enable interrupt */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, TRUE);
    6ada:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6ade:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6ae2:	2201      	movs	r2, #1
    6ae4:	4618      	mov	r0, r3
    6ae6:	f7ff fdc7 	bl	6678 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>

}
    6aea:	bf00      	nop
    6aec:	b005      	add	sp, #20
    6aee:	f85d fb04 	ldr.w	pc, [sp], #4
    6af2:	bf00      	nop
    6af4:	1fff8d2c 	.word	0x1fff8d2c

00006af8 <Ftm_Gpt_Ip_StartTimer>:
 *                  - enables the FTM counter
 * @pre           The driver needs to be initialized.
 * @implements    Ftm_Gpt_Ip_StartTimer_Activity
 */
void Ftm_Gpt_Ip_StartTimer(uint8 instance, uint16 counterValue)
{
    6af8:	b500      	push	{lr}
    6afa:	b083      	sub	sp, #12
    6afc:	4603      	mov	r3, r0
    6afe:	460a      	mov	r2, r1
    6b00:	f88d 3007 	strb.w	r3, [sp, #7]
    6b04:	4613      	mov	r3, r2
    6b06:	f8ad 3004 	strh.w	r3, [sp, #4]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
    DevAssert(FTM_INSTANCE_COUNT > instance);
#endif
    if (instance < FTM_INSTANCE_COUNT)
    6b0a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b0e:	2b03      	cmp	r3, #3
    6b10:	d814      	bhi.n	6b3c <Ftm_Gpt_Ip_StartTimer+0x44>
    {
        if (FTM_GPT_IP_STATUS_INITIALIZED == Ftm_Gpt_Ip_u32InstanceState[instance])
    6b12:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b16:	4a0b      	ldr	r2, [pc, #44]	; (6b44 <Ftm_Gpt_Ip_StartTimer+0x4c>)
    6b18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6b1c:	2b01      	cmp	r3, #1
    6b1e:	d10d      	bne.n	6b3c <Ftm_Gpt_Ip_StartTimer+0x44>
        {
            /* Set the new value counter */
            Ftm_Gpt_Ip_SetCounterInitVal(instance, counterValue);
    6b20:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    6b24:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b28:	4611      	mov	r1, r2
    6b2a:	4618      	mov	r0, r3
    6b2c:	f7ff fd52 	bl	65d4 <Ftm_Gpt_Ip_SetCounterInitVal>
            /* set FTM Enable bit */
            Ftm_Gpt_Ip_SetEnFtmModule(instance, TRUE);
    6b30:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b34:	2101      	movs	r1, #1
    6b36:	4618      	mov	r0, r3
    6b38:	f7ff fe18 	bl	676c <Ftm_Gpt_Ip_SetEnFtmModule>
        }
    }
}
    6b3c:	bf00      	nop
    6b3e:	b003      	add	sp, #12
    6b40:	f85d fb04 	ldr.w	pc, [sp], #4
    6b44:	1fff8dac 	.word	0x1fff8dac

00006b48 <Ftm_Gpt_Ip_StopTimer>:
* @return        void
* @pre           The driver needs to be initialized. This function is called for stoping the FTM timer channel.
* @implements    Ftm_Gpt_Ip_StopTimer_Activity
*/
void Ftm_Gpt_Ip_StopTimer(uint8 instance)
{
    6b48:	b500      	push	{lr}
    6b4a:	b083      	sub	sp, #12
    6b4c:	4603      	mov	r3, r0
    6b4e:	f88d 3007 	strb.w	r3, [sp, #7]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
DevAssert(FTM_INSTANCE_COUNT > instance);
#endif
    /* clear FTM Enable bit */
    Ftm_Gpt_Ip_SetEnFtmModule(instance, FALSE);
    6b52:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b56:	2100      	movs	r1, #0
    6b58:	4618      	mov	r0, r3
    6b5a:	f7ff fe07 	bl	676c <Ftm_Gpt_Ip_SetEnFtmModule>
    /* Set clock source as 'No clock'. This in effect disables the FTM counter */
    Ftm_Gpt_Ip_SetClockSource(instance, FTM_GPT_IP_CLOCK_SOURCE_NONE);
    6b5e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b62:	2100      	movs	r1, #0
    6b64:	4618      	mov	r0, r3
    6b66:	f7ff fdb7 	bl	66d8 <Ftm_Gpt_Ip_SetClockSource>
}
    6b6a:	bf00      	nop
    6b6c:	b003      	add	sp, #12
    6b6e:	f85d fb04 	ldr.w	pc, [sp], #4

00006b72 <Ftm_Gpt_Ip_EnableChannelInterrupt>:
* @return       void
* @pre          The driver needs to be initialized.
* @implements   Ftm_Gpt_Ip_EnableChannelInterrupt_Activity
*/
void Ftm_Gpt_Ip_EnableChannelInterrupt(uint8 instance, uint8 channel)
{
    6b72:	b500      	push	{lr}
    6b74:	b083      	sub	sp, #12
    6b76:	4603      	mov	r3, r0
    6b78:	460a      	mov	r2, r1
    6b7a:	f88d 3007 	strb.w	r3, [sp, #7]
    6b7e:	4613      	mov	r3, r2
    6b80:	f88d 3006 	strb.w	r3, [sp, #6]
DevAssert(FTM_INSTANCE_COUNT > instance);
DevAssert(FTM_CONTROLS_COUNT > channel);
#endif

     /* Clear interrupt flag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channel);
    6b84:	f89d 2006 	ldrb.w	r2, [sp, #6]
    6b88:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b8c:	4611      	mov	r1, r2
    6b8e:	4618      	mov	r0, r3
    6b90:	f7ff fd4c 	bl	662c <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
    /* Enable channel interrupt */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, TRUE);
    6b94:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6b98:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6b9c:	2201      	movs	r2, #1
    6b9e:	4618      	mov	r0, r3
    6ba0:	f7ff fd6a 	bl	6678 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
}
    6ba4:	bf00      	nop
    6ba6:	b003      	add	sp, #12
    6ba8:	f85d fb04 	ldr.w	pc, [sp], #4

00006bac <Ftm_Gpt_Ip_DisableChannelInterrupt>:
* @return        void
* @pre           The driver needs to be initialized.
* @implements    Ftm_Gpt_Ip_DisableChannelInterrupt_Activity
*/
void Ftm_Gpt_Ip_DisableChannelInterrupt(uint8 instance, uint8 channel)
{
    6bac:	b500      	push	{lr}
    6bae:	b083      	sub	sp, #12
    6bb0:	4603      	mov	r3, r0
    6bb2:	460a      	mov	r2, r1
    6bb4:	f88d 3007 	strb.w	r3, [sp, #7]
    6bb8:	4613      	mov	r3, r2
    6bba:	f88d 3006 	strb.w	r3, [sp, #6]
DevAssert(FTM_INSTANCE_COUNT > instance);
DevAssert(FTM_CONTROLS_COUNT > channel);
#endif

    /* Disable interrupt */
    Ftm_Gpt_Ip_SetChannelEnableInterrupt(instance, channel, FALSE);
    6bbe:	f89d 1006 	ldrb.w	r1, [sp, #6]
    6bc2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6bc6:	2200      	movs	r2, #0
    6bc8:	4618      	mov	r0, r3
    6bca:	f7ff fd55 	bl	6678 <Ftm_Gpt_Ip_SetChannelEnableInterrupt>
    /* Clear interrupt flag */
    Ftm_Gpt_Ip_ClearChInterruptStatusFlag(instance, channel);
    6bce:	f89d 2006 	ldrb.w	r2, [sp, #6]
    6bd2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6bd6:	4611      	mov	r1, r2
    6bd8:	4618      	mov	r0, r3
    6bda:	f7ff fd27 	bl	662c <Ftm_Gpt_Ip_ClearChInterruptStatusFlag>
}
    6bde:	bf00      	nop
    6be0:	b003      	add	sp, #12
    6be2:	f85d fb04 	ldr.w	pc, [sp], #4

00006be6 <Ftm_Gpt_Ip_SetHalfCycleReloadPoint>:
* @return
* @pre           The driver needs to be initialized.
* @implements    Ftm_Gpt_Ip_SetHalfCycleReloadPoint_Activity
*/
void Ftm_Gpt_Ip_SetHalfCycleReloadPoint(uint8 instance, uint16 reloadPoint)
{
    6be6:	b500      	push	{lr}
    6be8:	b083      	sub	sp, #12
    6bea:	4603      	mov	r3, r0
    6bec:	460a      	mov	r2, r1
    6bee:	f88d 3007 	strb.w	r3, [sp, #7]
    6bf2:	4613      	mov	r3, r2
    6bf4:	f8ad 3004 	strh.w	r3, [sp, #4]
#if FTM_GPT_IP_DEV_ERROR_DETECT == STD_ON
DevAssert(FTM_INSTANCE_COUNT > instance);
#endif
    Ftm_Gpt_Ip_SetHalfCycleValue(ftmGptBase[instance], reloadPoint);
    6bf8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6bfc:	4a06      	ldr	r2, [pc, #24]	; (6c18 <Ftm_Gpt_Ip_SetHalfCycleReloadPoint+0x32>)
    6bfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c02:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    6c06:	4611      	mov	r1, r2
    6c08:	4618      	mov	r0, r3
    6c0a:	f7ff fe5f 	bl	68cc <Ftm_Gpt_Ip_SetHalfCycleValue>
}
    6c0e:	bf00      	nop
    6c10:	b003      	add	sp, #12
    6c12:	f85d fb04 	ldr.w	pc, [sp], #4
    6c16:	bf00      	nop
    6c18:	0000ada8 	.word	0x0000ada8

00006c1c <Ftm_Gpt_Ip_GetChInterruptStatusFlag>:
{
    6c1c:	b082      	sub	sp, #8
    6c1e:	4603      	mov	r3, r0
    6c20:	460a      	mov	r2, r1
    6c22:	f88d 3007 	strb.w	r3, [sp, #7]
    6c26:	4613      	mov	r3, r2
    6c28:	f88d 3006 	strb.w	r3, [sp, #6]
    return (0U != (ftmGptBase[instance]->CONTROLS[channel].CSC & FTM_CSC_CHF_MASK)) ? TRUE : FALSE;
    6c2c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6c30:	4a09      	ldr	r2, [pc, #36]	; (6c58 <Ftm_Gpt_Ip_GetChInterruptStatusFlag+0x3c>)
    6c32:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6c36:	f89d 3006 	ldrb.w	r3, [sp, #6]
    6c3a:	3301      	adds	r3, #1
    6c3c:	00db      	lsls	r3, r3, #3
    6c3e:	4413      	add	r3, r2
    6c40:	685b      	ldr	r3, [r3, #4]
    6c42:	f003 0380 	and.w	r3, r3, #128	; 0x80
    6c46:	2b00      	cmp	r3, #0
    6c48:	bf14      	ite	ne
    6c4a:	2301      	movne	r3, #1
    6c4c:	2300      	moveq	r3, #0
    6c4e:	b2db      	uxtb	r3, r3
}
    6c50:	4618      	mov	r0, r3
    6c52:	b002      	add	sp, #8
    6c54:	4770      	bx	lr
    6c56:	bf00      	nop
    6c58:	0000ada8 	.word	0x0000ada8

00006c5c <Ftm_Gpt_Ip_GetCntValue>:
{
    6c5c:	b082      	sub	sp, #8
    6c5e:	4603      	mov	r3, r0
    6c60:	f88d 3007 	strb.w	r3, [sp, #7]
    return ftmGptBase[instance]->CNT;
    6c64:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6c68:	4a03      	ldr	r2, [pc, #12]	; (6c78 <Ftm_Gpt_Ip_GetCntValue+0x1c>)
    6c6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6c6e:	685b      	ldr	r3, [r3, #4]
}
    6c70:	4618      	mov	r0, r3
    6c72:	b002      	add	sp, #8
    6c74:	4770      	bx	lr
    6c76:	bf00      	nop
    6c78:	0000ada8 	.word	0x0000ada8

00006c7c <Ftm_Gpt_Ip_GetCompareValue>:
 *
 * @return      compare value (CV)
 *
 */
static inline uint32 Ftm_Gpt_Ip_GetCompareValue(uint8 instance, uint8 channel)
{
    6c7c:	b082      	sub	sp, #8
    6c7e:	4603      	mov	r3, r0
    6c80:	460a      	mov	r2, r1
    6c82:	f88d 3007 	strb.w	r3, [sp, #7]
    6c86:	4613      	mov	r3, r2
    6c88:	f88d 3006 	strb.w	r3, [sp, #6]
    return ftmGptBase[instance]->CONTROLS[channel].CV;
    6c8c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6c90:	4a05      	ldr	r2, [pc, #20]	; (6ca8 <Ftm_Gpt_Ip_GetCompareValue+0x2c>)
    6c92:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    6c96:	f89d 3006 	ldrb.w	r3, [sp, #6]
    6c9a:	3301      	adds	r3, #1
    6c9c:	00db      	lsls	r3, r3, #3
    6c9e:	4413      	add	r3, r2
    6ca0:	689b      	ldr	r3, [r3, #8]
}
    6ca2:	4618      	mov	r0, r3
    6ca4:	b002      	add	sp, #8
    6ca6:	4770      	bx	lr
    6ca8:	0000ada8 	.word	0x0000ada8

00006cac <Gpt_Ipw_InitInstances>:
*
* @return       void
* @pre          The driver needs to be initialized.
*/
void Gpt_Ipw_InitInstances(const Gpt_ConfigType * configPtr)
{
    6cac:	b500      	push	{lr}
    6cae:	b085      	sub	sp, #20
    6cb0:	9001      	str	r0, [sp, #4]

    uint8 index = 0U;
    6cb2:	2300      	movs	r3, #0
    6cb4:	f88d 300f 	strb.w	r3, [sp, #15]

    for(index = 0; index < configPtr->instanceCount; index++)
    6cb8:	2300      	movs	r3, #0
    6cba:	f88d 300f 	strb.w	r3, [sp, #15]
    6cbe:	e022      	b.n	6d06 <Gpt_Ipw_InitInstances+0x5a>
    {
        switch((*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].instanceType)
    6cc0:	9b01      	ldr	r3, [sp, #4]
    6cc2:	68da      	ldr	r2, [r3, #12]
    6cc4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6cc8:	011b      	lsls	r3, r3, #4
    6cca:	4413      	add	r3, r2
    6ccc:	681b      	ldr	r3, [r3, #0]
    6cce:	2b00      	cmp	r3, #0
    6cd0:	d113      	bne.n	6cfa <Gpt_Ipw_InitInstances+0x4e>
        {
#if (FTM_GPT_IP_USED == STD_ON)
            case(GPT_FTM_MODULE):
            {
                Ftm_Gpt_Ip_Init((*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].instance,
    6cd2:	9b01      	ldr	r3, [sp, #4]
    6cd4:	68da      	ldr	r2, [r3, #12]
    6cd6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6cda:	011b      	lsls	r3, r3, #4
    6cdc:	4413      	add	r3, r2
    6cde:	3304      	adds	r3, #4
    6ce0:	7818      	ldrb	r0, [r3, #0]
                                (*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].Gpt_Ipw_InstanceConfig.Ftm_Gpt_Ip_InstanceConfig);
    6ce2:	9b01      	ldr	r3, [sp, #4]
    6ce4:	68da      	ldr	r2, [r3, #12]
                Ftm_Gpt_Ip_Init((*(configPtr->Gpt_Ipw_HwInstanceConfig))[index].instance,
    6ce6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6cea:	011b      	lsls	r3, r3, #4
    6cec:	4413      	add	r3, r2
    6cee:	3308      	adds	r3, #8
    6cf0:	681b      	ldr	r3, [r3, #0]
    6cf2:	4619      	mov	r1, r3
    6cf4:	f7ff fdf7 	bl	68e6 <Ftm_Gpt_Ip_Init>
            }
            break;
    6cf8:	e000      	b.n	6cfc <Gpt_Ipw_InitInstances+0x50>
            break;
#endif

            default:
                /*This switch branch is empty because it shall not be executed for normal behaviour*/
            break;
    6cfa:	bf00      	nop
    for(index = 0; index < configPtr->instanceCount; index++)
    6cfc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6d00:	3301      	adds	r3, #1
    6d02:	f88d 300f 	strb.w	r3, [sp, #15]
    6d06:	9b01      	ldr	r3, [sp, #4]
    6d08:	7a1b      	ldrb	r3, [r3, #8]
    6d0a:	f89d 200f 	ldrb.w	r2, [sp, #15]
    6d0e:	429a      	cmp	r2, r3
    6d10:	d3d6      	bcc.n	6cc0 <Gpt_Ipw_InitInstances+0x14>
        }
    }
    return;
    6d12:	bf00      	nop
}
    6d14:	b005      	add	sp, #20
    6d16:	f85d fb04 	ldr.w	pc, [sp], #4

00006d1a <Gpt_Ipw_Init>:
* @param[in]    pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return       void
* @pre          The driver needs to be initialized.
*/
void Gpt_Ipw_Init(const Gpt_Ipw_HwChannelConfigType *pHwChannelConfig)
{
    6d1a:	b500      	push	{lr}
    6d1c:	b083      	sub	sp, #12
    6d1e:	9001      	str	r0, [sp, #4]

    switch(pHwChannelConfig->instanceType)
    6d20:	9b01      	ldr	r3, [sp, #4]
    6d22:	681b      	ldr	r3, [r3, #0]
    6d24:	2b00      	cmp	r3, #0
    6d26:	d108      	bne.n	6d3a <Gpt_Ipw_Init+0x20>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {
            Ftm_Gpt_Ip_InitChannel(pHwChannelConfig->instance,
    6d28:	9b01      	ldr	r3, [sp, #4]
    6d2a:	791a      	ldrb	r2, [r3, #4]
    6d2c:	9b01      	ldr	r3, [sp, #4]
    6d2e:	689b      	ldr	r3, [r3, #8]
    6d30:	4619      	mov	r1, r3
    6d32:	4610      	mov	r0, r2
    6d34:	f7ff fe18 	bl	6968 <Ftm_Gpt_Ip_InitChannel>
                                   pHwChannelConfig->Gpt_Ipw_ChannelConfig.Ftm_Gpt_Ip_ChannelConfig);
        }
        break;
    6d38:	e000      	b.n	6d3c <Gpt_Ipw_Init+0x22>
        }
            break;
#endif
        default:
            /* This switch branch is empty because it shall not be executed for normal behaviour */
        break;
    6d3a:	bf00      	nop
    }
    return;
    6d3c:	bf00      	nop
}
    6d3e:	b003      	add	sp, #12
    6d40:	f85d fb04 	ldr.w	pc, [sp], #4

00006d44 <Gpt_Ipw_StartTimer>:
* @param[in]     uValue              Timeout period (in ticks) after which a notification shall occur (if enabled).
* @return        void
* @pre           The driver needs to be initialized.Call Gpt_StartTimer before.
*/
Std_ReturnType Gpt_Ipw_StartTimer(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig, Gpt_ValueType uValue)
{
    6d44:	b500      	push	{lr}
    6d46:	b085      	sub	sp, #20
    6d48:	9001      	str	r0, [sp, #4]
    6d4a:	9100      	str	r1, [sp, #0]

    Std_ReturnType returnValue = (Std_ReturnType)E_NOT_OK;
    6d4c:	2301      	movs	r3, #1
    6d4e:	f88d 300f 	strb.w	r3, [sp, #15]

    switch(pHwChannelConfig->instanceType)
    6d52:	9b01      	ldr	r3, [sp, #4]
    6d54:	681b      	ldr	r3, [r3, #0]
    6d56:	2b00      	cmp	r3, #0
    6d58:	d10c      	bne.n	6d74 <Gpt_Ipw_StartTimer+0x30>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
            {
                Ftm_Gpt_Ip_StartCounting(pHwChannelConfig->instance,
    6d5a:	9b01      	ldr	r3, [sp, #4]
    6d5c:	7918      	ldrb	r0, [r3, #4]
    6d5e:	9b01      	ldr	r3, [sp, #4]
    6d60:	795b      	ldrb	r3, [r3, #5]
    6d62:	9a00      	ldr	r2, [sp, #0]
    6d64:	b292      	uxth	r2, r2
    6d66:	4619      	mov	r1, r3
    6d68:	f7ff fe76 	bl	6a58 <Ftm_Gpt_Ip_StartCounting>
                                         pHwChannelConfig->channel,
                                         (uint16)uValue);
                returnValue = (Std_ReturnType)E_OK;
    6d6c:	2300      	movs	r3, #0
    6d6e:	f88d 300f 	strb.w	r3, [sp, #15]
            }
        break;
    6d72:	e000      	b.n	6d76 <Gpt_Ipw_StartTimer+0x32>
            }
            break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour */
        break;
    6d74:	bf00      	nop
    }

    return returnValue;
    6d76:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    6d7a:	4618      	mov	r0, r3
    6d7c:	b005      	add	sp, #20
    6d7e:	f85d fb04 	ldr.w	pc, [sp], #4

00006d82 <Gpt_Ipw_GetTimeElapsed>:
* @pre           The driver needs to be initialized.Call GetTimeElapsed before.
*
*/
Gpt_ValueType Gpt_Ipw_GetTimeElapsed(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig,
                                                      Gpt_HwChannelInfoType * pReturnHwChannelInfo)
{
    6d82:	b500      	push	{lr}
    6d84:	b085      	sub	sp, #20
    6d86:	9001      	str	r0, [sp, #4]
    6d88:	9100      	str	r1, [sp, #0]
    uint32 returnValue;

    switch(pHwChannelConfig->instanceType)
    6d8a:	9b01      	ldr	r3, [sp, #4]
    6d8c:	681b      	ldr	r3, [r3, #0]
    6d8e:	2b00      	cmp	r3, #0
    6d90:	d105      	bne.n	6d9e <Gpt_Ipw_GetTimeElapsed+0x1c>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {
            returnValue = Gpt_Ipw_FtmGetTimeElapsed(pHwChannelConfig, pReturnHwChannelInfo);
    6d92:	9900      	ldr	r1, [sp, #0]
    6d94:	9801      	ldr	r0, [sp, #4]
    6d96:	f7f9 fdbd 	bl	914 <Gpt_Ipw_FtmGetTimeElapsed>
    6d9a:	9003      	str	r0, [sp, #12]
        }
        break;
    6d9c:	e002      	b.n	6da4 <Gpt_Ipw_GetTimeElapsed+0x22>
        break;
#endif

        default:
             /* This switch branch is empty because it shall not be executed for normal behaviour */
             returnValue = 0U;
    6d9e:	2300      	movs	r3, #0
    6da0:	9303      	str	r3, [sp, #12]
        break;
    6da2:	bf00      	nop
    }
    return (Gpt_ValueType)returnValue;
    6da4:	9b03      	ldr	r3, [sp, #12]
}
    6da6:	4618      	mov	r0, r3
    6da8:	b005      	add	sp, #20
    6daa:	f85d fb04 	ldr.w	pc, [sp], #4

00006dae <Gpt_Ipw_StopTimer>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized.Call StopTimer before.
*/
void Gpt_Ipw_StopTimer(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    6dae:	b500      	push	{lr}
    6db0:	b083      	sub	sp, #12
    6db2:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    6db4:	9b01      	ldr	r3, [sp, #4]
    6db6:	681b      	ldr	r3, [r3, #0]
    6db8:	2b00      	cmp	r3, #0
    6dba:	d108      	bne.n	6dce <Gpt_Ipw_StopTimer+0x20>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {

            Ftm_Gpt_Ip_DisableChannelInterrupt(pHwChannelConfig->instance,
    6dbc:	9b01      	ldr	r3, [sp, #4]
    6dbe:	791a      	ldrb	r2, [r3, #4]
    6dc0:	9b01      	ldr	r3, [sp, #4]
    6dc2:	795b      	ldrb	r3, [r3, #5]
    6dc4:	4619      	mov	r1, r3
    6dc6:	4610      	mov	r0, r2
    6dc8:	f7ff fef0 	bl	6bac <Ftm_Gpt_Ip_DisableChannelInterrupt>
                                               pHwChannelConfig->channel);
        }
        break;
    6dcc:	e000      	b.n	6dd0 <Gpt_Ipw_StopTimer+0x22>
        }
            break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    6dce:	bf00      	nop
    }

    return;
    6dd0:	bf00      	nop
}
    6dd2:	b003      	add	sp, #12
    6dd4:	f85d fb04 	ldr.w	pc, [sp], #4

00006dd8 <Gpt_Ipw_EnableInterrupt>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized.
*/
void Gpt_Ipw_EnableInterrupt(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    6dd8:	b082      	sub	sp, #8
    6dda:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    6ddc:	9b01      	ldr	r3, [sp, #4]
    6dde:	681b      	ldr	r3, [r3, #0]
    6de0:	2b00      	cmp	r3, #0
        }
        break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    6de2:	bf00      	nop
    }

    return;
    6de4:	bf00      	nop
}
    6de6:	b002      	add	sp, #8
    6de8:	4770      	bx	lr

00006dea <Gpt_Ipw_DeInit>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized. On/Off by the configuration parameter: GPT_DEINIT_API
*/
void Gpt_Ipw_DeInit(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    6dea:	b500      	push	{lr}
    6dec:	b083      	sub	sp, #12
    6dee:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    6df0:	9b01      	ldr	r3, [sp, #4]
    6df2:	681b      	ldr	r3, [r3, #0]
    6df4:	2b00      	cmp	r3, #0
    6df6:	d105      	bne.n	6e04 <Gpt_Ipw_DeInit+0x1a>
    {
#if (FTM_GPT_IP_USED == STD_ON)
        case(GPT_FTM_MODULE):
        {
           Ftm_Gpt_Ip_Deinit(pHwChannelConfig->instance);
    6df8:	9b01      	ldr	r3, [sp, #4]
    6dfa:	791b      	ldrb	r3, [r3, #4]
    6dfc:	4618      	mov	r0, r3
    6dfe:	f7ff fdde 	bl	69be <Ftm_Gpt_Ip_Deinit>
        }
        break;
    6e02:	e000      	b.n	6e06 <Gpt_Ipw_DeInit+0x1c>
        }
        break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    6e04:	bf00      	nop
    }
    return;
    6e06:	bf00      	nop
}
    6e08:	b003      	add	sp, #12
    6e0a:	f85d fb04 	ldr.w	pc, [sp], #4

00006e0e <Gpt_Ipw_DisableInterrupt>:
* @param[in]     pHwChannelConfig    Pointer to the channel configuration structure dependent by platform
* @return        void
* @pre           The driver needs to be initialized.On/Off by the configuration parameter: GPT_ENABLE_DISABLE_NOTIFICATION_API
*/
void Gpt_Ipw_DisableInterrupt(const Gpt_Ipw_HwChannelConfigType * pHwChannelConfig)
{
    6e0e:	b082      	sub	sp, #8
    6e10:	9001      	str	r0, [sp, #4]
    switch(pHwChannelConfig->instanceType)
    6e12:	9b01      	ldr	r3, [sp, #4]
    6e14:	681b      	ldr	r3, [r3, #0]
    6e16:	2b00      	cmp	r3, #0
        }
        break;
#endif
        default:
            /*This switch branch is empty because it shall not be executed for normal behaviour*/
        break;
    6e18:	bf00      	nop
    }

    return;
    6e1a:	bf00      	nop
}
    6e1c:	b002      	add	sp, #8
    6e1e:	4770      	bx	lr

00006e20 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    6e20:	b500      	push	{lr}
    6e22:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6e24:	f7f9 fec2 	bl	bac <Sys_GetCoreID>
    6e28:	4603      	mov	r3, r0
    6e2a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
    6e2c:	4a10      	ldr	r2, [pc, #64]	; (6e70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    6e2e:	9b01      	ldr	r3, [sp, #4]
    6e30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e34:	2b00      	cmp	r3, #0
    6e36:	d10d      	bne.n	6e54 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6e38:	f7f9 fdce 	bl	9d8 <Port_schm_read_msr>
    6e3c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6e3e:	9b00      	ldr	r3, [sp, #0]
    6e40:	f003 0301 	and.w	r3, r3, #1
    6e44:	2b00      	cmp	r3, #0
    6e46:	d100      	bne.n	6e4a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6e48:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    6e4a:	490a      	ldr	r1, [pc, #40]	; (6e74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
    6e4c:	9b01      	ldr	r3, [sp, #4]
    6e4e:	9a00      	ldr	r2, [sp, #0]
    6e50:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
    6e54:	4a06      	ldr	r2, [pc, #24]	; (6e70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    6e56:	9b01      	ldr	r3, [sp, #4]
    6e58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e5c:	1c5a      	adds	r2, r3, #1
    6e5e:	4904      	ldr	r1, [pc, #16]	; (6e70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
    6e60:	9b01      	ldr	r3, [sp, #4]
    6e62:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6e66:	bf00      	nop
    6e68:	b003      	add	sp, #12
    6e6a:	f85d fb04 	ldr.w	pc, [sp], #4
    6e6e:	bf00      	nop
    6e70:	1fff8dc0 	.word	0x1fff8dc0
    6e74:	1fff8dbc 	.word	0x1fff8dbc

00006e78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
    6e78:	b500      	push	{lr}
    6e7a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6e7c:	f7f9 fe96 	bl	bac <Sys_GetCoreID>
    6e80:	4603      	mov	r3, r0
    6e82:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
    6e84:	4a0d      	ldr	r2, [pc, #52]	; (6ebc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    6e86:	9b01      	ldr	r3, [sp, #4]
    6e88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e8c:	1e5a      	subs	r2, r3, #1
    6e8e:	490b      	ldr	r1, [pc, #44]	; (6ebc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    6e90:	9b01      	ldr	r3, [sp, #4]
    6e92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    6e96:	4a0a      	ldr	r2, [pc, #40]	; (6ec0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
    6e98:	9b01      	ldr	r3, [sp, #4]
    6e9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e9e:	f003 0301 	and.w	r3, r3, #1
    6ea2:	2b00      	cmp	r3, #0
    6ea4:	d106      	bne.n	6eb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    6ea6:	4a05      	ldr	r2, [pc, #20]	; (6ebc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
    6ea8:	9b01      	ldr	r3, [sp, #4]
    6eaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6eae:	2b00      	cmp	r3, #0
    6eb0:	d100      	bne.n	6eb4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6eb2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6eb4:	bf00      	nop
    6eb6:	b003      	add	sp, #12
    6eb8:	f85d fb04 	ldr.w	pc, [sp], #4
    6ebc:	1fff8dc0 	.word	0x1fff8dc0
    6ec0:	1fff8dbc 	.word	0x1fff8dbc

00006ec4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    6ec4:	b500      	push	{lr}
    6ec6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6ec8:	f7f9 fe70 	bl	bac <Sys_GetCoreID>
    6ecc:	4603      	mov	r3, r0
    6ece:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
    6ed0:	4a10      	ldr	r2, [pc, #64]	; (6f14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    6ed2:	9b01      	ldr	r3, [sp, #4]
    6ed4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6ed8:	2b00      	cmp	r3, #0
    6eda:	d10d      	bne.n	6ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6edc:	f7f9 fd7c 	bl	9d8 <Port_schm_read_msr>
    6ee0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6ee2:	9b00      	ldr	r3, [sp, #0]
    6ee4:	f003 0301 	and.w	r3, r3, #1
    6ee8:	2b00      	cmp	r3, #0
    6eea:	d100      	bne.n	6eee <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6eec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    6eee:	490a      	ldr	r1, [pc, #40]	; (6f18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
    6ef0:	9b01      	ldr	r3, [sp, #4]
    6ef2:	9a00      	ldr	r2, [sp, #0]
    6ef4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
    6ef8:	4a06      	ldr	r2, [pc, #24]	; (6f14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    6efa:	9b01      	ldr	r3, [sp, #4]
    6efc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f00:	1c5a      	adds	r2, r3, #1
    6f02:	4904      	ldr	r1, [pc, #16]	; (6f14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
    6f04:	9b01      	ldr	r3, [sp, #4]
    6f06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6f0a:	bf00      	nop
    6f0c:	b003      	add	sp, #12
    6f0e:	f85d fb04 	ldr.w	pc, [sp], #4
    6f12:	bf00      	nop
    6f14:	1fff8dc8 	.word	0x1fff8dc8
    6f18:	1fff8dc4 	.word	0x1fff8dc4

00006f1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
    6f1c:	b500      	push	{lr}
    6f1e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6f20:	f7f9 fe44 	bl	bac <Sys_GetCoreID>
    6f24:	4603      	mov	r3, r0
    6f26:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
    6f28:	4a0d      	ldr	r2, [pc, #52]	; (6f60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    6f2a:	9b01      	ldr	r3, [sp, #4]
    6f2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f30:	1e5a      	subs	r2, r3, #1
    6f32:	490b      	ldr	r1, [pc, #44]	; (6f60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    6f34:	9b01      	ldr	r3, [sp, #4]
    6f36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    6f3a:	4a0a      	ldr	r2, [pc, #40]	; (6f64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
    6f3c:	9b01      	ldr	r3, [sp, #4]
    6f3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f42:	f003 0301 	and.w	r3, r3, #1
    6f46:	2b00      	cmp	r3, #0
    6f48:	d106      	bne.n	6f58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    6f4a:	4a05      	ldr	r2, [pc, #20]	; (6f60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
    6f4c:	9b01      	ldr	r3, [sp, #4]
    6f4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f52:	2b00      	cmp	r3, #0
    6f54:	d100      	bne.n	6f58 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6f56:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6f58:	bf00      	nop
    6f5a:	b003      	add	sp, #12
    6f5c:	f85d fb04 	ldr.w	pc, [sp], #4
    6f60:	1fff8dc8 	.word	0x1fff8dc8
    6f64:	1fff8dc4 	.word	0x1fff8dc4

00006f68 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    6f68:	b500      	push	{lr}
    6f6a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6f6c:	f7f9 fe1e 	bl	bac <Sys_GetCoreID>
    6f70:	4603      	mov	r3, r0
    6f72:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
    6f74:	4a10      	ldr	r2, [pc, #64]	; (6fb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    6f76:	9b01      	ldr	r3, [sp, #4]
    6f78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6f7c:	2b00      	cmp	r3, #0
    6f7e:	d10d      	bne.n	6f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    6f80:	f7f9 fd2a 	bl	9d8 <Port_schm_read_msr>
    6f84:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    6f86:	9b00      	ldr	r3, [sp, #0]
    6f88:	f003 0301 	and.w	r3, r3, #1
    6f8c:	2b00      	cmp	r3, #0
    6f8e:	d100      	bne.n	6f92 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    6f90:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    6f92:	490a      	ldr	r1, [pc, #40]	; (6fbc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
    6f94:	9b01      	ldr	r3, [sp, #4]
    6f96:	9a00      	ldr	r2, [sp, #0]
    6f98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
    6f9c:	4a06      	ldr	r2, [pc, #24]	; (6fb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    6f9e:	9b01      	ldr	r3, [sp, #4]
    6fa0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6fa4:	1c5a      	adds	r2, r3, #1
    6fa6:	4904      	ldr	r1, [pc, #16]	; (6fb8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
    6fa8:	9b01      	ldr	r3, [sp, #4]
    6faa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    6fae:	bf00      	nop
    6fb0:	b003      	add	sp, #12
    6fb2:	f85d fb04 	ldr.w	pc, [sp], #4
    6fb6:	bf00      	nop
    6fb8:	1fff8dd0 	.word	0x1fff8dd0
    6fbc:	1fff8dcc 	.word	0x1fff8dcc

00006fc0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
    6fc0:	b500      	push	{lr}
    6fc2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    6fc4:	f7f9 fdf2 	bl	bac <Sys_GetCoreID>
    6fc8:	4603      	mov	r3, r0
    6fca:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
    6fcc:	4a0d      	ldr	r2, [pc, #52]	; (7004 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    6fce:	9b01      	ldr	r3, [sp, #4]
    6fd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6fd4:	1e5a      	subs	r2, r3, #1
    6fd6:	490b      	ldr	r1, [pc, #44]	; (7004 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    6fd8:	9b01      	ldr	r3, [sp, #4]
    6fda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    6fde:	4a0a      	ldr	r2, [pc, #40]	; (7008 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
    6fe0:	9b01      	ldr	r3, [sp, #4]
    6fe2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6fe6:	f003 0301 	and.w	r3, r3, #1
    6fea:	2b00      	cmp	r3, #0
    6fec:	d106      	bne.n	6ffc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    6fee:	4a05      	ldr	r2, [pc, #20]	; (7004 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
    6ff0:	9b01      	ldr	r3, [sp, #4]
    6ff2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6ff6:	2b00      	cmp	r3, #0
    6ff8:	d100      	bne.n	6ffc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    6ffa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    6ffc:	bf00      	nop
    6ffe:	b003      	add	sp, #12
    7000:	f85d fb04 	ldr.w	pc, [sp], #4
    7004:	1fff8dd0 	.word	0x1fff8dd0
    7008:	1fff8dcc 	.word	0x1fff8dcc

0000700c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    700c:	b500      	push	{lr}
    700e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7010:	f7f9 fdcc 	bl	bac <Sys_GetCoreID>
    7014:	4603      	mov	r3, r0
    7016:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
    7018:	4a10      	ldr	r2, [pc, #64]	; (705c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    701a:	9b01      	ldr	r3, [sp, #4]
    701c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7020:	2b00      	cmp	r3, #0
    7022:	d10d      	bne.n	7040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7024:	f7f9 fcd8 	bl	9d8 <Port_schm_read_msr>
    7028:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    702a:	9b00      	ldr	r3, [sp, #0]
    702c:	f003 0301 	and.w	r3, r3, #1
    7030:	2b00      	cmp	r3, #0
    7032:	d100      	bne.n	7036 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7034:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    7036:	490a      	ldr	r1, [pc, #40]	; (7060 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
    7038:	9b01      	ldr	r3, [sp, #4]
    703a:	9a00      	ldr	r2, [sp, #0]
    703c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
    7040:	4a06      	ldr	r2, [pc, #24]	; (705c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    7042:	9b01      	ldr	r3, [sp, #4]
    7044:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7048:	1c5a      	adds	r2, r3, #1
    704a:	4904      	ldr	r1, [pc, #16]	; (705c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
    704c:	9b01      	ldr	r3, [sp, #4]
    704e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7052:	bf00      	nop
    7054:	b003      	add	sp, #12
    7056:	f85d fb04 	ldr.w	pc, [sp], #4
    705a:	bf00      	nop
    705c:	1fff8dd8 	.word	0x1fff8dd8
    7060:	1fff8dd4 	.word	0x1fff8dd4

00007064 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
    7064:	b500      	push	{lr}
    7066:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7068:	f7f9 fda0 	bl	bac <Sys_GetCoreID>
    706c:	4603      	mov	r3, r0
    706e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
    7070:	4a0d      	ldr	r2, [pc, #52]	; (70a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    7072:	9b01      	ldr	r3, [sp, #4]
    7074:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7078:	1e5a      	subs	r2, r3, #1
    707a:	490b      	ldr	r1, [pc, #44]	; (70a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    707c:	9b01      	ldr	r3, [sp, #4]
    707e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    7082:	4a0a      	ldr	r2, [pc, #40]	; (70ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
    7084:	9b01      	ldr	r3, [sp, #4]
    7086:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    708a:	f003 0301 	and.w	r3, r3, #1
    708e:	2b00      	cmp	r3, #0
    7090:	d106      	bne.n	70a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    7092:	4a05      	ldr	r2, [pc, #20]	; (70a8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
    7094:	9b01      	ldr	r3, [sp, #4]
    7096:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    709a:	2b00      	cmp	r3, #0
    709c:	d100      	bne.n	70a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    709e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    70a0:	bf00      	nop
    70a2:	b003      	add	sp, #12
    70a4:	f85d fb04 	ldr.w	pc, [sp], #4
    70a8:	1fff8dd8 	.word	0x1fff8dd8
    70ac:	1fff8dd4 	.word	0x1fff8dd4

000070b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    70b0:	b500      	push	{lr}
    70b2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    70b4:	f7f9 fd7a 	bl	bac <Sys_GetCoreID>
    70b8:	4603      	mov	r3, r0
    70ba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
    70bc:	4a10      	ldr	r2, [pc, #64]	; (7100 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    70be:	9b01      	ldr	r3, [sp, #4]
    70c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70c4:	2b00      	cmp	r3, #0
    70c6:	d10d      	bne.n	70e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    70c8:	f7f9 fc86 	bl	9d8 <Port_schm_read_msr>
    70cc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    70ce:	9b00      	ldr	r3, [sp, #0]
    70d0:	f003 0301 	and.w	r3, r3, #1
    70d4:	2b00      	cmp	r3, #0
    70d6:	d100      	bne.n	70da <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    70d8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    70da:	490a      	ldr	r1, [pc, #40]	; (7104 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
    70dc:	9b01      	ldr	r3, [sp, #4]
    70de:	9a00      	ldr	r2, [sp, #0]
    70e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
    70e4:	4a06      	ldr	r2, [pc, #24]	; (7100 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    70e6:	9b01      	ldr	r3, [sp, #4]
    70e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    70ec:	1c5a      	adds	r2, r3, #1
    70ee:	4904      	ldr	r1, [pc, #16]	; (7100 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
    70f0:	9b01      	ldr	r3, [sp, #4]
    70f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    70f6:	bf00      	nop
    70f8:	b003      	add	sp, #12
    70fa:	f85d fb04 	ldr.w	pc, [sp], #4
    70fe:	bf00      	nop
    7100:	1fff8de0 	.word	0x1fff8de0
    7104:	1fff8ddc 	.word	0x1fff8ddc

00007108 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
    7108:	b500      	push	{lr}
    710a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    710c:	f7f9 fd4e 	bl	bac <Sys_GetCoreID>
    7110:	4603      	mov	r3, r0
    7112:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
    7114:	4a0d      	ldr	r2, [pc, #52]	; (714c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    7116:	9b01      	ldr	r3, [sp, #4]
    7118:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    711c:	1e5a      	subs	r2, r3, #1
    711e:	490b      	ldr	r1, [pc, #44]	; (714c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    7120:	9b01      	ldr	r3, [sp, #4]
    7122:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    7126:	4a0a      	ldr	r2, [pc, #40]	; (7150 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
    7128:	9b01      	ldr	r3, [sp, #4]
    712a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    712e:	f003 0301 	and.w	r3, r3, #1
    7132:	2b00      	cmp	r3, #0
    7134:	d106      	bne.n	7144 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    7136:	4a05      	ldr	r2, [pc, #20]	; (714c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
    7138:	9b01      	ldr	r3, [sp, #4]
    713a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    713e:	2b00      	cmp	r3, #0
    7140:	d100      	bne.n	7144 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7142:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7144:	bf00      	nop
    7146:	b003      	add	sp, #12
    7148:	f85d fb04 	ldr.w	pc, [sp], #4
    714c:	1fff8de0 	.word	0x1fff8de0
    7150:	1fff8ddc 	.word	0x1fff8ddc

00007154 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    7154:	b500      	push	{lr}
    7156:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7158:	f7f9 fd28 	bl	bac <Sys_GetCoreID>
    715c:	4603      	mov	r3, r0
    715e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
    7160:	4a10      	ldr	r2, [pc, #64]	; (71a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    7162:	9b01      	ldr	r3, [sp, #4]
    7164:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7168:	2b00      	cmp	r3, #0
    716a:	d10d      	bne.n	7188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    716c:	f7f9 fc34 	bl	9d8 <Port_schm_read_msr>
    7170:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7172:	9b00      	ldr	r3, [sp, #0]
    7174:	f003 0301 	and.w	r3, r3, #1
    7178:	2b00      	cmp	r3, #0
    717a:	d100      	bne.n	717e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    717c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    717e:	490a      	ldr	r1, [pc, #40]	; (71a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
    7180:	9b01      	ldr	r3, [sp, #4]
    7182:	9a00      	ldr	r2, [sp, #0]
    7184:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
    7188:	4a06      	ldr	r2, [pc, #24]	; (71a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    718a:	9b01      	ldr	r3, [sp, #4]
    718c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7190:	1c5a      	adds	r2, r3, #1
    7192:	4904      	ldr	r1, [pc, #16]	; (71a4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
    7194:	9b01      	ldr	r3, [sp, #4]
    7196:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    719a:	bf00      	nop
    719c:	b003      	add	sp, #12
    719e:	f85d fb04 	ldr.w	pc, [sp], #4
    71a2:	bf00      	nop
    71a4:	1fff8de8 	.word	0x1fff8de8
    71a8:	1fff8de4 	.word	0x1fff8de4

000071ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
    71ac:	b500      	push	{lr}
    71ae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    71b0:	f7f9 fcfc 	bl	bac <Sys_GetCoreID>
    71b4:	4603      	mov	r3, r0
    71b6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
    71b8:	4a0d      	ldr	r2, [pc, #52]	; (71f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    71ba:	9b01      	ldr	r3, [sp, #4]
    71bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    71c0:	1e5a      	subs	r2, r3, #1
    71c2:	490b      	ldr	r1, [pc, #44]	; (71f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    71c4:	9b01      	ldr	r3, [sp, #4]
    71c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    71ca:	4a0a      	ldr	r2, [pc, #40]	; (71f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
    71cc:	9b01      	ldr	r3, [sp, #4]
    71ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    71d2:	f003 0301 	and.w	r3, r3, #1
    71d6:	2b00      	cmp	r3, #0
    71d8:	d106      	bne.n	71e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    71da:	4a05      	ldr	r2, [pc, #20]	; (71f0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
    71dc:	9b01      	ldr	r3, [sp, #4]
    71de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    71e2:	2b00      	cmp	r3, #0
    71e4:	d100      	bne.n	71e8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    71e6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    71e8:	bf00      	nop
    71ea:	b003      	add	sp, #12
    71ec:	f85d fb04 	ldr.w	pc, [sp], #4
    71f0:	1fff8de8 	.word	0x1fff8de8
    71f4:	1fff8de4 	.word	0x1fff8de4

000071f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    71f8:	b500      	push	{lr}
    71fa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    71fc:	f7f9 fcd6 	bl	bac <Sys_GetCoreID>
    7200:	4603      	mov	r3, r0
    7202:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
    7204:	4a10      	ldr	r2, [pc, #64]	; (7248 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    7206:	9b01      	ldr	r3, [sp, #4]
    7208:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    720c:	2b00      	cmp	r3, #0
    720e:	d10d      	bne.n	722c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7210:	f7f9 fbe2 	bl	9d8 <Port_schm_read_msr>
    7214:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7216:	9b00      	ldr	r3, [sp, #0]
    7218:	f003 0301 	and.w	r3, r3, #1
    721c:	2b00      	cmp	r3, #0
    721e:	d100      	bne.n	7222 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7220:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    7222:	490a      	ldr	r1, [pc, #40]	; (724c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
    7224:	9b01      	ldr	r3, [sp, #4]
    7226:	9a00      	ldr	r2, [sp, #0]
    7228:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
    722c:	4a06      	ldr	r2, [pc, #24]	; (7248 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    722e:	9b01      	ldr	r3, [sp, #4]
    7230:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7234:	1c5a      	adds	r2, r3, #1
    7236:	4904      	ldr	r1, [pc, #16]	; (7248 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
    7238:	9b01      	ldr	r3, [sp, #4]
    723a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    723e:	bf00      	nop
    7240:	b003      	add	sp, #12
    7242:	f85d fb04 	ldr.w	pc, [sp], #4
    7246:	bf00      	nop
    7248:	1fff8df0 	.word	0x1fff8df0
    724c:	1fff8dec 	.word	0x1fff8dec

00007250 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
    7250:	b500      	push	{lr}
    7252:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7254:	f7f9 fcaa 	bl	bac <Sys_GetCoreID>
    7258:	4603      	mov	r3, r0
    725a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
    725c:	4a0d      	ldr	r2, [pc, #52]	; (7294 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    725e:	9b01      	ldr	r3, [sp, #4]
    7260:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7264:	1e5a      	subs	r2, r3, #1
    7266:	490b      	ldr	r1, [pc, #44]	; (7294 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    7268:	9b01      	ldr	r3, [sp, #4]
    726a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    726e:	4a0a      	ldr	r2, [pc, #40]	; (7298 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
    7270:	9b01      	ldr	r3, [sp, #4]
    7272:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7276:	f003 0301 	and.w	r3, r3, #1
    727a:	2b00      	cmp	r3, #0
    727c:	d106      	bne.n	728c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    727e:	4a05      	ldr	r2, [pc, #20]	; (7294 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
    7280:	9b01      	ldr	r3, [sp, #4]
    7282:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7286:	2b00      	cmp	r3, #0
    7288:	d100      	bne.n	728c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    728a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    728c:	bf00      	nop
    728e:	b003      	add	sp, #12
    7290:	f85d fb04 	ldr.w	pc, [sp], #4
    7294:	1fff8df0 	.word	0x1fff8df0
    7298:	1fff8dec 	.word	0x1fff8dec

0000729c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    729c:	b500      	push	{lr}
    729e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    72a0:	f7f9 fc84 	bl	bac <Sys_GetCoreID>
    72a4:	4603      	mov	r3, r0
    72a6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
    72a8:	4a10      	ldr	r2, [pc, #64]	; (72ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    72aa:	9b01      	ldr	r3, [sp, #4]
    72ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72b0:	2b00      	cmp	r3, #0
    72b2:	d10d      	bne.n	72d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    72b4:	f7f9 fb90 	bl	9d8 <Port_schm_read_msr>
    72b8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    72ba:	9b00      	ldr	r3, [sp, #0]
    72bc:	f003 0301 	and.w	r3, r3, #1
    72c0:	2b00      	cmp	r3, #0
    72c2:	d100      	bne.n	72c6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    72c4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    72c6:	490a      	ldr	r1, [pc, #40]	; (72f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
    72c8:	9b01      	ldr	r3, [sp, #4]
    72ca:	9a00      	ldr	r2, [sp, #0]
    72cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
    72d0:	4a06      	ldr	r2, [pc, #24]	; (72ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    72d2:	9b01      	ldr	r3, [sp, #4]
    72d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    72d8:	1c5a      	adds	r2, r3, #1
    72da:	4904      	ldr	r1, [pc, #16]	; (72ec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
    72dc:	9b01      	ldr	r3, [sp, #4]
    72de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    72e2:	bf00      	nop
    72e4:	b003      	add	sp, #12
    72e6:	f85d fb04 	ldr.w	pc, [sp], #4
    72ea:	bf00      	nop
    72ec:	1fff8df8 	.word	0x1fff8df8
    72f0:	1fff8df4 	.word	0x1fff8df4

000072f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
    72f4:	b500      	push	{lr}
    72f6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    72f8:	f7f9 fc58 	bl	bac <Sys_GetCoreID>
    72fc:	4603      	mov	r3, r0
    72fe:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
    7300:	4a0d      	ldr	r2, [pc, #52]	; (7338 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    7302:	9b01      	ldr	r3, [sp, #4]
    7304:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7308:	1e5a      	subs	r2, r3, #1
    730a:	490b      	ldr	r1, [pc, #44]	; (7338 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    730c:	9b01      	ldr	r3, [sp, #4]
    730e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    7312:	4a0a      	ldr	r2, [pc, #40]	; (733c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
    7314:	9b01      	ldr	r3, [sp, #4]
    7316:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    731a:	f003 0301 	and.w	r3, r3, #1
    731e:	2b00      	cmp	r3, #0
    7320:	d106      	bne.n	7330 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    7322:	4a05      	ldr	r2, [pc, #20]	; (7338 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
    7324:	9b01      	ldr	r3, [sp, #4]
    7326:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    732a:	2b00      	cmp	r3, #0
    732c:	d100      	bne.n	7330 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    732e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7330:	bf00      	nop
    7332:	b003      	add	sp, #12
    7334:	f85d fb04 	ldr.w	pc, [sp], #4
    7338:	1fff8df8 	.word	0x1fff8df8
    733c:	1fff8df4 	.word	0x1fff8df4

00007340 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    7340:	b500      	push	{lr}
    7342:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7344:	f7f9 fc32 	bl	bac <Sys_GetCoreID>
    7348:	4603      	mov	r3, r0
    734a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
    734c:	4a10      	ldr	r2, [pc, #64]	; (7390 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    734e:	9b01      	ldr	r3, [sp, #4]
    7350:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7354:	2b00      	cmp	r3, #0
    7356:	d10d      	bne.n	7374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7358:	f7f9 fb3e 	bl	9d8 <Port_schm_read_msr>
    735c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    735e:	9b00      	ldr	r3, [sp, #0]
    7360:	f003 0301 	and.w	r3, r3, #1
    7364:	2b00      	cmp	r3, #0
    7366:	d100      	bne.n	736a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7368:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
    736a:	490a      	ldr	r1, [pc, #40]	; (7394 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
    736c:	9b01      	ldr	r3, [sp, #4]
    736e:	9a00      	ldr	r2, [sp, #0]
    7370:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
    7374:	4a06      	ldr	r2, [pc, #24]	; (7390 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    7376:	9b01      	ldr	r3, [sp, #4]
    7378:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    737c:	1c5a      	adds	r2, r3, #1
    737e:	4904      	ldr	r1, [pc, #16]	; (7390 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
    7380:	9b01      	ldr	r3, [sp, #4]
    7382:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7386:	bf00      	nop
    7388:	b003      	add	sp, #12
    738a:	f85d fb04 	ldr.w	pc, [sp], #4
    738e:	bf00      	nop
    7390:	1fff8e00 	.word	0x1fff8e00
    7394:	1fff8dfc 	.word	0x1fff8dfc

00007398 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
    7398:	b500      	push	{lr}
    739a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    739c:	f7f9 fc06 	bl	bac <Sys_GetCoreID>
    73a0:	4603      	mov	r3, r0
    73a2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
    73a4:	4a0d      	ldr	r2, [pc, #52]	; (73dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    73a6:	9b01      	ldr	r3, [sp, #4]
    73a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73ac:	1e5a      	subs	r2, r3, #1
    73ae:	490b      	ldr	r1, [pc, #44]	; (73dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    73b0:	9b01      	ldr	r3, [sp, #4]
    73b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
    73b6:	4a0a      	ldr	r2, [pc, #40]	; (73e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
    73b8:	9b01      	ldr	r3, [sp, #4]
    73ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73be:	f003 0301 	and.w	r3, r3, #1
    73c2:	2b00      	cmp	r3, #0
    73c4:	d106      	bne.n	73d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    73c6:	4a05      	ldr	r2, [pc, #20]	; (73dc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
    73c8:	9b01      	ldr	r3, [sp, #4]
    73ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73ce:	2b00      	cmp	r3, #0
    73d0:	d100      	bne.n	73d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    73d2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    73d4:	bf00      	nop
    73d6:	b003      	add	sp, #12
    73d8:	f85d fb04 	ldr.w	pc, [sp], #4
    73dc:	1fff8e00 	.word	0x1fff8e00
    73e0:	1fff8dfc 	.word	0x1fff8dfc

000073e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    73e4:	b500      	push	{lr}
    73e6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    73e8:	f7f9 fbe0 	bl	bac <Sys_GetCoreID>
    73ec:	4603      	mov	r3, r0
    73ee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
    73f0:	4a10      	ldr	r2, [pc, #64]	; (7434 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    73f2:	9b01      	ldr	r3, [sp, #4]
    73f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    73f8:	2b00      	cmp	r3, #0
    73fa:	d10d      	bne.n	7418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    73fc:	f7f9 faec 	bl	9d8 <Port_schm_read_msr>
    7400:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7402:	9b00      	ldr	r3, [sp, #0]
    7404:	f003 0301 	and.w	r3, r3, #1
    7408:	2b00      	cmp	r3, #0
    740a:	d100      	bne.n	740e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    740c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
    740e:	490a      	ldr	r1, [pc, #40]	; (7438 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
    7410:	9b01      	ldr	r3, [sp, #4]
    7412:	9a00      	ldr	r2, [sp, #0]
    7414:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
    7418:	4a06      	ldr	r2, [pc, #24]	; (7434 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    741a:	9b01      	ldr	r3, [sp, #4]
    741c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7420:	1c5a      	adds	r2, r3, #1
    7422:	4904      	ldr	r1, [pc, #16]	; (7434 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
    7424:	9b01      	ldr	r3, [sp, #4]
    7426:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    742a:	bf00      	nop
    742c:	b003      	add	sp, #12
    742e:	f85d fb04 	ldr.w	pc, [sp], #4
    7432:	bf00      	nop
    7434:	1fff8e08 	.word	0x1fff8e08
    7438:	1fff8e04 	.word	0x1fff8e04

0000743c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
    743c:	b500      	push	{lr}
    743e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7440:	f7f9 fbb4 	bl	bac <Sys_GetCoreID>
    7444:	4603      	mov	r3, r0
    7446:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
    7448:	4a0d      	ldr	r2, [pc, #52]	; (7480 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    744a:	9b01      	ldr	r3, [sp, #4]
    744c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7450:	1e5a      	subs	r2, r3, #1
    7452:	490b      	ldr	r1, [pc, #44]	; (7480 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    7454:	9b01      	ldr	r3, [sp, #4]
    7456:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
    745a:	4a0a      	ldr	r2, [pc, #40]	; (7484 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
    745c:	9b01      	ldr	r3, [sp, #4]
    745e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7462:	f003 0301 	and.w	r3, r3, #1
    7466:	2b00      	cmp	r3, #0
    7468:	d106      	bne.n	7478 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    746a:	4a05      	ldr	r2, [pc, #20]	; (7480 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
    746c:	9b01      	ldr	r3, [sp, #4]
    746e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7472:	2b00      	cmp	r3, #0
    7474:	d100      	bne.n	7478 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7476:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7478:	bf00      	nop
    747a:	b003      	add	sp, #12
    747c:	f85d fb04 	ldr.w	pc, [sp], #4
    7480:	1fff8e08 	.word	0x1fff8e08
    7484:	1fff8e04 	.word	0x1fff8e04

00007488 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    7488:	b500      	push	{lr}
    748a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    748c:	f7f9 fb8e 	bl	bac <Sys_GetCoreID>
    7490:	4603      	mov	r3, r0
    7492:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
    7494:	4a10      	ldr	r2, [pc, #64]	; (74d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    7496:	9b01      	ldr	r3, [sp, #4]
    7498:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    749c:	2b00      	cmp	r3, #0
    749e:	d10d      	bne.n	74bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    74a0:	f7f9 fa9a 	bl	9d8 <Port_schm_read_msr>
    74a4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    74a6:	9b00      	ldr	r3, [sp, #0]
    74a8:	f003 0301 	and.w	r3, r3, #1
    74ac:	2b00      	cmp	r3, #0
    74ae:	d100      	bne.n	74b2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    74b0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    74b2:	490a      	ldr	r1, [pc, #40]	; (74dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
    74b4:	9b01      	ldr	r3, [sp, #4]
    74b6:	9a00      	ldr	r2, [sp, #0]
    74b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
    74bc:	4a06      	ldr	r2, [pc, #24]	; (74d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    74be:	9b01      	ldr	r3, [sp, #4]
    74c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    74c4:	1c5a      	adds	r2, r3, #1
    74c6:	4904      	ldr	r1, [pc, #16]	; (74d8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
    74c8:	9b01      	ldr	r3, [sp, #4]
    74ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    74ce:	bf00      	nop
    74d0:	b003      	add	sp, #12
    74d2:	f85d fb04 	ldr.w	pc, [sp], #4
    74d6:	bf00      	nop
    74d8:	1fff8e10 	.word	0x1fff8e10
    74dc:	1fff8e0c 	.word	0x1fff8e0c

000074e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
    74e0:	b500      	push	{lr}
    74e2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    74e4:	f7f9 fb62 	bl	bac <Sys_GetCoreID>
    74e8:	4603      	mov	r3, r0
    74ea:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
    74ec:	4a0d      	ldr	r2, [pc, #52]	; (7524 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    74ee:	9b01      	ldr	r3, [sp, #4]
    74f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    74f4:	1e5a      	subs	r2, r3, #1
    74f6:	490b      	ldr	r1, [pc, #44]	; (7524 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    74f8:	9b01      	ldr	r3, [sp, #4]
    74fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    74fe:	4a0a      	ldr	r2, [pc, #40]	; (7528 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
    7500:	9b01      	ldr	r3, [sp, #4]
    7502:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7506:	f003 0301 	and.w	r3, r3, #1
    750a:	2b00      	cmp	r3, #0
    750c:	d106      	bne.n	751c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    750e:	4a05      	ldr	r2, [pc, #20]	; (7524 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
    7510:	9b01      	ldr	r3, [sp, #4]
    7512:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7516:	2b00      	cmp	r3, #0
    7518:	d100      	bne.n	751c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    751a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    751c:	bf00      	nop
    751e:	b003      	add	sp, #12
    7520:	f85d fb04 	ldr.w	pc, [sp], #4
    7524:	1fff8e10 	.word	0x1fff8e10
    7528:	1fff8e0c 	.word	0x1fff8e0c

0000752c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    752c:	b500      	push	{lr}
    752e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7530:	f7f9 fb3c 	bl	bac <Sys_GetCoreID>
    7534:	4603      	mov	r3, r0
    7536:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
    7538:	4a10      	ldr	r2, [pc, #64]	; (757c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    753a:	9b01      	ldr	r3, [sp, #4]
    753c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7540:	2b00      	cmp	r3, #0
    7542:	d10d      	bne.n	7560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7544:	f7f9 fa48 	bl	9d8 <Port_schm_read_msr>
    7548:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    754a:	9b00      	ldr	r3, [sp, #0]
    754c:	f003 0301 	and.w	r3, r3, #1
    7550:	2b00      	cmp	r3, #0
    7552:	d100      	bne.n	7556 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7554:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    7556:	490a      	ldr	r1, [pc, #40]	; (7580 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
    7558:	9b01      	ldr	r3, [sp, #4]
    755a:	9a00      	ldr	r2, [sp, #0]
    755c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
    7560:	4a06      	ldr	r2, [pc, #24]	; (757c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    7562:	9b01      	ldr	r3, [sp, #4]
    7564:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7568:	1c5a      	adds	r2, r3, #1
    756a:	4904      	ldr	r1, [pc, #16]	; (757c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
    756c:	9b01      	ldr	r3, [sp, #4]
    756e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7572:	bf00      	nop
    7574:	b003      	add	sp, #12
    7576:	f85d fb04 	ldr.w	pc, [sp], #4
    757a:	bf00      	nop
    757c:	1fff8e18 	.word	0x1fff8e18
    7580:	1fff8e14 	.word	0x1fff8e14

00007584 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
    7584:	b500      	push	{lr}
    7586:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7588:	f7f9 fb10 	bl	bac <Sys_GetCoreID>
    758c:	4603      	mov	r3, r0
    758e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
    7590:	4a0d      	ldr	r2, [pc, #52]	; (75c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    7592:	9b01      	ldr	r3, [sp, #4]
    7594:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7598:	1e5a      	subs	r2, r3, #1
    759a:	490b      	ldr	r1, [pc, #44]	; (75c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    759c:	9b01      	ldr	r3, [sp, #4]
    759e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    75a2:	4a0a      	ldr	r2, [pc, #40]	; (75cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
    75a4:	9b01      	ldr	r3, [sp, #4]
    75a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    75aa:	f003 0301 	and.w	r3, r3, #1
    75ae:	2b00      	cmp	r3, #0
    75b0:	d106      	bne.n	75c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    75b2:	4a05      	ldr	r2, [pc, #20]	; (75c8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
    75b4:	9b01      	ldr	r3, [sp, #4]
    75b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    75ba:	2b00      	cmp	r3, #0
    75bc:	d100      	bne.n	75c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    75be:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    75c0:	bf00      	nop
    75c2:	b003      	add	sp, #12
    75c4:	f85d fb04 	ldr.w	pc, [sp], #4
    75c8:	1fff8e18 	.word	0x1fff8e18
    75cc:	1fff8e14 	.word	0x1fff8e14

000075d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    75d0:	b500      	push	{lr}
    75d2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    75d4:	f7f9 faea 	bl	bac <Sys_GetCoreID>
    75d8:	4603      	mov	r3, r0
    75da:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
    75dc:	4a10      	ldr	r2, [pc, #64]	; (7620 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    75de:	9b01      	ldr	r3, [sp, #4]
    75e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    75e4:	2b00      	cmp	r3, #0
    75e6:	d10d      	bne.n	7604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    75e8:	f7f9 f9f6 	bl	9d8 <Port_schm_read_msr>
    75ec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    75ee:	9b00      	ldr	r3, [sp, #0]
    75f0:	f003 0301 	and.w	r3, r3, #1
    75f4:	2b00      	cmp	r3, #0
    75f6:	d100      	bne.n	75fa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    75f8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    75fa:	490a      	ldr	r1, [pc, #40]	; (7624 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
    75fc:	9b01      	ldr	r3, [sp, #4]
    75fe:	9a00      	ldr	r2, [sp, #0]
    7600:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
    7604:	4a06      	ldr	r2, [pc, #24]	; (7620 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    7606:	9b01      	ldr	r3, [sp, #4]
    7608:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    760c:	1c5a      	adds	r2, r3, #1
    760e:	4904      	ldr	r1, [pc, #16]	; (7620 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
    7610:	9b01      	ldr	r3, [sp, #4]
    7612:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7616:	bf00      	nop
    7618:	b003      	add	sp, #12
    761a:	f85d fb04 	ldr.w	pc, [sp], #4
    761e:	bf00      	nop
    7620:	1fff8e20 	.word	0x1fff8e20
    7624:	1fff8e1c 	.word	0x1fff8e1c

00007628 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
    7628:	b500      	push	{lr}
    762a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    762c:	f7f9 fabe 	bl	bac <Sys_GetCoreID>
    7630:	4603      	mov	r3, r0
    7632:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
    7634:	4a0d      	ldr	r2, [pc, #52]	; (766c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    7636:	9b01      	ldr	r3, [sp, #4]
    7638:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    763c:	1e5a      	subs	r2, r3, #1
    763e:	490b      	ldr	r1, [pc, #44]	; (766c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    7640:	9b01      	ldr	r3, [sp, #4]
    7642:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    7646:	4a0a      	ldr	r2, [pc, #40]	; (7670 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
    7648:	9b01      	ldr	r3, [sp, #4]
    764a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    764e:	f003 0301 	and.w	r3, r3, #1
    7652:	2b00      	cmp	r3, #0
    7654:	d106      	bne.n	7664 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    7656:	4a05      	ldr	r2, [pc, #20]	; (766c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
    7658:	9b01      	ldr	r3, [sp, #4]
    765a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    765e:	2b00      	cmp	r3, #0
    7660:	d100      	bne.n	7664 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7662:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7664:	bf00      	nop
    7666:	b003      	add	sp, #12
    7668:	f85d fb04 	ldr.w	pc, [sp], #4
    766c:	1fff8e20 	.word	0x1fff8e20
    7670:	1fff8e1c 	.word	0x1fff8e1c

00007674 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    7674:	b500      	push	{lr}
    7676:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7678:	f7f9 fa98 	bl	bac <Sys_GetCoreID>
    767c:	4603      	mov	r3, r0
    767e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
    7680:	4a10      	ldr	r2, [pc, #64]	; (76c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    7682:	9b01      	ldr	r3, [sp, #4]
    7684:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7688:	2b00      	cmp	r3, #0
    768a:	d10d      	bne.n	76a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    768c:	f7f9 f9a4 	bl	9d8 <Port_schm_read_msr>
    7690:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7692:	9b00      	ldr	r3, [sp, #0]
    7694:	f003 0301 	and.w	r3, r3, #1
    7698:	2b00      	cmp	r3, #0
    769a:	d100      	bne.n	769e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    769c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    769e:	490a      	ldr	r1, [pc, #40]	; (76c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
    76a0:	9b01      	ldr	r3, [sp, #4]
    76a2:	9a00      	ldr	r2, [sp, #0]
    76a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
    76a8:	4a06      	ldr	r2, [pc, #24]	; (76c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    76aa:	9b01      	ldr	r3, [sp, #4]
    76ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    76b0:	1c5a      	adds	r2, r3, #1
    76b2:	4904      	ldr	r1, [pc, #16]	; (76c4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
    76b4:	9b01      	ldr	r3, [sp, #4]
    76b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    76ba:	bf00      	nop
    76bc:	b003      	add	sp, #12
    76be:	f85d fb04 	ldr.w	pc, [sp], #4
    76c2:	bf00      	nop
    76c4:	1fff8e28 	.word	0x1fff8e28
    76c8:	1fff8e24 	.word	0x1fff8e24

000076cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
    76cc:	b500      	push	{lr}
    76ce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    76d0:	f7f9 fa6c 	bl	bac <Sys_GetCoreID>
    76d4:	4603      	mov	r3, r0
    76d6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
    76d8:	4a0d      	ldr	r2, [pc, #52]	; (7710 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    76da:	9b01      	ldr	r3, [sp, #4]
    76dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    76e0:	1e5a      	subs	r2, r3, #1
    76e2:	490b      	ldr	r1, [pc, #44]	; (7710 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    76e4:	9b01      	ldr	r3, [sp, #4]
    76e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    76ea:	4a0a      	ldr	r2, [pc, #40]	; (7714 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
    76ec:	9b01      	ldr	r3, [sp, #4]
    76ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    76f2:	f003 0301 	and.w	r3, r3, #1
    76f6:	2b00      	cmp	r3, #0
    76f8:	d106      	bne.n	7708 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    76fa:	4a05      	ldr	r2, [pc, #20]	; (7710 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
    76fc:	9b01      	ldr	r3, [sp, #4]
    76fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7702:	2b00      	cmp	r3, #0
    7704:	d100      	bne.n	7708 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7706:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7708:	bf00      	nop
    770a:	b003      	add	sp, #12
    770c:	f85d fb04 	ldr.w	pc, [sp], #4
    7710:	1fff8e28 	.word	0x1fff8e28
    7714:	1fff8e24 	.word	0x1fff8e24

00007718 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    7718:	b500      	push	{lr}
    771a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    771c:	f7f9 fa46 	bl	bac <Sys_GetCoreID>
    7720:	4603      	mov	r3, r0
    7722:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
    7724:	4a10      	ldr	r2, [pc, #64]	; (7768 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    7726:	9b01      	ldr	r3, [sp, #4]
    7728:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    772c:	2b00      	cmp	r3, #0
    772e:	d10d      	bne.n	774c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7730:	f7f9 f952 	bl	9d8 <Port_schm_read_msr>
    7734:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7736:	9b00      	ldr	r3, [sp, #0]
    7738:	f003 0301 	and.w	r3, r3, #1
    773c:	2b00      	cmp	r3, #0
    773e:	d100      	bne.n	7742 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7740:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    7742:	490a      	ldr	r1, [pc, #40]	; (776c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
    7744:	9b01      	ldr	r3, [sp, #4]
    7746:	9a00      	ldr	r2, [sp, #0]
    7748:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
    774c:	4a06      	ldr	r2, [pc, #24]	; (7768 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    774e:	9b01      	ldr	r3, [sp, #4]
    7750:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7754:	1c5a      	adds	r2, r3, #1
    7756:	4904      	ldr	r1, [pc, #16]	; (7768 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
    7758:	9b01      	ldr	r3, [sp, #4]
    775a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    775e:	bf00      	nop
    7760:	b003      	add	sp, #12
    7762:	f85d fb04 	ldr.w	pc, [sp], #4
    7766:	bf00      	nop
    7768:	1fff8e30 	.word	0x1fff8e30
    776c:	1fff8e2c 	.word	0x1fff8e2c

00007770 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
    7770:	b500      	push	{lr}
    7772:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7774:	f7f9 fa1a 	bl	bac <Sys_GetCoreID>
    7778:	4603      	mov	r3, r0
    777a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
    777c:	4a0d      	ldr	r2, [pc, #52]	; (77b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    777e:	9b01      	ldr	r3, [sp, #4]
    7780:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7784:	1e5a      	subs	r2, r3, #1
    7786:	490b      	ldr	r1, [pc, #44]	; (77b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    7788:	9b01      	ldr	r3, [sp, #4]
    778a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    778e:	4a0a      	ldr	r2, [pc, #40]	; (77b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
    7790:	9b01      	ldr	r3, [sp, #4]
    7792:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7796:	f003 0301 	and.w	r3, r3, #1
    779a:	2b00      	cmp	r3, #0
    779c:	d106      	bne.n	77ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    779e:	4a05      	ldr	r2, [pc, #20]	; (77b4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
    77a0:	9b01      	ldr	r3, [sp, #4]
    77a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77a6:	2b00      	cmp	r3, #0
    77a8:	d100      	bne.n	77ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    77aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    77ac:	bf00      	nop
    77ae:	b003      	add	sp, #12
    77b0:	f85d fb04 	ldr.w	pc, [sp], #4
    77b4:	1fff8e30 	.word	0x1fff8e30
    77b8:	1fff8e2c 	.word	0x1fff8e2c

000077bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    77bc:	b500      	push	{lr}
    77be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    77c0:	f7f9 f9f4 	bl	bac <Sys_GetCoreID>
    77c4:	4603      	mov	r3, r0
    77c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
    77c8:	4a10      	ldr	r2, [pc, #64]	; (780c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    77ca:	9b01      	ldr	r3, [sp, #4]
    77cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77d0:	2b00      	cmp	r3, #0
    77d2:	d10d      	bne.n	77f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    77d4:	f7f9 f900 	bl	9d8 <Port_schm_read_msr>
    77d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    77da:	9b00      	ldr	r3, [sp, #0]
    77dc:	f003 0301 	and.w	r3, r3, #1
    77e0:	2b00      	cmp	r3, #0
    77e2:	d100      	bne.n	77e6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    77e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    77e6:	490a      	ldr	r1, [pc, #40]	; (7810 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
    77e8:	9b01      	ldr	r3, [sp, #4]
    77ea:	9a00      	ldr	r2, [sp, #0]
    77ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
    77f0:	4a06      	ldr	r2, [pc, #24]	; (780c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    77f2:	9b01      	ldr	r3, [sp, #4]
    77f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    77f8:	1c5a      	adds	r2, r3, #1
    77fa:	4904      	ldr	r1, [pc, #16]	; (780c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
    77fc:	9b01      	ldr	r3, [sp, #4]
    77fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7802:	bf00      	nop
    7804:	b003      	add	sp, #12
    7806:	f85d fb04 	ldr.w	pc, [sp], #4
    780a:	bf00      	nop
    780c:	1fff8e38 	.word	0x1fff8e38
    7810:	1fff8e34 	.word	0x1fff8e34

00007814 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
    7814:	b500      	push	{lr}
    7816:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7818:	f7f9 f9c8 	bl	bac <Sys_GetCoreID>
    781c:	4603      	mov	r3, r0
    781e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
    7820:	4a0d      	ldr	r2, [pc, #52]	; (7858 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    7822:	9b01      	ldr	r3, [sp, #4]
    7824:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7828:	1e5a      	subs	r2, r3, #1
    782a:	490b      	ldr	r1, [pc, #44]	; (7858 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    782c:	9b01      	ldr	r3, [sp, #4]
    782e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    7832:	4a0a      	ldr	r2, [pc, #40]	; (785c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
    7834:	9b01      	ldr	r3, [sp, #4]
    7836:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    783a:	f003 0301 	and.w	r3, r3, #1
    783e:	2b00      	cmp	r3, #0
    7840:	d106      	bne.n	7850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    7842:	4a05      	ldr	r2, [pc, #20]	; (7858 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
    7844:	9b01      	ldr	r3, [sp, #4]
    7846:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    784a:	2b00      	cmp	r3, #0
    784c:	d100      	bne.n	7850 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    784e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7850:	bf00      	nop
    7852:	b003      	add	sp, #12
    7854:	f85d fb04 	ldr.w	pc, [sp], #4
    7858:	1fff8e38 	.word	0x1fff8e38
    785c:	1fff8e34 	.word	0x1fff8e34

00007860 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    7860:	b500      	push	{lr}
    7862:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7864:	f7f9 f9a2 	bl	bac <Sys_GetCoreID>
    7868:	4603      	mov	r3, r0
    786a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
    786c:	4a10      	ldr	r2, [pc, #64]	; (78b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    786e:	9b01      	ldr	r3, [sp, #4]
    7870:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7874:	2b00      	cmp	r3, #0
    7876:	d10d      	bne.n	7894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7878:	f7f9 f8ae 	bl	9d8 <Port_schm_read_msr>
    787c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    787e:	9b00      	ldr	r3, [sp, #0]
    7880:	f003 0301 	and.w	r3, r3, #1
    7884:	2b00      	cmp	r3, #0
    7886:	d100      	bne.n	788a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7888:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    788a:	490a      	ldr	r1, [pc, #40]	; (78b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
    788c:	9b01      	ldr	r3, [sp, #4]
    788e:	9a00      	ldr	r2, [sp, #0]
    7890:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
    7894:	4a06      	ldr	r2, [pc, #24]	; (78b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    7896:	9b01      	ldr	r3, [sp, #4]
    7898:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    789c:	1c5a      	adds	r2, r3, #1
    789e:	4904      	ldr	r1, [pc, #16]	; (78b0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
    78a0:	9b01      	ldr	r3, [sp, #4]
    78a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    78a6:	bf00      	nop
    78a8:	b003      	add	sp, #12
    78aa:	f85d fb04 	ldr.w	pc, [sp], #4
    78ae:	bf00      	nop
    78b0:	1fff8e40 	.word	0x1fff8e40
    78b4:	1fff8e3c 	.word	0x1fff8e3c

000078b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
    78b8:	b500      	push	{lr}
    78ba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    78bc:	f7f9 f976 	bl	bac <Sys_GetCoreID>
    78c0:	4603      	mov	r3, r0
    78c2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
    78c4:	4a0d      	ldr	r2, [pc, #52]	; (78fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    78c6:	9b01      	ldr	r3, [sp, #4]
    78c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78cc:	1e5a      	subs	r2, r3, #1
    78ce:	490b      	ldr	r1, [pc, #44]	; (78fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    78d0:	9b01      	ldr	r3, [sp, #4]
    78d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    78d6:	4a0a      	ldr	r2, [pc, #40]	; (7900 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
    78d8:	9b01      	ldr	r3, [sp, #4]
    78da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78de:	f003 0301 	and.w	r3, r3, #1
    78e2:	2b00      	cmp	r3, #0
    78e4:	d106      	bne.n	78f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    78e6:	4a05      	ldr	r2, [pc, #20]	; (78fc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
    78e8:	9b01      	ldr	r3, [sp, #4]
    78ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    78ee:	2b00      	cmp	r3, #0
    78f0:	d100      	bne.n	78f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    78f2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    78f4:	bf00      	nop
    78f6:	b003      	add	sp, #12
    78f8:	f85d fb04 	ldr.w	pc, [sp], #4
    78fc:	1fff8e40 	.word	0x1fff8e40
    7900:	1fff8e3c 	.word	0x1fff8e3c

00007904 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    7904:	b500      	push	{lr}
    7906:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7908:	f7f9 f950 	bl	bac <Sys_GetCoreID>
    790c:	4603      	mov	r3, r0
    790e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
    7910:	4a10      	ldr	r2, [pc, #64]	; (7954 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    7912:	9b01      	ldr	r3, [sp, #4]
    7914:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7918:	2b00      	cmp	r3, #0
    791a:	d10d      	bne.n	7938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    791c:	f7f9 f85c 	bl	9d8 <Port_schm_read_msr>
    7920:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7922:	9b00      	ldr	r3, [sp, #0]
    7924:	f003 0301 	and.w	r3, r3, #1
    7928:	2b00      	cmp	r3, #0
    792a:	d100      	bne.n	792e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    792c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    792e:	490a      	ldr	r1, [pc, #40]	; (7958 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
    7930:	9b01      	ldr	r3, [sp, #4]
    7932:	9a00      	ldr	r2, [sp, #0]
    7934:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
    7938:	4a06      	ldr	r2, [pc, #24]	; (7954 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    793a:	9b01      	ldr	r3, [sp, #4]
    793c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7940:	1c5a      	adds	r2, r3, #1
    7942:	4904      	ldr	r1, [pc, #16]	; (7954 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
    7944:	9b01      	ldr	r3, [sp, #4]
    7946:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    794a:	bf00      	nop
    794c:	b003      	add	sp, #12
    794e:	f85d fb04 	ldr.w	pc, [sp], #4
    7952:	bf00      	nop
    7954:	1fff8e48 	.word	0x1fff8e48
    7958:	1fff8e44 	.word	0x1fff8e44

0000795c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
    795c:	b500      	push	{lr}
    795e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7960:	f7f9 f924 	bl	bac <Sys_GetCoreID>
    7964:	4603      	mov	r3, r0
    7966:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
    7968:	4a0d      	ldr	r2, [pc, #52]	; (79a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    796a:	9b01      	ldr	r3, [sp, #4]
    796c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7970:	1e5a      	subs	r2, r3, #1
    7972:	490b      	ldr	r1, [pc, #44]	; (79a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    7974:	9b01      	ldr	r3, [sp, #4]
    7976:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    797a:	4a0a      	ldr	r2, [pc, #40]	; (79a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
    797c:	9b01      	ldr	r3, [sp, #4]
    797e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7982:	f003 0301 	and.w	r3, r3, #1
    7986:	2b00      	cmp	r3, #0
    7988:	d106      	bne.n	7998 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    798a:	4a05      	ldr	r2, [pc, #20]	; (79a0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
    798c:	9b01      	ldr	r3, [sp, #4]
    798e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7992:	2b00      	cmp	r3, #0
    7994:	d100      	bne.n	7998 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7996:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7998:	bf00      	nop
    799a:	b003      	add	sp, #12
    799c:	f85d fb04 	ldr.w	pc, [sp], #4
    79a0:	1fff8e48 	.word	0x1fff8e48
    79a4:	1fff8e44 	.word	0x1fff8e44

000079a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    79a8:	b500      	push	{lr}
    79aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    79ac:	f7f9 f8fe 	bl	bac <Sys_GetCoreID>
    79b0:	4603      	mov	r3, r0
    79b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
    79b4:	4a10      	ldr	r2, [pc, #64]	; (79f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    79b6:	9b01      	ldr	r3, [sp, #4]
    79b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79bc:	2b00      	cmp	r3, #0
    79be:	d10d      	bne.n	79dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    79c0:	f7f9 f80a 	bl	9d8 <Port_schm_read_msr>
    79c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    79c6:	9b00      	ldr	r3, [sp, #0]
    79c8:	f003 0301 	and.w	r3, r3, #1
    79cc:	2b00      	cmp	r3, #0
    79ce:	d100      	bne.n	79d2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    79d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    79d2:	490a      	ldr	r1, [pc, #40]	; (79fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
    79d4:	9b01      	ldr	r3, [sp, #4]
    79d6:	9a00      	ldr	r2, [sp, #0]
    79d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
    79dc:	4a06      	ldr	r2, [pc, #24]	; (79f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    79de:	9b01      	ldr	r3, [sp, #4]
    79e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    79e4:	1c5a      	adds	r2, r3, #1
    79e6:	4904      	ldr	r1, [pc, #16]	; (79f8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
    79e8:	9b01      	ldr	r3, [sp, #4]
    79ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    79ee:	bf00      	nop
    79f0:	b003      	add	sp, #12
    79f2:	f85d fb04 	ldr.w	pc, [sp], #4
    79f6:	bf00      	nop
    79f8:	1fff8e50 	.word	0x1fff8e50
    79fc:	1fff8e4c 	.word	0x1fff8e4c

00007a00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
    7a00:	b500      	push	{lr}
    7a02:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7a04:	f7f9 f8d2 	bl	bac <Sys_GetCoreID>
    7a08:	4603      	mov	r3, r0
    7a0a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
    7a0c:	4a0d      	ldr	r2, [pc, #52]	; (7a44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    7a0e:	9b01      	ldr	r3, [sp, #4]
    7a10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a14:	1e5a      	subs	r2, r3, #1
    7a16:	490b      	ldr	r1, [pc, #44]	; (7a44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    7a18:	9b01      	ldr	r3, [sp, #4]
    7a1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    7a1e:	4a0a      	ldr	r2, [pc, #40]	; (7a48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
    7a20:	9b01      	ldr	r3, [sp, #4]
    7a22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a26:	f003 0301 	and.w	r3, r3, #1
    7a2a:	2b00      	cmp	r3, #0
    7a2c:	d106      	bne.n	7a3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    7a2e:	4a05      	ldr	r2, [pc, #20]	; (7a44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
    7a30:	9b01      	ldr	r3, [sp, #4]
    7a32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a36:	2b00      	cmp	r3, #0
    7a38:	d100      	bne.n	7a3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7a3a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7a3c:	bf00      	nop
    7a3e:	b003      	add	sp, #12
    7a40:	f85d fb04 	ldr.w	pc, [sp], #4
    7a44:	1fff8e50 	.word	0x1fff8e50
    7a48:	1fff8e4c 	.word	0x1fff8e4c

00007a4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    7a4c:	b500      	push	{lr}
    7a4e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7a50:	f7f9 f8ac 	bl	bac <Sys_GetCoreID>
    7a54:	4603      	mov	r3, r0
    7a56:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
    7a58:	4a10      	ldr	r2, [pc, #64]	; (7a9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    7a5a:	9b01      	ldr	r3, [sp, #4]
    7a5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a60:	2b00      	cmp	r3, #0
    7a62:	d10d      	bne.n	7a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7a64:	f7f8 ffb8 	bl	9d8 <Port_schm_read_msr>
    7a68:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7a6a:	9b00      	ldr	r3, [sp, #0]
    7a6c:	f003 0301 	and.w	r3, r3, #1
    7a70:	2b00      	cmp	r3, #0
    7a72:	d100      	bne.n	7a76 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7a74:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    7a76:	490a      	ldr	r1, [pc, #40]	; (7aa0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
    7a78:	9b01      	ldr	r3, [sp, #4]
    7a7a:	9a00      	ldr	r2, [sp, #0]
    7a7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
    7a80:	4a06      	ldr	r2, [pc, #24]	; (7a9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    7a82:	9b01      	ldr	r3, [sp, #4]
    7a84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a88:	1c5a      	adds	r2, r3, #1
    7a8a:	4904      	ldr	r1, [pc, #16]	; (7a9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
    7a8c:	9b01      	ldr	r3, [sp, #4]
    7a8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7a92:	bf00      	nop
    7a94:	b003      	add	sp, #12
    7a96:	f85d fb04 	ldr.w	pc, [sp], #4
    7a9a:	bf00      	nop
    7a9c:	1fff8e58 	.word	0x1fff8e58
    7aa0:	1fff8e54 	.word	0x1fff8e54

00007aa4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
    7aa4:	b500      	push	{lr}
    7aa6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7aa8:	f7f9 f880 	bl	bac <Sys_GetCoreID>
    7aac:	4603      	mov	r3, r0
    7aae:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
    7ab0:	4a0d      	ldr	r2, [pc, #52]	; (7ae8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    7ab2:	9b01      	ldr	r3, [sp, #4]
    7ab4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ab8:	1e5a      	subs	r2, r3, #1
    7aba:	490b      	ldr	r1, [pc, #44]	; (7ae8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    7abc:	9b01      	ldr	r3, [sp, #4]
    7abe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    7ac2:	4a0a      	ldr	r2, [pc, #40]	; (7aec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
    7ac4:	9b01      	ldr	r3, [sp, #4]
    7ac6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7aca:	f003 0301 	and.w	r3, r3, #1
    7ace:	2b00      	cmp	r3, #0
    7ad0:	d106      	bne.n	7ae0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    7ad2:	4a05      	ldr	r2, [pc, #20]	; (7ae8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
    7ad4:	9b01      	ldr	r3, [sp, #4]
    7ad6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ada:	2b00      	cmp	r3, #0
    7adc:	d100      	bne.n	7ae0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7ade:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7ae0:	bf00      	nop
    7ae2:	b003      	add	sp, #12
    7ae4:	f85d fb04 	ldr.w	pc, [sp], #4
    7ae8:	1fff8e58 	.word	0x1fff8e58
    7aec:	1fff8e54 	.word	0x1fff8e54

00007af0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    7af0:	b500      	push	{lr}
    7af2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7af4:	f7f9 f85a 	bl	bac <Sys_GetCoreID>
    7af8:	4603      	mov	r3, r0
    7afa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
    7afc:	4a10      	ldr	r2, [pc, #64]	; (7b40 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    7afe:	9b01      	ldr	r3, [sp, #4]
    7b00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b04:	2b00      	cmp	r3, #0
    7b06:	d10d      	bne.n	7b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7b08:	f7f8 ff66 	bl	9d8 <Port_schm_read_msr>
    7b0c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7b0e:	9b00      	ldr	r3, [sp, #0]
    7b10:	f003 0301 	and.w	r3, r3, #1
    7b14:	2b00      	cmp	r3, #0
    7b16:	d100      	bne.n	7b1a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7b18:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    7b1a:	490a      	ldr	r1, [pc, #40]	; (7b44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
    7b1c:	9b01      	ldr	r3, [sp, #4]
    7b1e:	9a00      	ldr	r2, [sp, #0]
    7b20:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
    7b24:	4a06      	ldr	r2, [pc, #24]	; (7b40 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    7b26:	9b01      	ldr	r3, [sp, #4]
    7b28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b2c:	1c5a      	adds	r2, r3, #1
    7b2e:	4904      	ldr	r1, [pc, #16]	; (7b40 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
    7b30:	9b01      	ldr	r3, [sp, #4]
    7b32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7b36:	bf00      	nop
    7b38:	b003      	add	sp, #12
    7b3a:	f85d fb04 	ldr.w	pc, [sp], #4
    7b3e:	bf00      	nop
    7b40:	1fff8e60 	.word	0x1fff8e60
    7b44:	1fff8e5c 	.word	0x1fff8e5c

00007b48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
    7b48:	b500      	push	{lr}
    7b4a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7b4c:	f7f9 f82e 	bl	bac <Sys_GetCoreID>
    7b50:	4603      	mov	r3, r0
    7b52:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
    7b54:	4a0d      	ldr	r2, [pc, #52]	; (7b8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    7b56:	9b01      	ldr	r3, [sp, #4]
    7b58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b5c:	1e5a      	subs	r2, r3, #1
    7b5e:	490b      	ldr	r1, [pc, #44]	; (7b8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    7b60:	9b01      	ldr	r3, [sp, #4]
    7b62:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    7b66:	4a0a      	ldr	r2, [pc, #40]	; (7b90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
    7b68:	9b01      	ldr	r3, [sp, #4]
    7b6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b6e:	f003 0301 	and.w	r3, r3, #1
    7b72:	2b00      	cmp	r3, #0
    7b74:	d106      	bne.n	7b84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    7b76:	4a05      	ldr	r2, [pc, #20]	; (7b8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
    7b78:	9b01      	ldr	r3, [sp, #4]
    7b7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b7e:	2b00      	cmp	r3, #0
    7b80:	d100      	bne.n	7b84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7b82:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7b84:	bf00      	nop
    7b86:	b003      	add	sp, #12
    7b88:	f85d fb04 	ldr.w	pc, [sp], #4
    7b8c:	1fff8e60 	.word	0x1fff8e60
    7b90:	1fff8e5c 	.word	0x1fff8e5c

00007b94 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    7b94:	b500      	push	{lr}
    7b96:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7b98:	f7f9 f808 	bl	bac <Sys_GetCoreID>
    7b9c:	4603      	mov	r3, r0
    7b9e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
    7ba0:	4a10      	ldr	r2, [pc, #64]	; (7be4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    7ba2:	9b01      	ldr	r3, [sp, #4]
    7ba4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ba8:	2b00      	cmp	r3, #0
    7baa:	d10d      	bne.n	7bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7bac:	f7f8 ff14 	bl	9d8 <Port_schm_read_msr>
    7bb0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7bb2:	9b00      	ldr	r3, [sp, #0]
    7bb4:	f003 0301 	and.w	r3, r3, #1
    7bb8:	2b00      	cmp	r3, #0
    7bba:	d100      	bne.n	7bbe <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7bbc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    7bbe:	490a      	ldr	r1, [pc, #40]	; (7be8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
    7bc0:	9b01      	ldr	r3, [sp, #4]
    7bc2:	9a00      	ldr	r2, [sp, #0]
    7bc4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
    7bc8:	4a06      	ldr	r2, [pc, #24]	; (7be4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    7bca:	9b01      	ldr	r3, [sp, #4]
    7bcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bd0:	1c5a      	adds	r2, r3, #1
    7bd2:	4904      	ldr	r1, [pc, #16]	; (7be4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
    7bd4:	9b01      	ldr	r3, [sp, #4]
    7bd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7bda:	bf00      	nop
    7bdc:	b003      	add	sp, #12
    7bde:	f85d fb04 	ldr.w	pc, [sp], #4
    7be2:	bf00      	nop
    7be4:	1fff8e68 	.word	0x1fff8e68
    7be8:	1fff8e64 	.word	0x1fff8e64

00007bec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
    7bec:	b500      	push	{lr}
    7bee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7bf0:	f7f8 ffdc 	bl	bac <Sys_GetCoreID>
    7bf4:	4603      	mov	r3, r0
    7bf6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
    7bf8:	4a0d      	ldr	r2, [pc, #52]	; (7c30 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    7bfa:	9b01      	ldr	r3, [sp, #4]
    7bfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c00:	1e5a      	subs	r2, r3, #1
    7c02:	490b      	ldr	r1, [pc, #44]	; (7c30 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    7c04:	9b01      	ldr	r3, [sp, #4]
    7c06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    7c0a:	4a0a      	ldr	r2, [pc, #40]	; (7c34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
    7c0c:	9b01      	ldr	r3, [sp, #4]
    7c0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c12:	f003 0301 	and.w	r3, r3, #1
    7c16:	2b00      	cmp	r3, #0
    7c18:	d106      	bne.n	7c28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    7c1a:	4a05      	ldr	r2, [pc, #20]	; (7c30 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
    7c1c:	9b01      	ldr	r3, [sp, #4]
    7c1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c22:	2b00      	cmp	r3, #0
    7c24:	d100      	bne.n	7c28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7c26:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7c28:	bf00      	nop
    7c2a:	b003      	add	sp, #12
    7c2c:	f85d fb04 	ldr.w	pc, [sp], #4
    7c30:	1fff8e68 	.word	0x1fff8e68
    7c34:	1fff8e64 	.word	0x1fff8e64

00007c38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    7c38:	b500      	push	{lr}
    7c3a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7c3c:	f7f8 ffb6 	bl	bac <Sys_GetCoreID>
    7c40:	4603      	mov	r3, r0
    7c42:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
    7c44:	4a10      	ldr	r2, [pc, #64]	; (7c88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    7c46:	9b01      	ldr	r3, [sp, #4]
    7c48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c4c:	2b00      	cmp	r3, #0
    7c4e:	d10d      	bne.n	7c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7c50:	f7f8 fec2 	bl	9d8 <Port_schm_read_msr>
    7c54:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7c56:	9b00      	ldr	r3, [sp, #0]
    7c58:	f003 0301 	and.w	r3, r3, #1
    7c5c:	2b00      	cmp	r3, #0
    7c5e:	d100      	bne.n	7c62 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7c60:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    7c62:	490a      	ldr	r1, [pc, #40]	; (7c8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
    7c64:	9b01      	ldr	r3, [sp, #4]
    7c66:	9a00      	ldr	r2, [sp, #0]
    7c68:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
    7c6c:	4a06      	ldr	r2, [pc, #24]	; (7c88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    7c6e:	9b01      	ldr	r3, [sp, #4]
    7c70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c74:	1c5a      	adds	r2, r3, #1
    7c76:	4904      	ldr	r1, [pc, #16]	; (7c88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
    7c78:	9b01      	ldr	r3, [sp, #4]
    7c7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7c7e:	bf00      	nop
    7c80:	b003      	add	sp, #12
    7c82:	f85d fb04 	ldr.w	pc, [sp], #4
    7c86:	bf00      	nop
    7c88:	1fff8e70 	.word	0x1fff8e70
    7c8c:	1fff8e6c 	.word	0x1fff8e6c

00007c90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
    7c90:	b500      	push	{lr}
    7c92:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7c94:	f7f8 ff8a 	bl	bac <Sys_GetCoreID>
    7c98:	4603      	mov	r3, r0
    7c9a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
    7c9c:	4a0d      	ldr	r2, [pc, #52]	; (7cd4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    7c9e:	9b01      	ldr	r3, [sp, #4]
    7ca0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ca4:	1e5a      	subs	r2, r3, #1
    7ca6:	490b      	ldr	r1, [pc, #44]	; (7cd4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    7ca8:	9b01      	ldr	r3, [sp, #4]
    7caa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    7cae:	4a0a      	ldr	r2, [pc, #40]	; (7cd8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
    7cb0:	9b01      	ldr	r3, [sp, #4]
    7cb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cb6:	f003 0301 	and.w	r3, r3, #1
    7cba:	2b00      	cmp	r3, #0
    7cbc:	d106      	bne.n	7ccc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    7cbe:	4a05      	ldr	r2, [pc, #20]	; (7cd4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
    7cc0:	9b01      	ldr	r3, [sp, #4]
    7cc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cc6:	2b00      	cmp	r3, #0
    7cc8:	d100      	bne.n	7ccc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7cca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7ccc:	bf00      	nop
    7cce:	b003      	add	sp, #12
    7cd0:	f85d fb04 	ldr.w	pc, [sp], #4
    7cd4:	1fff8e70 	.word	0x1fff8e70
    7cd8:	1fff8e6c 	.word	0x1fff8e6c

00007cdc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    7cdc:	b500      	push	{lr}
    7cde:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7ce0:	f7f8 ff64 	bl	bac <Sys_GetCoreID>
    7ce4:	4603      	mov	r3, r0
    7ce6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
    7ce8:	4a10      	ldr	r2, [pc, #64]	; (7d2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    7cea:	9b01      	ldr	r3, [sp, #4]
    7cec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cf0:	2b00      	cmp	r3, #0
    7cf2:	d10d      	bne.n	7d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7cf4:	f7f8 fe70 	bl	9d8 <Port_schm_read_msr>
    7cf8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7cfa:	9b00      	ldr	r3, [sp, #0]
    7cfc:	f003 0301 	and.w	r3, r3, #1
    7d00:	2b00      	cmp	r3, #0
    7d02:	d100      	bne.n	7d06 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7d04:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    7d06:	490a      	ldr	r1, [pc, #40]	; (7d30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
    7d08:	9b01      	ldr	r3, [sp, #4]
    7d0a:	9a00      	ldr	r2, [sp, #0]
    7d0c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
    7d10:	4a06      	ldr	r2, [pc, #24]	; (7d2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    7d12:	9b01      	ldr	r3, [sp, #4]
    7d14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d18:	1c5a      	adds	r2, r3, #1
    7d1a:	4904      	ldr	r1, [pc, #16]	; (7d2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
    7d1c:	9b01      	ldr	r3, [sp, #4]
    7d1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7d22:	bf00      	nop
    7d24:	b003      	add	sp, #12
    7d26:	f85d fb04 	ldr.w	pc, [sp], #4
    7d2a:	bf00      	nop
    7d2c:	1fff8e78 	.word	0x1fff8e78
    7d30:	1fff8e74 	.word	0x1fff8e74

00007d34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
    7d34:	b500      	push	{lr}
    7d36:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7d38:	f7f8 ff38 	bl	bac <Sys_GetCoreID>
    7d3c:	4603      	mov	r3, r0
    7d3e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
    7d40:	4a0d      	ldr	r2, [pc, #52]	; (7d78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    7d42:	9b01      	ldr	r3, [sp, #4]
    7d44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d48:	1e5a      	subs	r2, r3, #1
    7d4a:	490b      	ldr	r1, [pc, #44]	; (7d78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    7d4c:	9b01      	ldr	r3, [sp, #4]
    7d4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    7d52:	4a0a      	ldr	r2, [pc, #40]	; (7d7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
    7d54:	9b01      	ldr	r3, [sp, #4]
    7d56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d5a:	f003 0301 	and.w	r3, r3, #1
    7d5e:	2b00      	cmp	r3, #0
    7d60:	d106      	bne.n	7d70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    7d62:	4a05      	ldr	r2, [pc, #20]	; (7d78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
    7d64:	9b01      	ldr	r3, [sp, #4]
    7d66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d6a:	2b00      	cmp	r3, #0
    7d6c:	d100      	bne.n	7d70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7d6e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7d70:	bf00      	nop
    7d72:	b003      	add	sp, #12
    7d74:	f85d fb04 	ldr.w	pc, [sp], #4
    7d78:	1fff8e78 	.word	0x1fff8e78
    7d7c:	1fff8e74 	.word	0x1fff8e74

00007d80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    7d80:	b500      	push	{lr}
    7d82:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7d84:	f7f8 ff12 	bl	bac <Sys_GetCoreID>
    7d88:	4603      	mov	r3, r0
    7d8a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
    7d8c:	4a10      	ldr	r2, [pc, #64]	; (7dd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    7d8e:	9b01      	ldr	r3, [sp, #4]
    7d90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d94:	2b00      	cmp	r3, #0
    7d96:	d10d      	bne.n	7db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7d98:	f7f8 fe1e 	bl	9d8 <Port_schm_read_msr>
    7d9c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7d9e:	9b00      	ldr	r3, [sp, #0]
    7da0:	f003 0301 	and.w	r3, r3, #1
    7da4:	2b00      	cmp	r3, #0
    7da6:	d100      	bne.n	7daa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7da8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    7daa:	490a      	ldr	r1, [pc, #40]	; (7dd4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
    7dac:	9b01      	ldr	r3, [sp, #4]
    7dae:	9a00      	ldr	r2, [sp, #0]
    7db0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
    7db4:	4a06      	ldr	r2, [pc, #24]	; (7dd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    7db6:	9b01      	ldr	r3, [sp, #4]
    7db8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dbc:	1c5a      	adds	r2, r3, #1
    7dbe:	4904      	ldr	r1, [pc, #16]	; (7dd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
    7dc0:	9b01      	ldr	r3, [sp, #4]
    7dc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7dc6:	bf00      	nop
    7dc8:	b003      	add	sp, #12
    7dca:	f85d fb04 	ldr.w	pc, [sp], #4
    7dce:	bf00      	nop
    7dd0:	1fff8e80 	.word	0x1fff8e80
    7dd4:	1fff8e7c 	.word	0x1fff8e7c

00007dd8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
    7dd8:	b500      	push	{lr}
    7dda:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7ddc:	f7f8 fee6 	bl	bac <Sys_GetCoreID>
    7de0:	4603      	mov	r3, r0
    7de2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
    7de4:	4a0d      	ldr	r2, [pc, #52]	; (7e1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    7de6:	9b01      	ldr	r3, [sp, #4]
    7de8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dec:	1e5a      	subs	r2, r3, #1
    7dee:	490b      	ldr	r1, [pc, #44]	; (7e1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    7df0:	9b01      	ldr	r3, [sp, #4]
    7df2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    7df6:	4a0a      	ldr	r2, [pc, #40]	; (7e20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
    7df8:	9b01      	ldr	r3, [sp, #4]
    7dfa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dfe:	f003 0301 	and.w	r3, r3, #1
    7e02:	2b00      	cmp	r3, #0
    7e04:	d106      	bne.n	7e14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    7e06:	4a05      	ldr	r2, [pc, #20]	; (7e1c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
    7e08:	9b01      	ldr	r3, [sp, #4]
    7e0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e0e:	2b00      	cmp	r3, #0
    7e10:	d100      	bne.n	7e14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7e12:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7e14:	bf00      	nop
    7e16:	b003      	add	sp, #12
    7e18:	f85d fb04 	ldr.w	pc, [sp], #4
    7e1c:	1fff8e80 	.word	0x1fff8e80
    7e20:	1fff8e7c 	.word	0x1fff8e7c

00007e24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    7e24:	b500      	push	{lr}
    7e26:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7e28:	f7f8 fec0 	bl	bac <Sys_GetCoreID>
    7e2c:	4603      	mov	r3, r0
    7e2e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
    7e30:	4a10      	ldr	r2, [pc, #64]	; (7e74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    7e32:	9b01      	ldr	r3, [sp, #4]
    7e34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e38:	2b00      	cmp	r3, #0
    7e3a:	d10d      	bne.n	7e58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7e3c:	f7f8 fdcc 	bl	9d8 <Port_schm_read_msr>
    7e40:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7e42:	9b00      	ldr	r3, [sp, #0]
    7e44:	f003 0301 	and.w	r3, r3, #1
    7e48:	2b00      	cmp	r3, #0
    7e4a:	d100      	bne.n	7e4e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7e4c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    7e4e:	490a      	ldr	r1, [pc, #40]	; (7e78 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
    7e50:	9b01      	ldr	r3, [sp, #4]
    7e52:	9a00      	ldr	r2, [sp, #0]
    7e54:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
    7e58:	4a06      	ldr	r2, [pc, #24]	; (7e74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    7e5a:	9b01      	ldr	r3, [sp, #4]
    7e5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e60:	1c5a      	adds	r2, r3, #1
    7e62:	4904      	ldr	r1, [pc, #16]	; (7e74 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
    7e64:	9b01      	ldr	r3, [sp, #4]
    7e66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7e6a:	bf00      	nop
    7e6c:	b003      	add	sp, #12
    7e6e:	f85d fb04 	ldr.w	pc, [sp], #4
    7e72:	bf00      	nop
    7e74:	1fff8e88 	.word	0x1fff8e88
    7e78:	1fff8e84 	.word	0x1fff8e84

00007e7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
    7e7c:	b500      	push	{lr}
    7e7e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7e80:	f7f8 fe94 	bl	bac <Sys_GetCoreID>
    7e84:	4603      	mov	r3, r0
    7e86:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
    7e88:	4a0d      	ldr	r2, [pc, #52]	; (7ec0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    7e8a:	9b01      	ldr	r3, [sp, #4]
    7e8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e90:	1e5a      	subs	r2, r3, #1
    7e92:	490b      	ldr	r1, [pc, #44]	; (7ec0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    7e94:	9b01      	ldr	r3, [sp, #4]
    7e96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    7e9a:	4a0a      	ldr	r2, [pc, #40]	; (7ec4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
    7e9c:	9b01      	ldr	r3, [sp, #4]
    7e9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ea2:	f003 0301 	and.w	r3, r3, #1
    7ea6:	2b00      	cmp	r3, #0
    7ea8:	d106      	bne.n	7eb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    7eaa:	4a05      	ldr	r2, [pc, #20]	; (7ec0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
    7eac:	9b01      	ldr	r3, [sp, #4]
    7eae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7eb2:	2b00      	cmp	r3, #0
    7eb4:	d100      	bne.n	7eb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7eb6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7eb8:	bf00      	nop
    7eba:	b003      	add	sp, #12
    7ebc:	f85d fb04 	ldr.w	pc, [sp], #4
    7ec0:	1fff8e88 	.word	0x1fff8e88
    7ec4:	1fff8e84 	.word	0x1fff8e84

00007ec8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    7ec8:	b500      	push	{lr}
    7eca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7ecc:	f7f8 fe6e 	bl	bac <Sys_GetCoreID>
    7ed0:	4603      	mov	r3, r0
    7ed2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
    7ed4:	4a10      	ldr	r2, [pc, #64]	; (7f18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    7ed6:	9b01      	ldr	r3, [sp, #4]
    7ed8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7edc:	2b00      	cmp	r3, #0
    7ede:	d10d      	bne.n	7efc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7ee0:	f7f8 fd7a 	bl	9d8 <Port_schm_read_msr>
    7ee4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7ee6:	9b00      	ldr	r3, [sp, #0]
    7ee8:	f003 0301 	and.w	r3, r3, #1
    7eec:	2b00      	cmp	r3, #0
    7eee:	d100      	bne.n	7ef2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7ef0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    7ef2:	490a      	ldr	r1, [pc, #40]	; (7f1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
    7ef4:	9b01      	ldr	r3, [sp, #4]
    7ef6:	9a00      	ldr	r2, [sp, #0]
    7ef8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
    7efc:	4a06      	ldr	r2, [pc, #24]	; (7f18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    7efe:	9b01      	ldr	r3, [sp, #4]
    7f00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f04:	1c5a      	adds	r2, r3, #1
    7f06:	4904      	ldr	r1, [pc, #16]	; (7f18 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
    7f08:	9b01      	ldr	r3, [sp, #4]
    7f0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7f0e:	bf00      	nop
    7f10:	b003      	add	sp, #12
    7f12:	f85d fb04 	ldr.w	pc, [sp], #4
    7f16:	bf00      	nop
    7f18:	1fff8e90 	.word	0x1fff8e90
    7f1c:	1fff8e8c 	.word	0x1fff8e8c

00007f20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
    7f20:	b500      	push	{lr}
    7f22:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7f24:	f7f8 fe42 	bl	bac <Sys_GetCoreID>
    7f28:	4603      	mov	r3, r0
    7f2a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
    7f2c:	4a0d      	ldr	r2, [pc, #52]	; (7f64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    7f2e:	9b01      	ldr	r3, [sp, #4]
    7f30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f34:	1e5a      	subs	r2, r3, #1
    7f36:	490b      	ldr	r1, [pc, #44]	; (7f64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    7f38:	9b01      	ldr	r3, [sp, #4]
    7f3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    7f3e:	4a0a      	ldr	r2, [pc, #40]	; (7f68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
    7f40:	9b01      	ldr	r3, [sp, #4]
    7f42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f46:	f003 0301 	and.w	r3, r3, #1
    7f4a:	2b00      	cmp	r3, #0
    7f4c:	d106      	bne.n	7f5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    7f4e:	4a05      	ldr	r2, [pc, #20]	; (7f64 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
    7f50:	9b01      	ldr	r3, [sp, #4]
    7f52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f56:	2b00      	cmp	r3, #0
    7f58:	d100      	bne.n	7f5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7f5a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    7f5c:	bf00      	nop
    7f5e:	b003      	add	sp, #12
    7f60:	f85d fb04 	ldr.w	pc, [sp], #4
    7f64:	1fff8e90 	.word	0x1fff8e90
    7f68:	1fff8e8c 	.word	0x1fff8e8c

00007f6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    7f6c:	b500      	push	{lr}
    7f6e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7f70:	f7f8 fe1c 	bl	bac <Sys_GetCoreID>
    7f74:	4603      	mov	r3, r0
    7f76:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
    7f78:	4a10      	ldr	r2, [pc, #64]	; (7fbc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    7f7a:	9b01      	ldr	r3, [sp, #4]
    7f7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f80:	2b00      	cmp	r3, #0
    7f82:	d10d      	bne.n	7fa0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
    7f84:	f7f8 fd28 	bl	9d8 <Port_schm_read_msr>
    7f88:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    7f8a:	9b00      	ldr	r3, [sp, #0]
    7f8c:	f003 0301 	and.w	r3, r3, #1
    7f90:	2b00      	cmp	r3, #0
    7f92:	d100      	bne.n	7f96 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    7f94:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
    7f96:	490a      	ldr	r1, [pc, #40]	; (7fc0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
    7f98:	9b01      	ldr	r3, [sp, #4]
    7f9a:	9a00      	ldr	r2, [sp, #0]
    7f9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
    7fa0:	4a06      	ldr	r2, [pc, #24]	; (7fbc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    7fa2:	9b01      	ldr	r3, [sp, #4]
    7fa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fa8:	1c5a      	adds	r2, r3, #1
    7faa:	4904      	ldr	r1, [pc, #16]	; (7fbc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
    7fac:	9b01      	ldr	r3, [sp, #4]
    7fae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    7fb2:	bf00      	nop
    7fb4:	b003      	add	sp, #12
    7fb6:	f85d fb04 	ldr.w	pc, [sp], #4
    7fba:	bf00      	nop
    7fbc:	1fff8e98 	.word	0x1fff8e98
    7fc0:	1fff8e94 	.word	0x1fff8e94

00007fc4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
    7fc4:	b500      	push	{lr}
    7fc6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    7fc8:	f7f8 fdf0 	bl	bac <Sys_GetCoreID>
    7fcc:	4603      	mov	r3, r0
    7fce:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
    7fd0:	4a0d      	ldr	r2, [pc, #52]	; (8008 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    7fd2:	9b01      	ldr	r3, [sp, #4]
    7fd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fd8:	1e5a      	subs	r2, r3, #1
    7fda:	490b      	ldr	r1, [pc, #44]	; (8008 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    7fdc:	9b01      	ldr	r3, [sp, #4]
    7fde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
    7fe2:	4a0a      	ldr	r2, [pc, #40]	; (800c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
    7fe4:	9b01      	ldr	r3, [sp, #4]
    7fe6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fea:	f003 0301 	and.w	r3, r3, #1
    7fee:	2b00      	cmp	r3, #0
    7ff0:	d106      	bne.n	8000 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    7ff2:	4a05      	ldr	r2, [pc, #20]	; (8008 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
    7ff4:	9b01      	ldr	r3, [sp, #4]
    7ff6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ffa:	2b00      	cmp	r3, #0
    7ffc:	d100      	bne.n	8000 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    7ffe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8000:	bf00      	nop
    8002:	b003      	add	sp, #12
    8004:	f85d fb04 	ldr.w	pc, [sp], #4
    8008:	1fff8e98 	.word	0x1fff8e98
    800c:	1fff8e94 	.word	0x1fff8e94

00008010 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00(void)
{
    8010:	b500      	push	{lr}
    8012:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8014:	f7f8 fdca 	bl	bac <Sys_GetCoreID>
    8018:	4603      	mov	r3, r0
    801a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId])
    801c:	4a10      	ldr	r2, [pc, #64]	; (8060 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x50>)
    801e:	9b01      	ldr	r3, [sp, #4]
    8020:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8024:	2b00      	cmp	r3, #0
    8026:	d10d      	bne.n	8044 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8028:	f7f8 fcdf 	bl	9ea <Gpt_schm_read_msr>
    802c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    802e:	9b00      	ldr	r3, [sp, #0]
    8030:	f003 0301 	and.w	r3, r3, #1
    8034:	2b00      	cmp	r3, #0
    8036:	d100      	bne.n	803a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8038:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    803a:	490a      	ldr	r1, [pc, #40]	; (8064 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x54>)
    803c:	9b01      	ldr	r3, [sp, #4]
    803e:	9a00      	ldr	r2, [sp, #0]
    8040:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId]++;
    8044:	4a06      	ldr	r2, [pc, #24]	; (8060 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x50>)
    8046:	9b01      	ldr	r3, [sp, #4]
    8048:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    804c:	1c5a      	adds	r2, r3, #1
    804e:	4904      	ldr	r1, [pc, #16]	; (8060 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_00+0x50>)
    8050:	9b01      	ldr	r3, [sp, #4]
    8052:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8056:	bf00      	nop
    8058:	b003      	add	sp, #12
    805a:	f85d fb04 	ldr.w	pc, [sp], #4
    805e:	bf00      	nop
    8060:	1fff8ea0 	.word	0x1fff8ea0
    8064:	1fff8e9c 	.word	0x1fff8e9c

00008068 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00(void)
{
    8068:	b500      	push	{lr}
    806a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    806c:	f7f8 fd9e 	bl	bac <Sys_GetCoreID>
    8070:	4603      	mov	r3, r0
    8072:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId]--;
    8074:	4a0d      	ldr	r2, [pc, #52]	; (80ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x44>)
    8076:	9b01      	ldr	r3, [sp, #4]
    8078:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    807c:	1e5a      	subs	r2, r3, #1
    807e:	490b      	ldr	r1, [pc, #44]	; (80ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x44>)
    8080:	9b01      	ldr	r3, [sp, #4]
    8082:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    8086:	4a0a      	ldr	r2, [pc, #40]	; (80b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x48>)
    8088:	9b01      	ldr	r3, [sp, #4]
    808a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    808e:	f003 0301 	and.w	r3, r3, #1
    8092:	2b00      	cmp	r3, #0
    8094:	d106      	bne.n	80a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x3c>
    8096:	4a05      	ldr	r2, [pc, #20]	; (80ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x44>)
    8098:	9b01      	ldr	r3, [sp, #4]
    809a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    809e:	2b00      	cmp	r3, #0
    80a0:	d100      	bne.n	80a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    80a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    80a4:	bf00      	nop
    80a6:	b003      	add	sp, #12
    80a8:	f85d fb04 	ldr.w	pc, [sp], #4
    80ac:	1fff8ea0 	.word	0x1fff8ea0
    80b0:	1fff8e9c 	.word	0x1fff8e9c

000080b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01(void)
{
    80b4:	b500      	push	{lr}
    80b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    80b8:	f7f8 fd78 	bl	bac <Sys_GetCoreID>
    80bc:	4603      	mov	r3, r0
    80be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId])
    80c0:	4a10      	ldr	r2, [pc, #64]	; (8104 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x50>)
    80c2:	9b01      	ldr	r3, [sp, #4]
    80c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80c8:	2b00      	cmp	r3, #0
    80ca:	d10d      	bne.n	80e8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    80cc:	f7f8 fc8d 	bl	9ea <Gpt_schm_read_msr>
    80d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    80d2:	9b00      	ldr	r3, [sp, #0]
    80d4:	f003 0301 	and.w	r3, r3, #1
    80d8:	2b00      	cmp	r3, #0
    80da:	d100      	bne.n	80de <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    80dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    80de:	490a      	ldr	r1, [pc, #40]	; (8108 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x54>)
    80e0:	9b01      	ldr	r3, [sp, #4]
    80e2:	9a00      	ldr	r2, [sp, #0]
    80e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId]++;
    80e8:	4a06      	ldr	r2, [pc, #24]	; (8104 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x50>)
    80ea:	9b01      	ldr	r3, [sp, #4]
    80ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80f0:	1c5a      	adds	r2, r3, #1
    80f2:	4904      	ldr	r1, [pc, #16]	; (8104 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_01+0x50>)
    80f4:	9b01      	ldr	r3, [sp, #4]
    80f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    80fa:	bf00      	nop
    80fc:	b003      	add	sp, #12
    80fe:	f85d fb04 	ldr.w	pc, [sp], #4
    8102:	bf00      	nop
    8104:	1fff8ea8 	.word	0x1fff8ea8
    8108:	1fff8ea4 	.word	0x1fff8ea4

0000810c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01(void)
{
    810c:	b500      	push	{lr}
    810e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8110:	f7f8 fd4c 	bl	bac <Sys_GetCoreID>
    8114:	4603      	mov	r3, r0
    8116:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId]--;
    8118:	4a0d      	ldr	r2, [pc, #52]	; (8150 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x44>)
    811a:	9b01      	ldr	r3, [sp, #4]
    811c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8120:	1e5a      	subs	r2, r3, #1
    8122:	490b      	ldr	r1, [pc, #44]	; (8150 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x44>)
    8124:	9b01      	ldr	r3, [sp, #4]
    8126:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    812a:	4a0a      	ldr	r2, [pc, #40]	; (8154 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x48>)
    812c:	9b01      	ldr	r3, [sp, #4]
    812e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8132:	f003 0301 	and.w	r3, r3, #1
    8136:	2b00      	cmp	r3, #0
    8138:	d106      	bne.n	8148 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x3c>
    813a:	4a05      	ldr	r2, [pc, #20]	; (8150 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x44>)
    813c:	9b01      	ldr	r3, [sp, #4]
    813e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8142:	2b00      	cmp	r3, #0
    8144:	d100      	bne.n	8148 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8146:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8148:	bf00      	nop
    814a:	b003      	add	sp, #12
    814c:	f85d fb04 	ldr.w	pc, [sp], #4
    8150:	1fff8ea8 	.word	0x1fff8ea8
    8154:	1fff8ea4 	.word	0x1fff8ea4

00008158 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02(void)
{
    8158:	b500      	push	{lr}
    815a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    815c:	f7f8 fd26 	bl	bac <Sys_GetCoreID>
    8160:	4603      	mov	r3, r0
    8162:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId])
    8164:	4a10      	ldr	r2, [pc, #64]	; (81a8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x50>)
    8166:	9b01      	ldr	r3, [sp, #4]
    8168:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    816c:	2b00      	cmp	r3, #0
    816e:	d10d      	bne.n	818c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8170:	f7f8 fc3b 	bl	9ea <Gpt_schm_read_msr>
    8174:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8176:	9b00      	ldr	r3, [sp, #0]
    8178:	f003 0301 	and.w	r3, r3, #1
    817c:	2b00      	cmp	r3, #0
    817e:	d100      	bne.n	8182 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8180:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    8182:	490a      	ldr	r1, [pc, #40]	; (81ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x54>)
    8184:	9b01      	ldr	r3, [sp, #4]
    8186:	9a00      	ldr	r2, [sp, #0]
    8188:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId]++;
    818c:	4a06      	ldr	r2, [pc, #24]	; (81a8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x50>)
    818e:	9b01      	ldr	r3, [sp, #4]
    8190:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8194:	1c5a      	adds	r2, r3, #1
    8196:	4904      	ldr	r1, [pc, #16]	; (81a8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_02+0x50>)
    8198:	9b01      	ldr	r3, [sp, #4]
    819a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    819e:	bf00      	nop
    81a0:	b003      	add	sp, #12
    81a2:	f85d fb04 	ldr.w	pc, [sp], #4
    81a6:	bf00      	nop
    81a8:	1fff8eb0 	.word	0x1fff8eb0
    81ac:	1fff8eac 	.word	0x1fff8eac

000081b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02(void)
{
    81b0:	b500      	push	{lr}
    81b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    81b4:	f7f8 fcfa 	bl	bac <Sys_GetCoreID>
    81b8:	4603      	mov	r3, r0
    81ba:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId]--;
    81bc:	4a0d      	ldr	r2, [pc, #52]	; (81f4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x44>)
    81be:	9b01      	ldr	r3, [sp, #4]
    81c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81c4:	1e5a      	subs	r2, r3, #1
    81c6:	490b      	ldr	r1, [pc, #44]	; (81f4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x44>)
    81c8:	9b01      	ldr	r3, [sp, #4]
    81ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    81ce:	4a0a      	ldr	r2, [pc, #40]	; (81f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x48>)
    81d0:	9b01      	ldr	r3, [sp, #4]
    81d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81d6:	f003 0301 	and.w	r3, r3, #1
    81da:	2b00      	cmp	r3, #0
    81dc:	d106      	bne.n	81ec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x3c>
    81de:	4a05      	ldr	r2, [pc, #20]	; (81f4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x44>)
    81e0:	9b01      	ldr	r3, [sp, #4]
    81e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81e6:	2b00      	cmp	r3, #0
    81e8:	d100      	bne.n	81ec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    81ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    81ec:	bf00      	nop
    81ee:	b003      	add	sp, #12
    81f0:	f85d fb04 	ldr.w	pc, [sp], #4
    81f4:	1fff8eb0 	.word	0x1fff8eb0
    81f8:	1fff8eac 	.word	0x1fff8eac

000081fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03(void)
{
    81fc:	b500      	push	{lr}
    81fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8200:	f7f8 fcd4 	bl	bac <Sys_GetCoreID>
    8204:	4603      	mov	r3, r0
    8206:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId])
    8208:	4a10      	ldr	r2, [pc, #64]	; (824c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x50>)
    820a:	9b01      	ldr	r3, [sp, #4]
    820c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8210:	2b00      	cmp	r3, #0
    8212:	d10d      	bne.n	8230 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8214:	f7f8 fbe9 	bl	9ea <Gpt_schm_read_msr>
    8218:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    821a:	9b00      	ldr	r3, [sp, #0]
    821c:	f003 0301 	and.w	r3, r3, #1
    8220:	2b00      	cmp	r3, #0
    8222:	d100      	bne.n	8226 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8224:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    8226:	490a      	ldr	r1, [pc, #40]	; (8250 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x54>)
    8228:	9b01      	ldr	r3, [sp, #4]
    822a:	9a00      	ldr	r2, [sp, #0]
    822c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId]++;
    8230:	4a06      	ldr	r2, [pc, #24]	; (824c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x50>)
    8232:	9b01      	ldr	r3, [sp, #4]
    8234:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8238:	1c5a      	adds	r2, r3, #1
    823a:	4904      	ldr	r1, [pc, #16]	; (824c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_03+0x50>)
    823c:	9b01      	ldr	r3, [sp, #4]
    823e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8242:	bf00      	nop
    8244:	b003      	add	sp, #12
    8246:	f85d fb04 	ldr.w	pc, [sp], #4
    824a:	bf00      	nop
    824c:	1fff8eb8 	.word	0x1fff8eb8
    8250:	1fff8eb4 	.word	0x1fff8eb4

00008254 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03(void)
{
    8254:	b500      	push	{lr}
    8256:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8258:	f7f8 fca8 	bl	bac <Sys_GetCoreID>
    825c:	4603      	mov	r3, r0
    825e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId]--;
    8260:	4a0d      	ldr	r2, [pc, #52]	; (8298 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x44>)
    8262:	9b01      	ldr	r3, [sp, #4]
    8264:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8268:	1e5a      	subs	r2, r3, #1
    826a:	490b      	ldr	r1, [pc, #44]	; (8298 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x44>)
    826c:	9b01      	ldr	r3, [sp, #4]
    826e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    8272:	4a0a      	ldr	r2, [pc, #40]	; (829c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x48>)
    8274:	9b01      	ldr	r3, [sp, #4]
    8276:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    827a:	f003 0301 	and.w	r3, r3, #1
    827e:	2b00      	cmp	r3, #0
    8280:	d106      	bne.n	8290 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x3c>
    8282:	4a05      	ldr	r2, [pc, #20]	; (8298 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x44>)
    8284:	9b01      	ldr	r3, [sp, #4]
    8286:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    828a:	2b00      	cmp	r3, #0
    828c:	d100      	bne.n	8290 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    828e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8290:	bf00      	nop
    8292:	b003      	add	sp, #12
    8294:	f85d fb04 	ldr.w	pc, [sp], #4
    8298:	1fff8eb8 	.word	0x1fff8eb8
    829c:	1fff8eb4 	.word	0x1fff8eb4

000082a0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04(void)
{
    82a0:	b500      	push	{lr}
    82a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    82a4:	f7f8 fc82 	bl	bac <Sys_GetCoreID>
    82a8:	4603      	mov	r3, r0
    82aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId])
    82ac:	4a10      	ldr	r2, [pc, #64]	; (82f0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x50>)
    82ae:	9b01      	ldr	r3, [sp, #4]
    82b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82b4:	2b00      	cmp	r3, #0
    82b6:	d10d      	bne.n	82d4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    82b8:	f7f8 fb97 	bl	9ea <Gpt_schm_read_msr>
    82bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    82be:	9b00      	ldr	r3, [sp, #0]
    82c0:	f003 0301 	and.w	r3, r3, #1
    82c4:	2b00      	cmp	r3, #0
    82c6:	d100      	bne.n	82ca <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    82c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    82ca:	490a      	ldr	r1, [pc, #40]	; (82f4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x54>)
    82cc:	9b01      	ldr	r3, [sp, #4]
    82ce:	9a00      	ldr	r2, [sp, #0]
    82d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId]++;
    82d4:	4a06      	ldr	r2, [pc, #24]	; (82f0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x50>)
    82d6:	9b01      	ldr	r3, [sp, #4]
    82d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82dc:	1c5a      	adds	r2, r3, #1
    82de:	4904      	ldr	r1, [pc, #16]	; (82f0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_04+0x50>)
    82e0:	9b01      	ldr	r3, [sp, #4]
    82e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    82e6:	bf00      	nop
    82e8:	b003      	add	sp, #12
    82ea:	f85d fb04 	ldr.w	pc, [sp], #4
    82ee:	bf00      	nop
    82f0:	1fff8ec0 	.word	0x1fff8ec0
    82f4:	1fff8ebc 	.word	0x1fff8ebc

000082f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04(void)
{
    82f8:	b500      	push	{lr}
    82fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    82fc:	f7f8 fc56 	bl	bac <Sys_GetCoreID>
    8300:	4603      	mov	r3, r0
    8302:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId]--;
    8304:	4a0d      	ldr	r2, [pc, #52]	; (833c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x44>)
    8306:	9b01      	ldr	r3, [sp, #4]
    8308:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    830c:	1e5a      	subs	r2, r3, #1
    830e:	490b      	ldr	r1, [pc, #44]	; (833c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x44>)
    8310:	9b01      	ldr	r3, [sp, #4]
    8312:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    8316:	4a0a      	ldr	r2, [pc, #40]	; (8340 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x48>)
    8318:	9b01      	ldr	r3, [sp, #4]
    831a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    831e:	f003 0301 	and.w	r3, r3, #1
    8322:	2b00      	cmp	r3, #0
    8324:	d106      	bne.n	8334 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x3c>
    8326:	4a05      	ldr	r2, [pc, #20]	; (833c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x44>)
    8328:	9b01      	ldr	r3, [sp, #4]
    832a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    832e:	2b00      	cmp	r3, #0
    8330:	d100      	bne.n	8334 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8332:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8334:	bf00      	nop
    8336:	b003      	add	sp, #12
    8338:	f85d fb04 	ldr.w	pc, [sp], #4
    833c:	1fff8ec0 	.word	0x1fff8ec0
    8340:	1fff8ebc 	.word	0x1fff8ebc

00008344 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05(void)
{
    8344:	b500      	push	{lr}
    8346:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8348:	f7f8 fc30 	bl	bac <Sys_GetCoreID>
    834c:	4603      	mov	r3, r0
    834e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId])
    8350:	4a10      	ldr	r2, [pc, #64]	; (8394 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x50>)
    8352:	9b01      	ldr	r3, [sp, #4]
    8354:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8358:	2b00      	cmp	r3, #0
    835a:	d10d      	bne.n	8378 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    835c:	f7f8 fb45 	bl	9ea <Gpt_schm_read_msr>
    8360:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8362:	9b00      	ldr	r3, [sp, #0]
    8364:	f003 0301 	and.w	r3, r3, #1
    8368:	2b00      	cmp	r3, #0
    836a:	d100      	bne.n	836e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    836c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    836e:	490a      	ldr	r1, [pc, #40]	; (8398 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x54>)
    8370:	9b01      	ldr	r3, [sp, #4]
    8372:	9a00      	ldr	r2, [sp, #0]
    8374:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId]++;
    8378:	4a06      	ldr	r2, [pc, #24]	; (8394 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x50>)
    837a:	9b01      	ldr	r3, [sp, #4]
    837c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8380:	1c5a      	adds	r2, r3, #1
    8382:	4904      	ldr	r1, [pc, #16]	; (8394 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_05+0x50>)
    8384:	9b01      	ldr	r3, [sp, #4]
    8386:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    838a:	bf00      	nop
    838c:	b003      	add	sp, #12
    838e:	f85d fb04 	ldr.w	pc, [sp], #4
    8392:	bf00      	nop
    8394:	1fff8ec8 	.word	0x1fff8ec8
    8398:	1fff8ec4 	.word	0x1fff8ec4

0000839c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05(void)
{
    839c:	b500      	push	{lr}
    839e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    83a0:	f7f8 fc04 	bl	bac <Sys_GetCoreID>
    83a4:	4603      	mov	r3, r0
    83a6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId]--;
    83a8:	4a0d      	ldr	r2, [pc, #52]	; (83e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x44>)
    83aa:	9b01      	ldr	r3, [sp, #4]
    83ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83b0:	1e5a      	subs	r2, r3, #1
    83b2:	490b      	ldr	r1, [pc, #44]	; (83e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x44>)
    83b4:	9b01      	ldr	r3, [sp, #4]
    83b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    83ba:	4a0a      	ldr	r2, [pc, #40]	; (83e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x48>)
    83bc:	9b01      	ldr	r3, [sp, #4]
    83be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83c2:	f003 0301 	and.w	r3, r3, #1
    83c6:	2b00      	cmp	r3, #0
    83c8:	d106      	bne.n	83d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x3c>
    83ca:	4a05      	ldr	r2, [pc, #20]	; (83e0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x44>)
    83cc:	9b01      	ldr	r3, [sp, #4]
    83ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83d2:	2b00      	cmp	r3, #0
    83d4:	d100      	bne.n	83d8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    83d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    83d8:	bf00      	nop
    83da:	b003      	add	sp, #12
    83dc:	f85d fb04 	ldr.w	pc, [sp], #4
    83e0:	1fff8ec8 	.word	0x1fff8ec8
    83e4:	1fff8ec4 	.word	0x1fff8ec4

000083e8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06(void)
{
    83e8:	b500      	push	{lr}
    83ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    83ec:	f7f8 fbde 	bl	bac <Sys_GetCoreID>
    83f0:	4603      	mov	r3, r0
    83f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId])
    83f4:	4a10      	ldr	r2, [pc, #64]	; (8438 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x50>)
    83f6:	9b01      	ldr	r3, [sp, #4]
    83f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83fc:	2b00      	cmp	r3, #0
    83fe:	d10d      	bne.n	841c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8400:	f7f8 faf3 	bl	9ea <Gpt_schm_read_msr>
    8404:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8406:	9b00      	ldr	r3, [sp, #0]
    8408:	f003 0301 	and.w	r3, r3, #1
    840c:	2b00      	cmp	r3, #0
    840e:	d100      	bne.n	8412 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8410:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
    8412:	490a      	ldr	r1, [pc, #40]	; (843c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x54>)
    8414:	9b01      	ldr	r3, [sp, #4]
    8416:	9a00      	ldr	r2, [sp, #0]
    8418:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId]++;
    841c:	4a06      	ldr	r2, [pc, #24]	; (8438 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x50>)
    841e:	9b01      	ldr	r3, [sp, #4]
    8420:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8424:	1c5a      	adds	r2, r3, #1
    8426:	4904      	ldr	r1, [pc, #16]	; (8438 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_06+0x50>)
    8428:	9b01      	ldr	r3, [sp, #4]
    842a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    842e:	bf00      	nop
    8430:	b003      	add	sp, #12
    8432:	f85d fb04 	ldr.w	pc, [sp], #4
    8436:	bf00      	nop
    8438:	1fff8ed0 	.word	0x1fff8ed0
    843c:	1fff8ecc 	.word	0x1fff8ecc

00008440 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06(void)
{
    8440:	b500      	push	{lr}
    8442:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8444:	f7f8 fbb2 	bl	bac <Sys_GetCoreID>
    8448:	4603      	mov	r3, r0
    844a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId]--;
    844c:	4a0d      	ldr	r2, [pc, #52]	; (8484 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x44>)
    844e:	9b01      	ldr	r3, [sp, #4]
    8450:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8454:	1e5a      	subs	r2, r3, #1
    8456:	490b      	ldr	r1, [pc, #44]	; (8484 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x44>)
    8458:	9b01      	ldr	r3, [sp, #4]
    845a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
    845e:	4a0a      	ldr	r2, [pc, #40]	; (8488 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x48>)
    8460:	9b01      	ldr	r3, [sp, #4]
    8462:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8466:	f003 0301 	and.w	r3, r3, #1
    846a:	2b00      	cmp	r3, #0
    846c:	d106      	bne.n	847c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x3c>
    846e:	4a05      	ldr	r2, [pc, #20]	; (8484 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x44>)
    8470:	9b01      	ldr	r3, [sp, #4]
    8472:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8476:	2b00      	cmp	r3, #0
    8478:	d100      	bne.n	847c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    847a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    847c:	bf00      	nop
    847e:	b003      	add	sp, #12
    8480:	f85d fb04 	ldr.w	pc, [sp], #4
    8484:	1fff8ed0 	.word	0x1fff8ed0
    8488:	1fff8ecc 	.word	0x1fff8ecc

0000848c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07(void)
{
    848c:	b500      	push	{lr}
    848e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8490:	f7f8 fb8c 	bl	bac <Sys_GetCoreID>
    8494:	4603      	mov	r3, r0
    8496:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId])
    8498:	4a10      	ldr	r2, [pc, #64]	; (84dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x50>)
    849a:	9b01      	ldr	r3, [sp, #4]
    849c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84a0:	2b00      	cmp	r3, #0
    84a2:	d10d      	bne.n	84c0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    84a4:	f7f8 faa1 	bl	9ea <Gpt_schm_read_msr>
    84a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    84aa:	9b00      	ldr	r3, [sp, #0]
    84ac:	f003 0301 	and.w	r3, r3, #1
    84b0:	2b00      	cmp	r3, #0
    84b2:	d100      	bne.n	84b6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    84b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
    84b6:	490a      	ldr	r1, [pc, #40]	; (84e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x54>)
    84b8:	9b01      	ldr	r3, [sp, #4]
    84ba:	9a00      	ldr	r2, [sp, #0]
    84bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId]++;
    84c0:	4a06      	ldr	r2, [pc, #24]	; (84dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x50>)
    84c2:	9b01      	ldr	r3, [sp, #4]
    84c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84c8:	1c5a      	adds	r2, r3, #1
    84ca:	4904      	ldr	r1, [pc, #16]	; (84dc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_07+0x50>)
    84cc:	9b01      	ldr	r3, [sp, #4]
    84ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    84d2:	bf00      	nop
    84d4:	b003      	add	sp, #12
    84d6:	f85d fb04 	ldr.w	pc, [sp], #4
    84da:	bf00      	nop
    84dc:	1fff8ed8 	.word	0x1fff8ed8
    84e0:	1fff8ed4 	.word	0x1fff8ed4

000084e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07(void)
{
    84e4:	b500      	push	{lr}
    84e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    84e8:	f7f8 fb60 	bl	bac <Sys_GetCoreID>
    84ec:	4603      	mov	r3, r0
    84ee:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId]--;
    84f0:	4a0d      	ldr	r2, [pc, #52]	; (8528 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x44>)
    84f2:	9b01      	ldr	r3, [sp, #4]
    84f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84f8:	1e5a      	subs	r2, r3, #1
    84fa:	490b      	ldr	r1, [pc, #44]	; (8528 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x44>)
    84fc:	9b01      	ldr	r3, [sp, #4]
    84fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
    8502:	4a0a      	ldr	r2, [pc, #40]	; (852c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x48>)
    8504:	9b01      	ldr	r3, [sp, #4]
    8506:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    850a:	f003 0301 	and.w	r3, r3, #1
    850e:	2b00      	cmp	r3, #0
    8510:	d106      	bne.n	8520 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x3c>
    8512:	4a05      	ldr	r2, [pc, #20]	; (8528 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x44>)
    8514:	9b01      	ldr	r3, [sp, #4]
    8516:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    851a:	2b00      	cmp	r3, #0
    851c:	d100      	bne.n	8520 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    851e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8520:	bf00      	nop
    8522:	b003      	add	sp, #12
    8524:	f85d fb04 	ldr.w	pc, [sp], #4
    8528:	1fff8ed8 	.word	0x1fff8ed8
    852c:	1fff8ed4 	.word	0x1fff8ed4

00008530 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10(void)
{
    8530:	b500      	push	{lr}
    8532:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8534:	f7f8 fb3a 	bl	bac <Sys_GetCoreID>
    8538:	4603      	mov	r3, r0
    853a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId])
    853c:	4a10      	ldr	r2, [pc, #64]	; (8580 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x50>)
    853e:	9b01      	ldr	r3, [sp, #4]
    8540:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8544:	2b00      	cmp	r3, #0
    8546:	d10d      	bne.n	8564 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8548:	f7f8 fa4f 	bl	9ea <Gpt_schm_read_msr>
    854c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    854e:	9b00      	ldr	r3, [sp, #0]
    8550:	f003 0301 	and.w	r3, r3, #1
    8554:	2b00      	cmp	r3, #0
    8556:	d100      	bne.n	855a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8558:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    855a:	490a      	ldr	r1, [pc, #40]	; (8584 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x54>)
    855c:	9b01      	ldr	r3, [sp, #4]
    855e:	9a00      	ldr	r2, [sp, #0]
    8560:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId]++;
    8564:	4a06      	ldr	r2, [pc, #24]	; (8580 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x50>)
    8566:	9b01      	ldr	r3, [sp, #4]
    8568:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    856c:	1c5a      	adds	r2, r3, #1
    856e:	4904      	ldr	r1, [pc, #16]	; (8580 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_10+0x50>)
    8570:	9b01      	ldr	r3, [sp, #4]
    8572:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8576:	bf00      	nop
    8578:	b003      	add	sp, #12
    857a:	f85d fb04 	ldr.w	pc, [sp], #4
    857e:	bf00      	nop
    8580:	1fff8ee0 	.word	0x1fff8ee0
    8584:	1fff8edc 	.word	0x1fff8edc

00008588 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10(void)
{
    8588:	b500      	push	{lr}
    858a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    858c:	f7f8 fb0e 	bl	bac <Sys_GetCoreID>
    8590:	4603      	mov	r3, r0
    8592:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId]--;
    8594:	4a0d      	ldr	r2, [pc, #52]	; (85cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x44>)
    8596:	9b01      	ldr	r3, [sp, #4]
    8598:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    859c:	1e5a      	subs	r2, r3, #1
    859e:	490b      	ldr	r1, [pc, #44]	; (85cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x44>)
    85a0:	9b01      	ldr	r3, [sp, #4]
    85a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    85a6:	4a0a      	ldr	r2, [pc, #40]	; (85d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x48>)
    85a8:	9b01      	ldr	r3, [sp, #4]
    85aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85ae:	f003 0301 	and.w	r3, r3, #1
    85b2:	2b00      	cmp	r3, #0
    85b4:	d106      	bne.n	85c4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x3c>
    85b6:	4a05      	ldr	r2, [pc, #20]	; (85cc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x44>)
    85b8:	9b01      	ldr	r3, [sp, #4]
    85ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85be:	2b00      	cmp	r3, #0
    85c0:	d100      	bne.n	85c4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    85c2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    85c4:	bf00      	nop
    85c6:	b003      	add	sp, #12
    85c8:	f85d fb04 	ldr.w	pc, [sp], #4
    85cc:	1fff8ee0 	.word	0x1fff8ee0
    85d0:	1fff8edc 	.word	0x1fff8edc

000085d4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11(void)
{
    85d4:	b500      	push	{lr}
    85d6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    85d8:	f7f8 fae8 	bl	bac <Sys_GetCoreID>
    85dc:	4603      	mov	r3, r0
    85de:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId])
    85e0:	4a10      	ldr	r2, [pc, #64]	; (8624 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x50>)
    85e2:	9b01      	ldr	r3, [sp, #4]
    85e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85e8:	2b00      	cmp	r3, #0
    85ea:	d10d      	bne.n	8608 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    85ec:	f7f8 f9fd 	bl	9ea <Gpt_schm_read_msr>
    85f0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    85f2:	9b00      	ldr	r3, [sp, #0]
    85f4:	f003 0301 	and.w	r3, r3, #1
    85f8:	2b00      	cmp	r3, #0
    85fa:	d100      	bne.n	85fe <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    85fc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    85fe:	490a      	ldr	r1, [pc, #40]	; (8628 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x54>)
    8600:	9b01      	ldr	r3, [sp, #4]
    8602:	9a00      	ldr	r2, [sp, #0]
    8604:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId]++;
    8608:	4a06      	ldr	r2, [pc, #24]	; (8624 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x50>)
    860a:	9b01      	ldr	r3, [sp, #4]
    860c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8610:	1c5a      	adds	r2, r3, #1
    8612:	4904      	ldr	r1, [pc, #16]	; (8624 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_11+0x50>)
    8614:	9b01      	ldr	r3, [sp, #4]
    8616:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    861a:	bf00      	nop
    861c:	b003      	add	sp, #12
    861e:	f85d fb04 	ldr.w	pc, [sp], #4
    8622:	bf00      	nop
    8624:	1fff8ee8 	.word	0x1fff8ee8
    8628:	1fff8ee4 	.word	0x1fff8ee4

0000862c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11(void)
{
    862c:	b500      	push	{lr}
    862e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8630:	f7f8 fabc 	bl	bac <Sys_GetCoreID>
    8634:	4603      	mov	r3, r0
    8636:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId]--;
    8638:	4a0d      	ldr	r2, [pc, #52]	; (8670 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x44>)
    863a:	9b01      	ldr	r3, [sp, #4]
    863c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8640:	1e5a      	subs	r2, r3, #1
    8642:	490b      	ldr	r1, [pc, #44]	; (8670 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x44>)
    8644:	9b01      	ldr	r3, [sp, #4]
    8646:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    864a:	4a0a      	ldr	r2, [pc, #40]	; (8674 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x48>)
    864c:	9b01      	ldr	r3, [sp, #4]
    864e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8652:	f003 0301 	and.w	r3, r3, #1
    8656:	2b00      	cmp	r3, #0
    8658:	d106      	bne.n	8668 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x3c>
    865a:	4a05      	ldr	r2, [pc, #20]	; (8670 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x44>)
    865c:	9b01      	ldr	r3, [sp, #4]
    865e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8662:	2b00      	cmp	r3, #0
    8664:	d100      	bne.n	8668 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8666:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8668:	bf00      	nop
    866a:	b003      	add	sp, #12
    866c:	f85d fb04 	ldr.w	pc, [sp], #4
    8670:	1fff8ee8 	.word	0x1fff8ee8
    8674:	1fff8ee4 	.word	0x1fff8ee4

00008678 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17(void)
{
    8678:	b500      	push	{lr}
    867a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    867c:	f7f8 fa96 	bl	bac <Sys_GetCoreID>
    8680:	4603      	mov	r3, r0
    8682:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId])
    8684:	4a10      	ldr	r2, [pc, #64]	; (86c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x50>)
    8686:	9b01      	ldr	r3, [sp, #4]
    8688:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    868c:	2b00      	cmp	r3, #0
    868e:	d10d      	bne.n	86ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8690:	f7f8 f9ab 	bl	9ea <Gpt_schm_read_msr>
    8694:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8696:	9b00      	ldr	r3, [sp, #0]
    8698:	f003 0301 	and.w	r3, r3, #1
    869c:	2b00      	cmp	r3, #0
    869e:	d100      	bne.n	86a2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    86a0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    86a2:	490a      	ldr	r1, [pc, #40]	; (86cc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x54>)
    86a4:	9b01      	ldr	r3, [sp, #4]
    86a6:	9a00      	ldr	r2, [sp, #0]
    86a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId]++;
    86ac:	4a06      	ldr	r2, [pc, #24]	; (86c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x50>)
    86ae:	9b01      	ldr	r3, [sp, #4]
    86b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86b4:	1c5a      	adds	r2, r3, #1
    86b6:	4904      	ldr	r1, [pc, #16]	; (86c8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_17+0x50>)
    86b8:	9b01      	ldr	r3, [sp, #4]
    86ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    86be:	bf00      	nop
    86c0:	b003      	add	sp, #12
    86c2:	f85d fb04 	ldr.w	pc, [sp], #4
    86c6:	bf00      	nop
    86c8:	1fff8ef0 	.word	0x1fff8ef0
    86cc:	1fff8eec 	.word	0x1fff8eec

000086d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17(void)
{
    86d0:	b500      	push	{lr}
    86d2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    86d4:	f7f8 fa6a 	bl	bac <Sys_GetCoreID>
    86d8:	4603      	mov	r3, r0
    86da:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId]--;
    86dc:	4a0d      	ldr	r2, [pc, #52]	; (8714 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x44>)
    86de:	9b01      	ldr	r3, [sp, #4]
    86e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86e4:	1e5a      	subs	r2, r3, #1
    86e6:	490b      	ldr	r1, [pc, #44]	; (8714 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x44>)
    86e8:	9b01      	ldr	r3, [sp, #4]
    86ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    86ee:	4a0a      	ldr	r2, [pc, #40]	; (8718 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x48>)
    86f0:	9b01      	ldr	r3, [sp, #4]
    86f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86f6:	f003 0301 	and.w	r3, r3, #1
    86fa:	2b00      	cmp	r3, #0
    86fc:	d106      	bne.n	870c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x3c>
    86fe:	4a05      	ldr	r2, [pc, #20]	; (8714 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x44>)
    8700:	9b01      	ldr	r3, [sp, #4]
    8702:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8706:	2b00      	cmp	r3, #0
    8708:	d100      	bne.n	870c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    870a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    870c:	bf00      	nop
    870e:	b003      	add	sp, #12
    8710:	f85d fb04 	ldr.w	pc, [sp], #4
    8714:	1fff8ef0 	.word	0x1fff8ef0
    8718:	1fff8eec 	.word	0x1fff8eec

0000871c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21(void)
{
    871c:	b500      	push	{lr}
    871e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8720:	f7f8 fa44 	bl	bac <Sys_GetCoreID>
    8724:	4603      	mov	r3, r0
    8726:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId])
    8728:	4a10      	ldr	r2, [pc, #64]	; (876c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x50>)
    872a:	9b01      	ldr	r3, [sp, #4]
    872c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8730:	2b00      	cmp	r3, #0
    8732:	d10d      	bne.n	8750 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8734:	f7f8 f959 	bl	9ea <Gpt_schm_read_msr>
    8738:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    873a:	9b00      	ldr	r3, [sp, #0]
    873c:	f003 0301 	and.w	r3, r3, #1
    8740:	2b00      	cmp	r3, #0
    8742:	d100      	bne.n	8746 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8744:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    8746:	490a      	ldr	r1, [pc, #40]	; (8770 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x54>)
    8748:	9b01      	ldr	r3, [sp, #4]
    874a:	9a00      	ldr	r2, [sp, #0]
    874c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId]++;
    8750:	4a06      	ldr	r2, [pc, #24]	; (876c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x50>)
    8752:	9b01      	ldr	r3, [sp, #4]
    8754:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8758:	1c5a      	adds	r2, r3, #1
    875a:	4904      	ldr	r1, [pc, #16]	; (876c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_21+0x50>)
    875c:	9b01      	ldr	r3, [sp, #4]
    875e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8762:	bf00      	nop
    8764:	b003      	add	sp, #12
    8766:	f85d fb04 	ldr.w	pc, [sp], #4
    876a:	bf00      	nop
    876c:	1fff8ef8 	.word	0x1fff8ef8
    8770:	1fff8ef4 	.word	0x1fff8ef4

00008774 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21(void)
{
    8774:	b500      	push	{lr}
    8776:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8778:	f7f8 fa18 	bl	bac <Sys_GetCoreID>
    877c:	4603      	mov	r3, r0
    877e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId]--;
    8780:	4a0d      	ldr	r2, [pc, #52]	; (87b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x44>)
    8782:	9b01      	ldr	r3, [sp, #4]
    8784:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8788:	1e5a      	subs	r2, r3, #1
    878a:	490b      	ldr	r1, [pc, #44]	; (87b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x44>)
    878c:	9b01      	ldr	r3, [sp, #4]
    878e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    8792:	4a0a      	ldr	r2, [pc, #40]	; (87bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x48>)
    8794:	9b01      	ldr	r3, [sp, #4]
    8796:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    879a:	f003 0301 	and.w	r3, r3, #1
    879e:	2b00      	cmp	r3, #0
    87a0:	d106      	bne.n	87b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x3c>
    87a2:	4a05      	ldr	r2, [pc, #20]	; (87b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x44>)
    87a4:	9b01      	ldr	r3, [sp, #4]
    87a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87aa:	2b00      	cmp	r3, #0
    87ac:	d100      	bne.n	87b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    87ae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    87b0:	bf00      	nop
    87b2:	b003      	add	sp, #12
    87b4:	f85d fb04 	ldr.w	pc, [sp], #4
    87b8:	1fff8ef8 	.word	0x1fff8ef8
    87bc:	1fff8ef4 	.word	0x1fff8ef4

000087c0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22(void)
{
    87c0:	b500      	push	{lr}
    87c2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    87c4:	f7f8 f9f2 	bl	bac <Sys_GetCoreID>
    87c8:	4603      	mov	r3, r0
    87ca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId])
    87cc:	4a10      	ldr	r2, [pc, #64]	; (8810 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x50>)
    87ce:	9b01      	ldr	r3, [sp, #4]
    87d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87d4:	2b00      	cmp	r3, #0
    87d6:	d10d      	bne.n	87f4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    87d8:	f7f8 f907 	bl	9ea <Gpt_schm_read_msr>
    87dc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    87de:	9b00      	ldr	r3, [sp, #0]
    87e0:	f003 0301 	and.w	r3, r3, #1
    87e4:	2b00      	cmp	r3, #0
    87e6:	d100      	bne.n	87ea <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    87e8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    87ea:	490a      	ldr	r1, [pc, #40]	; (8814 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x54>)
    87ec:	9b01      	ldr	r3, [sp, #4]
    87ee:	9a00      	ldr	r2, [sp, #0]
    87f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId]++;
    87f4:	4a06      	ldr	r2, [pc, #24]	; (8810 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x50>)
    87f6:	9b01      	ldr	r3, [sp, #4]
    87f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    87fc:	1c5a      	adds	r2, r3, #1
    87fe:	4904      	ldr	r1, [pc, #16]	; (8810 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_22+0x50>)
    8800:	9b01      	ldr	r3, [sp, #4]
    8802:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8806:	bf00      	nop
    8808:	b003      	add	sp, #12
    880a:	f85d fb04 	ldr.w	pc, [sp], #4
    880e:	bf00      	nop
    8810:	1fff8f00 	.word	0x1fff8f00
    8814:	1fff8efc 	.word	0x1fff8efc

00008818 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22(void)
{
    8818:	b500      	push	{lr}
    881a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    881c:	f7f8 f9c6 	bl	bac <Sys_GetCoreID>
    8820:	4603      	mov	r3, r0
    8822:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId]--;
    8824:	4a0d      	ldr	r2, [pc, #52]	; (885c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x44>)
    8826:	9b01      	ldr	r3, [sp, #4]
    8828:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    882c:	1e5a      	subs	r2, r3, #1
    882e:	490b      	ldr	r1, [pc, #44]	; (885c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x44>)
    8830:	9b01      	ldr	r3, [sp, #4]
    8832:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    8836:	4a0a      	ldr	r2, [pc, #40]	; (8860 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x48>)
    8838:	9b01      	ldr	r3, [sp, #4]
    883a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    883e:	f003 0301 	and.w	r3, r3, #1
    8842:	2b00      	cmp	r3, #0
    8844:	d106      	bne.n	8854 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x3c>
    8846:	4a05      	ldr	r2, [pc, #20]	; (885c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x44>)
    8848:	9b01      	ldr	r3, [sp, #4]
    884a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    884e:	2b00      	cmp	r3, #0
    8850:	d100      	bne.n	8854 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8852:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8854:	bf00      	nop
    8856:	b003      	add	sp, #12
    8858:	f85d fb04 	ldr.w	pc, [sp], #4
    885c:	1fff8f00 	.word	0x1fff8f00
    8860:	1fff8efc 	.word	0x1fff8efc

00008864 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23(void)
{
    8864:	b500      	push	{lr}
    8866:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8868:	f7f8 f9a0 	bl	bac <Sys_GetCoreID>
    886c:	4603      	mov	r3, r0
    886e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId])
    8870:	4a10      	ldr	r2, [pc, #64]	; (88b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x50>)
    8872:	9b01      	ldr	r3, [sp, #4]
    8874:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8878:	2b00      	cmp	r3, #0
    887a:	d10d      	bne.n	8898 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    887c:	f7f8 f8b5 	bl	9ea <Gpt_schm_read_msr>
    8880:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8882:	9b00      	ldr	r3, [sp, #0]
    8884:	f003 0301 	and.w	r3, r3, #1
    8888:	2b00      	cmp	r3, #0
    888a:	d100      	bne.n	888e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    888c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    888e:	490a      	ldr	r1, [pc, #40]	; (88b8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x54>)
    8890:	9b01      	ldr	r3, [sp, #4]
    8892:	9a00      	ldr	r2, [sp, #0]
    8894:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId]++;
    8898:	4a06      	ldr	r2, [pc, #24]	; (88b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x50>)
    889a:	9b01      	ldr	r3, [sp, #4]
    889c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88a0:	1c5a      	adds	r2, r3, #1
    88a2:	4904      	ldr	r1, [pc, #16]	; (88b4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_23+0x50>)
    88a4:	9b01      	ldr	r3, [sp, #4]
    88a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    88aa:	bf00      	nop
    88ac:	b003      	add	sp, #12
    88ae:	f85d fb04 	ldr.w	pc, [sp], #4
    88b2:	bf00      	nop
    88b4:	1fff8f08 	.word	0x1fff8f08
    88b8:	1fff8f04 	.word	0x1fff8f04

000088bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23(void)
{
    88bc:	b500      	push	{lr}
    88be:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    88c0:	f7f8 f974 	bl	bac <Sys_GetCoreID>
    88c4:	4603      	mov	r3, r0
    88c6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId]--;
    88c8:	4a0d      	ldr	r2, [pc, #52]	; (8900 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x44>)
    88ca:	9b01      	ldr	r3, [sp, #4]
    88cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88d0:	1e5a      	subs	r2, r3, #1
    88d2:	490b      	ldr	r1, [pc, #44]	; (8900 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x44>)
    88d4:	9b01      	ldr	r3, [sp, #4]
    88d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    88da:	4a0a      	ldr	r2, [pc, #40]	; (8904 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x48>)
    88dc:	9b01      	ldr	r3, [sp, #4]
    88de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88e2:	f003 0301 	and.w	r3, r3, #1
    88e6:	2b00      	cmp	r3, #0
    88e8:	d106      	bne.n	88f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x3c>
    88ea:	4a05      	ldr	r2, [pc, #20]	; (8900 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x44>)
    88ec:	9b01      	ldr	r3, [sp, #4]
    88ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88f2:	2b00      	cmp	r3, #0
    88f4:	d100      	bne.n	88f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    88f6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    88f8:	bf00      	nop
    88fa:	b003      	add	sp, #12
    88fc:	f85d fb04 	ldr.w	pc, [sp], #4
    8900:	1fff8f08 	.word	0x1fff8f08
    8904:	1fff8f04 	.word	0x1fff8f04

00008908 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24(void)
{
    8908:	b500      	push	{lr}
    890a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    890c:	f7f8 f94e 	bl	bac <Sys_GetCoreID>
    8910:	4603      	mov	r3, r0
    8912:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId])
    8914:	4a10      	ldr	r2, [pc, #64]	; (8958 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x50>)
    8916:	9b01      	ldr	r3, [sp, #4]
    8918:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    891c:	2b00      	cmp	r3, #0
    891e:	d10d      	bne.n	893c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8920:	f7f8 f863 	bl	9ea <Gpt_schm_read_msr>
    8924:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8926:	9b00      	ldr	r3, [sp, #0]
    8928:	f003 0301 	and.w	r3, r3, #1
    892c:	2b00      	cmp	r3, #0
    892e:	d100      	bne.n	8932 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8930:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    8932:	490a      	ldr	r1, [pc, #40]	; (895c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x54>)
    8934:	9b01      	ldr	r3, [sp, #4]
    8936:	9a00      	ldr	r2, [sp, #0]
    8938:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId]++;
    893c:	4a06      	ldr	r2, [pc, #24]	; (8958 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x50>)
    893e:	9b01      	ldr	r3, [sp, #4]
    8940:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8944:	1c5a      	adds	r2, r3, #1
    8946:	4904      	ldr	r1, [pc, #16]	; (8958 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_24+0x50>)
    8948:	9b01      	ldr	r3, [sp, #4]
    894a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    894e:	bf00      	nop
    8950:	b003      	add	sp, #12
    8952:	f85d fb04 	ldr.w	pc, [sp], #4
    8956:	bf00      	nop
    8958:	1fff8f10 	.word	0x1fff8f10
    895c:	1fff8f0c 	.word	0x1fff8f0c

00008960 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24(void)
{
    8960:	b500      	push	{lr}
    8962:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8964:	f7f8 f922 	bl	bac <Sys_GetCoreID>
    8968:	4603      	mov	r3, r0
    896a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId]--;
    896c:	4a0d      	ldr	r2, [pc, #52]	; (89a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x44>)
    896e:	9b01      	ldr	r3, [sp, #4]
    8970:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8974:	1e5a      	subs	r2, r3, #1
    8976:	490b      	ldr	r1, [pc, #44]	; (89a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x44>)
    8978:	9b01      	ldr	r3, [sp, #4]
    897a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    897e:	4a0a      	ldr	r2, [pc, #40]	; (89a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x48>)
    8980:	9b01      	ldr	r3, [sp, #4]
    8982:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8986:	f003 0301 	and.w	r3, r3, #1
    898a:	2b00      	cmp	r3, #0
    898c:	d106      	bne.n	899c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x3c>
    898e:	4a05      	ldr	r2, [pc, #20]	; (89a4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x44>)
    8990:	9b01      	ldr	r3, [sp, #4]
    8992:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8996:	2b00      	cmp	r3, #0
    8998:	d100      	bne.n	899c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    899a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    899c:	bf00      	nop
    899e:	b003      	add	sp, #12
    89a0:	f85d fb04 	ldr.w	pc, [sp], #4
    89a4:	1fff8f10 	.word	0x1fff8f10
    89a8:	1fff8f0c 	.word	0x1fff8f0c

000089ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25(void)
{
    89ac:	b500      	push	{lr}
    89ae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    89b0:	f7f8 f8fc 	bl	bac <Sys_GetCoreID>
    89b4:	4603      	mov	r3, r0
    89b6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId])
    89b8:	4a10      	ldr	r2, [pc, #64]	; (89fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x50>)
    89ba:	9b01      	ldr	r3, [sp, #4]
    89bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89c0:	2b00      	cmp	r3, #0
    89c2:	d10d      	bne.n	89e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    89c4:	f7f8 f811 	bl	9ea <Gpt_schm_read_msr>
    89c8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    89ca:	9b00      	ldr	r3, [sp, #0]
    89cc:	f003 0301 	and.w	r3, r3, #1
    89d0:	2b00      	cmp	r3, #0
    89d2:	d100      	bne.n	89d6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    89d4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    89d6:	490a      	ldr	r1, [pc, #40]	; (8a00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x54>)
    89d8:	9b01      	ldr	r3, [sp, #4]
    89da:	9a00      	ldr	r2, [sp, #0]
    89dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId]++;
    89e0:	4a06      	ldr	r2, [pc, #24]	; (89fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x50>)
    89e2:	9b01      	ldr	r3, [sp, #4]
    89e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89e8:	1c5a      	adds	r2, r3, #1
    89ea:	4904      	ldr	r1, [pc, #16]	; (89fc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_25+0x50>)
    89ec:	9b01      	ldr	r3, [sp, #4]
    89ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    89f2:	bf00      	nop
    89f4:	b003      	add	sp, #12
    89f6:	f85d fb04 	ldr.w	pc, [sp], #4
    89fa:	bf00      	nop
    89fc:	1fff8f18 	.word	0x1fff8f18
    8a00:	1fff8f14 	.word	0x1fff8f14

00008a04 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25(void)
{
    8a04:	b500      	push	{lr}
    8a06:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a08:	f7f8 f8d0 	bl	bac <Sys_GetCoreID>
    8a0c:	4603      	mov	r3, r0
    8a0e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId]--;
    8a10:	4a0d      	ldr	r2, [pc, #52]	; (8a48 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x44>)
    8a12:	9b01      	ldr	r3, [sp, #4]
    8a14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a18:	1e5a      	subs	r2, r3, #1
    8a1a:	490b      	ldr	r1, [pc, #44]	; (8a48 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x44>)
    8a1c:	9b01      	ldr	r3, [sp, #4]
    8a1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    8a22:	4a0a      	ldr	r2, [pc, #40]	; (8a4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x48>)
    8a24:	9b01      	ldr	r3, [sp, #4]
    8a26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a2a:	f003 0301 	and.w	r3, r3, #1
    8a2e:	2b00      	cmp	r3, #0
    8a30:	d106      	bne.n	8a40 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x3c>
    8a32:	4a05      	ldr	r2, [pc, #20]	; (8a48 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x44>)
    8a34:	9b01      	ldr	r3, [sp, #4]
    8a36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a3a:	2b00      	cmp	r3, #0
    8a3c:	d100      	bne.n	8a40 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8a3e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8a40:	bf00      	nop
    8a42:	b003      	add	sp, #12
    8a44:	f85d fb04 	ldr.w	pc, [sp], #4
    8a48:	1fff8f18 	.word	0x1fff8f18
    8a4c:	1fff8f14 	.word	0x1fff8f14

00008a50 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26(void)
{
    8a50:	b500      	push	{lr}
    8a52:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8a54:	f7f8 f8aa 	bl	bac <Sys_GetCoreID>
    8a58:	4603      	mov	r3, r0
    8a5a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId])
    8a5c:	4a10      	ldr	r2, [pc, #64]	; (8aa0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x50>)
    8a5e:	9b01      	ldr	r3, [sp, #4]
    8a60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a64:	2b00      	cmp	r3, #0
    8a66:	d10d      	bne.n	8a84 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8a68:	f7f7 ffbf 	bl	9ea <Gpt_schm_read_msr>
    8a6c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8a6e:	9b00      	ldr	r3, [sp, #0]
    8a70:	f003 0301 	and.w	r3, r3, #1
    8a74:	2b00      	cmp	r3, #0
    8a76:	d100      	bne.n	8a7a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8a78:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    8a7a:	490a      	ldr	r1, [pc, #40]	; (8aa4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x54>)
    8a7c:	9b01      	ldr	r3, [sp, #4]
    8a7e:	9a00      	ldr	r2, [sp, #0]
    8a80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId]++;
    8a84:	4a06      	ldr	r2, [pc, #24]	; (8aa0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x50>)
    8a86:	9b01      	ldr	r3, [sp, #4]
    8a88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a8c:	1c5a      	adds	r2, r3, #1
    8a8e:	4904      	ldr	r1, [pc, #16]	; (8aa0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_26+0x50>)
    8a90:	9b01      	ldr	r3, [sp, #4]
    8a92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8a96:	bf00      	nop
    8a98:	b003      	add	sp, #12
    8a9a:	f85d fb04 	ldr.w	pc, [sp], #4
    8a9e:	bf00      	nop
    8aa0:	1fff8f20 	.word	0x1fff8f20
    8aa4:	1fff8f1c 	.word	0x1fff8f1c

00008aa8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26(void)
{
    8aa8:	b500      	push	{lr}
    8aaa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8aac:	f7f8 f87e 	bl	bac <Sys_GetCoreID>
    8ab0:	4603      	mov	r3, r0
    8ab2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId]--;
    8ab4:	4a0d      	ldr	r2, [pc, #52]	; (8aec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x44>)
    8ab6:	9b01      	ldr	r3, [sp, #4]
    8ab8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8abc:	1e5a      	subs	r2, r3, #1
    8abe:	490b      	ldr	r1, [pc, #44]	; (8aec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x44>)
    8ac0:	9b01      	ldr	r3, [sp, #4]
    8ac2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    8ac6:	4a0a      	ldr	r2, [pc, #40]	; (8af0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x48>)
    8ac8:	9b01      	ldr	r3, [sp, #4]
    8aca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ace:	f003 0301 	and.w	r3, r3, #1
    8ad2:	2b00      	cmp	r3, #0
    8ad4:	d106      	bne.n	8ae4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x3c>
    8ad6:	4a05      	ldr	r2, [pc, #20]	; (8aec <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x44>)
    8ad8:	9b01      	ldr	r3, [sp, #4]
    8ada:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ade:	2b00      	cmp	r3, #0
    8ae0:	d100      	bne.n	8ae4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8ae2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8ae4:	bf00      	nop
    8ae6:	b003      	add	sp, #12
    8ae8:	f85d fb04 	ldr.w	pc, [sp], #4
    8aec:	1fff8f20 	.word	0x1fff8f20
    8af0:	1fff8f1c 	.word	0x1fff8f1c

00008af4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29(void)
{
    8af4:	b500      	push	{lr}
    8af6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8af8:	f7f8 f858 	bl	bac <Sys_GetCoreID>
    8afc:	4603      	mov	r3, r0
    8afe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId])
    8b00:	4a10      	ldr	r2, [pc, #64]	; (8b44 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x50>)
    8b02:	9b01      	ldr	r3, [sp, #4]
    8b04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b08:	2b00      	cmp	r3, #0
    8b0a:	d10d      	bne.n	8b28 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8b0c:	f7f7 ff6d 	bl	9ea <Gpt_schm_read_msr>
    8b10:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8b12:	9b00      	ldr	r3, [sp, #0]
    8b14:	f003 0301 	and.w	r3, r3, #1
    8b18:	2b00      	cmp	r3, #0
    8b1a:	d100      	bne.n	8b1e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8b1c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_29[u32CoreId] = msr;
    8b1e:	490a      	ldr	r1, [pc, #40]	; (8b48 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x54>)
    8b20:	9b01      	ldr	r3, [sp, #4]
    8b22:	9a00      	ldr	r2, [sp, #0]
    8b24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId]++;
    8b28:	4a06      	ldr	r2, [pc, #24]	; (8b44 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x50>)
    8b2a:	9b01      	ldr	r3, [sp, #4]
    8b2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b30:	1c5a      	adds	r2, r3, #1
    8b32:	4904      	ldr	r1, [pc, #16]	; (8b44 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_29+0x50>)
    8b34:	9b01      	ldr	r3, [sp, #4]
    8b36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8b3a:	bf00      	nop
    8b3c:	b003      	add	sp, #12
    8b3e:	f85d fb04 	ldr.w	pc, [sp], #4
    8b42:	bf00      	nop
    8b44:	1fff8f28 	.word	0x1fff8f28
    8b48:	1fff8f24 	.word	0x1fff8f24

00008b4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29(void)
{
    8b4c:	b500      	push	{lr}
    8b4e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b50:	f7f8 f82c 	bl	bac <Sys_GetCoreID>
    8b54:	4603      	mov	r3, r0
    8b56:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId]--;
    8b58:	4a0d      	ldr	r2, [pc, #52]	; (8b90 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x44>)
    8b5a:	9b01      	ldr	r3, [sp, #4]
    8b5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b60:	1e5a      	subs	r2, r3, #1
    8b62:	490b      	ldr	r1, [pc, #44]	; (8b90 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x44>)
    8b64:	9b01      	ldr	r3, [sp, #4]
    8b66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_29[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_29[u32CoreId]))         /*if interrupts were enabled*/
    8b6a:	4a0a      	ldr	r2, [pc, #40]	; (8b94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x48>)
    8b6c:	9b01      	ldr	r3, [sp, #4]
    8b6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b72:	f003 0301 	and.w	r3, r3, #1
    8b76:	2b00      	cmp	r3, #0
    8b78:	d106      	bne.n	8b88 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x3c>
    8b7a:	4a05      	ldr	r2, [pc, #20]	; (8b90 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x44>)
    8b7c:	9b01      	ldr	r3, [sp, #4]
    8b7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b82:	2b00      	cmp	r3, #0
    8b84:	d100      	bne.n	8b88 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_29+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8b86:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8b88:	bf00      	nop
    8b8a:	b003      	add	sp, #12
    8b8c:	f85d fb04 	ldr.w	pc, [sp], #4
    8b90:	1fff8f28 	.word	0x1fff8f28
    8b94:	1fff8f24 	.word	0x1fff8f24

00008b98 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30(void)
{
    8b98:	b500      	push	{lr}
    8b9a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8b9c:	f7f8 f806 	bl	bac <Sys_GetCoreID>
    8ba0:	4603      	mov	r3, r0
    8ba2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId])
    8ba4:	4a10      	ldr	r2, [pc, #64]	; (8be8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x50>)
    8ba6:	9b01      	ldr	r3, [sp, #4]
    8ba8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bac:	2b00      	cmp	r3, #0
    8bae:	d10d      	bne.n	8bcc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8bb0:	f7f7 ff1b 	bl	9ea <Gpt_schm_read_msr>
    8bb4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8bb6:	9b00      	ldr	r3, [sp, #0]
    8bb8:	f003 0301 	and.w	r3, r3, #1
    8bbc:	2b00      	cmp	r3, #0
    8bbe:	d100      	bne.n	8bc2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8bc0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_30[u32CoreId] = msr;
    8bc2:	490a      	ldr	r1, [pc, #40]	; (8bec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x54>)
    8bc4:	9b01      	ldr	r3, [sp, #4]
    8bc6:	9a00      	ldr	r2, [sp, #0]
    8bc8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId]++;
    8bcc:	4a06      	ldr	r2, [pc, #24]	; (8be8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x50>)
    8bce:	9b01      	ldr	r3, [sp, #4]
    8bd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8bd4:	1c5a      	adds	r2, r3, #1
    8bd6:	4904      	ldr	r1, [pc, #16]	; (8be8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_30+0x50>)
    8bd8:	9b01      	ldr	r3, [sp, #4]
    8bda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8bde:	bf00      	nop
    8be0:	b003      	add	sp, #12
    8be2:	f85d fb04 	ldr.w	pc, [sp], #4
    8be6:	bf00      	nop
    8be8:	1fff8f30 	.word	0x1fff8f30
    8bec:	1fff8f2c 	.word	0x1fff8f2c

00008bf0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30(void)
{
    8bf0:	b500      	push	{lr}
    8bf2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8bf4:	f7f7 ffda 	bl	bac <Sys_GetCoreID>
    8bf8:	4603      	mov	r3, r0
    8bfa:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId]--;
    8bfc:	4a0d      	ldr	r2, [pc, #52]	; (8c34 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x44>)
    8bfe:	9b01      	ldr	r3, [sp, #4]
    8c00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c04:	1e5a      	subs	r2, r3, #1
    8c06:	490b      	ldr	r1, [pc, #44]	; (8c34 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x44>)
    8c08:	9b01      	ldr	r3, [sp, #4]
    8c0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_30[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_30[u32CoreId]))         /*if interrupts were enabled*/
    8c0e:	4a0a      	ldr	r2, [pc, #40]	; (8c38 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x48>)
    8c10:	9b01      	ldr	r3, [sp, #4]
    8c12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c16:	f003 0301 	and.w	r3, r3, #1
    8c1a:	2b00      	cmp	r3, #0
    8c1c:	d106      	bne.n	8c2c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x3c>
    8c1e:	4a05      	ldr	r2, [pc, #20]	; (8c34 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x44>)
    8c20:	9b01      	ldr	r3, [sp, #4]
    8c22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c26:	2b00      	cmp	r3, #0
    8c28:	d100      	bne.n	8c2c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_30+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8c2a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8c2c:	bf00      	nop
    8c2e:	b003      	add	sp, #12
    8c30:	f85d fb04 	ldr.w	pc, [sp], #4
    8c34:	1fff8f30 	.word	0x1fff8f30
    8c38:	1fff8f2c 	.word	0x1fff8f2c

00008c3c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31(void)
{
    8c3c:	b500      	push	{lr}
    8c3e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c40:	f7f7 ffb4 	bl	bac <Sys_GetCoreID>
    8c44:	4603      	mov	r3, r0
    8c46:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId])
    8c48:	4a10      	ldr	r2, [pc, #64]	; (8c8c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x50>)
    8c4a:	9b01      	ldr	r3, [sp, #4]
    8c4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c50:	2b00      	cmp	r3, #0
    8c52:	d10d      	bne.n	8c70 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8c54:	f7f7 fec9 	bl	9ea <Gpt_schm_read_msr>
    8c58:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8c5a:	9b00      	ldr	r3, [sp, #0]
    8c5c:	f003 0301 	and.w	r3, r3, #1
    8c60:	2b00      	cmp	r3, #0
    8c62:	d100      	bne.n	8c66 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8c64:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_31[u32CoreId] = msr;
    8c66:	490a      	ldr	r1, [pc, #40]	; (8c90 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x54>)
    8c68:	9b01      	ldr	r3, [sp, #4]
    8c6a:	9a00      	ldr	r2, [sp, #0]
    8c6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId]++;
    8c70:	4a06      	ldr	r2, [pc, #24]	; (8c8c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x50>)
    8c72:	9b01      	ldr	r3, [sp, #4]
    8c74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c78:	1c5a      	adds	r2, r3, #1
    8c7a:	4904      	ldr	r1, [pc, #16]	; (8c8c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_31+0x50>)
    8c7c:	9b01      	ldr	r3, [sp, #4]
    8c7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8c82:	bf00      	nop
    8c84:	b003      	add	sp, #12
    8c86:	f85d fb04 	ldr.w	pc, [sp], #4
    8c8a:	bf00      	nop
    8c8c:	1fff8f38 	.word	0x1fff8f38
    8c90:	1fff8f34 	.word	0x1fff8f34

00008c94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31(void)
{
    8c94:	b500      	push	{lr}
    8c96:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8c98:	f7f7 ff88 	bl	bac <Sys_GetCoreID>
    8c9c:	4603      	mov	r3, r0
    8c9e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId]--;
    8ca0:	4a0d      	ldr	r2, [pc, #52]	; (8cd8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x44>)
    8ca2:	9b01      	ldr	r3, [sp, #4]
    8ca4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ca8:	1e5a      	subs	r2, r3, #1
    8caa:	490b      	ldr	r1, [pc, #44]	; (8cd8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x44>)
    8cac:	9b01      	ldr	r3, [sp, #4]
    8cae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_31[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_31[u32CoreId]))         /*if interrupts were enabled*/
    8cb2:	4a0a      	ldr	r2, [pc, #40]	; (8cdc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x48>)
    8cb4:	9b01      	ldr	r3, [sp, #4]
    8cb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cba:	f003 0301 	and.w	r3, r3, #1
    8cbe:	2b00      	cmp	r3, #0
    8cc0:	d106      	bne.n	8cd0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x3c>
    8cc2:	4a05      	ldr	r2, [pc, #20]	; (8cd8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x44>)
    8cc4:	9b01      	ldr	r3, [sp, #4]
    8cc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cca:	2b00      	cmp	r3, #0
    8ccc:	d100      	bne.n	8cd0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_31+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8cce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8cd0:	bf00      	nop
    8cd2:	b003      	add	sp, #12
    8cd4:	f85d fb04 	ldr.w	pc, [sp], #4
    8cd8:	1fff8f38 	.word	0x1fff8f38
    8cdc:	1fff8f34 	.word	0x1fff8f34

00008ce0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35(void)
{
    8ce0:	b500      	push	{lr}
    8ce2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8ce4:	f7f7 ff62 	bl	bac <Sys_GetCoreID>
    8ce8:	4603      	mov	r3, r0
    8cea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId])
    8cec:	4a10      	ldr	r2, [pc, #64]	; (8d30 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x50>)
    8cee:	9b01      	ldr	r3, [sp, #4]
    8cf0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8cf4:	2b00      	cmp	r3, #0
    8cf6:	d10d      	bne.n	8d14 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8cf8:	f7f7 fe77 	bl	9ea <Gpt_schm_read_msr>
    8cfc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8cfe:	9b00      	ldr	r3, [sp, #0]
    8d00:	f003 0301 	and.w	r3, r3, #1
    8d04:	2b00      	cmp	r3, #0
    8d06:	d100      	bne.n	8d0a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8d08:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_35[u32CoreId] = msr;
    8d0a:	490a      	ldr	r1, [pc, #40]	; (8d34 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x54>)
    8d0c:	9b01      	ldr	r3, [sp, #4]
    8d0e:	9a00      	ldr	r2, [sp, #0]
    8d10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId]++;
    8d14:	4a06      	ldr	r2, [pc, #24]	; (8d30 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x50>)
    8d16:	9b01      	ldr	r3, [sp, #4]
    8d18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d1c:	1c5a      	adds	r2, r3, #1
    8d1e:	4904      	ldr	r1, [pc, #16]	; (8d30 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_35+0x50>)
    8d20:	9b01      	ldr	r3, [sp, #4]
    8d22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8d26:	bf00      	nop
    8d28:	b003      	add	sp, #12
    8d2a:	f85d fb04 	ldr.w	pc, [sp], #4
    8d2e:	bf00      	nop
    8d30:	1fff8f40 	.word	0x1fff8f40
    8d34:	1fff8f3c 	.word	0x1fff8f3c

00008d38 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35(void)
{
    8d38:	b500      	push	{lr}
    8d3a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d3c:	f7f7 ff36 	bl	bac <Sys_GetCoreID>
    8d40:	4603      	mov	r3, r0
    8d42:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId]--;
    8d44:	4a0d      	ldr	r2, [pc, #52]	; (8d7c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x44>)
    8d46:	9b01      	ldr	r3, [sp, #4]
    8d48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d4c:	1e5a      	subs	r2, r3, #1
    8d4e:	490b      	ldr	r1, [pc, #44]	; (8d7c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x44>)
    8d50:	9b01      	ldr	r3, [sp, #4]
    8d52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_35[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_35[u32CoreId]))         /*if interrupts were enabled*/
    8d56:	4a0a      	ldr	r2, [pc, #40]	; (8d80 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x48>)
    8d58:	9b01      	ldr	r3, [sp, #4]
    8d5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d5e:	f003 0301 	and.w	r3, r3, #1
    8d62:	2b00      	cmp	r3, #0
    8d64:	d106      	bne.n	8d74 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x3c>
    8d66:	4a05      	ldr	r2, [pc, #20]	; (8d7c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x44>)
    8d68:	9b01      	ldr	r3, [sp, #4]
    8d6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d6e:	2b00      	cmp	r3, #0
    8d70:	d100      	bne.n	8d74 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_35+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8d72:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8d74:	bf00      	nop
    8d76:	b003      	add	sp, #12
    8d78:	f85d fb04 	ldr.w	pc, [sp], #4
    8d7c:	1fff8f40 	.word	0x1fff8f40
    8d80:	1fff8f3c 	.word	0x1fff8f3c

00008d84 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36(void)
{
    8d84:	b500      	push	{lr}
    8d86:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8d88:	f7f7 ff10 	bl	bac <Sys_GetCoreID>
    8d8c:	4603      	mov	r3, r0
    8d8e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId])
    8d90:	4a10      	ldr	r2, [pc, #64]	; (8dd4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x50>)
    8d92:	9b01      	ldr	r3, [sp, #4]
    8d94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8d98:	2b00      	cmp	r3, #0
    8d9a:	d10d      	bne.n	8db8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8d9c:	f7f7 fe25 	bl	9ea <Gpt_schm_read_msr>
    8da0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8da2:	9b00      	ldr	r3, [sp, #0]
    8da4:	f003 0301 	and.w	r3, r3, #1
    8da8:	2b00      	cmp	r3, #0
    8daa:	d100      	bne.n	8dae <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8dac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_36[u32CoreId] = msr;
    8dae:	490a      	ldr	r1, [pc, #40]	; (8dd8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x54>)
    8db0:	9b01      	ldr	r3, [sp, #4]
    8db2:	9a00      	ldr	r2, [sp, #0]
    8db4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId]++;
    8db8:	4a06      	ldr	r2, [pc, #24]	; (8dd4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x50>)
    8dba:	9b01      	ldr	r3, [sp, #4]
    8dbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8dc0:	1c5a      	adds	r2, r3, #1
    8dc2:	4904      	ldr	r1, [pc, #16]	; (8dd4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_36+0x50>)
    8dc4:	9b01      	ldr	r3, [sp, #4]
    8dc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8dca:	bf00      	nop
    8dcc:	b003      	add	sp, #12
    8dce:	f85d fb04 	ldr.w	pc, [sp], #4
    8dd2:	bf00      	nop
    8dd4:	1fff8f48 	.word	0x1fff8f48
    8dd8:	1fff8f44 	.word	0x1fff8f44

00008ddc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36(void)
{
    8ddc:	b500      	push	{lr}
    8dde:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8de0:	f7f7 fee4 	bl	bac <Sys_GetCoreID>
    8de4:	4603      	mov	r3, r0
    8de6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId]--;
    8de8:	4a0d      	ldr	r2, [pc, #52]	; (8e20 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x44>)
    8dea:	9b01      	ldr	r3, [sp, #4]
    8dec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8df0:	1e5a      	subs	r2, r3, #1
    8df2:	490b      	ldr	r1, [pc, #44]	; (8e20 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x44>)
    8df4:	9b01      	ldr	r3, [sp, #4]
    8df6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_36[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_36[u32CoreId]))         /*if interrupts were enabled*/
    8dfa:	4a0a      	ldr	r2, [pc, #40]	; (8e24 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x48>)
    8dfc:	9b01      	ldr	r3, [sp, #4]
    8dfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e02:	f003 0301 	and.w	r3, r3, #1
    8e06:	2b00      	cmp	r3, #0
    8e08:	d106      	bne.n	8e18 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x3c>
    8e0a:	4a05      	ldr	r2, [pc, #20]	; (8e20 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x44>)
    8e0c:	9b01      	ldr	r3, [sp, #4]
    8e0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e12:	2b00      	cmp	r3, #0
    8e14:	d100      	bne.n	8e18 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_36+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8e16:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8e18:	bf00      	nop
    8e1a:	b003      	add	sp, #12
    8e1c:	f85d fb04 	ldr.w	pc, [sp], #4
    8e20:	1fff8f48 	.word	0x1fff8f48
    8e24:	1fff8f44 	.word	0x1fff8f44

00008e28 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38(void)
{
    8e28:	b500      	push	{lr}
    8e2a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e2c:	f7f7 febe 	bl	bac <Sys_GetCoreID>
    8e30:	4603      	mov	r3, r0
    8e32:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId])
    8e34:	4a10      	ldr	r2, [pc, #64]	; (8e78 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x50>)
    8e36:	9b01      	ldr	r3, [sp, #4]
    8e38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e3c:	2b00      	cmp	r3, #0
    8e3e:	d10d      	bne.n	8e5c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8e40:	f7f7 fdd3 	bl	9ea <Gpt_schm_read_msr>
    8e44:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8e46:	9b00      	ldr	r3, [sp, #0]
    8e48:	f003 0301 	and.w	r3, r3, #1
    8e4c:	2b00      	cmp	r3, #0
    8e4e:	d100      	bne.n	8e52 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8e50:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_38[u32CoreId] = msr;
    8e52:	490a      	ldr	r1, [pc, #40]	; (8e7c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x54>)
    8e54:	9b01      	ldr	r3, [sp, #4]
    8e56:	9a00      	ldr	r2, [sp, #0]
    8e58:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId]++;
    8e5c:	4a06      	ldr	r2, [pc, #24]	; (8e78 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x50>)
    8e5e:	9b01      	ldr	r3, [sp, #4]
    8e60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e64:	1c5a      	adds	r2, r3, #1
    8e66:	4904      	ldr	r1, [pc, #16]	; (8e78 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_38+0x50>)
    8e68:	9b01      	ldr	r3, [sp, #4]
    8e6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8e6e:	bf00      	nop
    8e70:	b003      	add	sp, #12
    8e72:	f85d fb04 	ldr.w	pc, [sp], #4
    8e76:	bf00      	nop
    8e78:	1fff8f50 	.word	0x1fff8f50
    8e7c:	1fff8f4c 	.word	0x1fff8f4c

00008e80 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38(void)
{
    8e80:	b500      	push	{lr}
    8e82:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8e84:	f7f7 fe92 	bl	bac <Sys_GetCoreID>
    8e88:	4603      	mov	r3, r0
    8e8a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId]--;
    8e8c:	4a0d      	ldr	r2, [pc, #52]	; (8ec4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x44>)
    8e8e:	9b01      	ldr	r3, [sp, #4]
    8e90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8e94:	1e5a      	subs	r2, r3, #1
    8e96:	490b      	ldr	r1, [pc, #44]	; (8ec4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x44>)
    8e98:	9b01      	ldr	r3, [sp, #4]
    8e9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_38[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_38[u32CoreId]))         /*if interrupts were enabled*/
    8e9e:	4a0a      	ldr	r2, [pc, #40]	; (8ec8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x48>)
    8ea0:	9b01      	ldr	r3, [sp, #4]
    8ea2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ea6:	f003 0301 	and.w	r3, r3, #1
    8eaa:	2b00      	cmp	r3, #0
    8eac:	d106      	bne.n	8ebc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x3c>
    8eae:	4a05      	ldr	r2, [pc, #20]	; (8ec4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x44>)
    8eb0:	9b01      	ldr	r3, [sp, #4]
    8eb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8eb6:	2b00      	cmp	r3, #0
    8eb8:	d100      	bne.n	8ebc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_38+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8eba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8ebc:	bf00      	nop
    8ebe:	b003      	add	sp, #12
    8ec0:	f85d fb04 	ldr.w	pc, [sp], #4
    8ec4:	1fff8f50 	.word	0x1fff8f50
    8ec8:	1fff8f4c 	.word	0x1fff8f4c

00008ecc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39(void)
{
    8ecc:	b500      	push	{lr}
    8ece:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8ed0:	f7f7 fe6c 	bl	bac <Sys_GetCoreID>
    8ed4:	4603      	mov	r3, r0
    8ed6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId])
    8ed8:	4a10      	ldr	r2, [pc, #64]	; (8f1c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x50>)
    8eda:	9b01      	ldr	r3, [sp, #4]
    8edc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ee0:	2b00      	cmp	r3, #0
    8ee2:	d10d      	bne.n	8f00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8ee4:	f7f7 fd81 	bl	9ea <Gpt_schm_read_msr>
    8ee8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8eea:	9b00      	ldr	r3, [sp, #0]
    8eec:	f003 0301 	and.w	r3, r3, #1
    8ef0:	2b00      	cmp	r3, #0
    8ef2:	d100      	bne.n	8ef6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8ef4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_39[u32CoreId] = msr;
    8ef6:	490a      	ldr	r1, [pc, #40]	; (8f20 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x54>)
    8ef8:	9b01      	ldr	r3, [sp, #4]
    8efa:	9a00      	ldr	r2, [sp, #0]
    8efc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId]++;
    8f00:	4a06      	ldr	r2, [pc, #24]	; (8f1c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x50>)
    8f02:	9b01      	ldr	r3, [sp, #4]
    8f04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f08:	1c5a      	adds	r2, r3, #1
    8f0a:	4904      	ldr	r1, [pc, #16]	; (8f1c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_39+0x50>)
    8f0c:	9b01      	ldr	r3, [sp, #4]
    8f0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8f12:	bf00      	nop
    8f14:	b003      	add	sp, #12
    8f16:	f85d fb04 	ldr.w	pc, [sp], #4
    8f1a:	bf00      	nop
    8f1c:	1fff8f58 	.word	0x1fff8f58
    8f20:	1fff8f54 	.word	0x1fff8f54

00008f24 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39(void)
{
    8f24:	b500      	push	{lr}
    8f26:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f28:	f7f7 fe40 	bl	bac <Sys_GetCoreID>
    8f2c:	4603      	mov	r3, r0
    8f2e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId]--;
    8f30:	4a0d      	ldr	r2, [pc, #52]	; (8f68 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x44>)
    8f32:	9b01      	ldr	r3, [sp, #4]
    8f34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f38:	1e5a      	subs	r2, r3, #1
    8f3a:	490b      	ldr	r1, [pc, #44]	; (8f68 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x44>)
    8f3c:	9b01      	ldr	r3, [sp, #4]
    8f3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_39[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_39[u32CoreId]))         /*if interrupts were enabled*/
    8f42:	4a0a      	ldr	r2, [pc, #40]	; (8f6c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x48>)
    8f44:	9b01      	ldr	r3, [sp, #4]
    8f46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f4a:	f003 0301 	and.w	r3, r3, #1
    8f4e:	2b00      	cmp	r3, #0
    8f50:	d106      	bne.n	8f60 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x3c>
    8f52:	4a05      	ldr	r2, [pc, #20]	; (8f68 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x44>)
    8f54:	9b01      	ldr	r3, [sp, #4]
    8f56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f5a:	2b00      	cmp	r3, #0
    8f5c:	d100      	bne.n	8f60 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_39+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    8f5e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    8f60:	bf00      	nop
    8f62:	b003      	add	sp, #12
    8f64:	f85d fb04 	ldr.w	pc, [sp], #4
    8f68:	1fff8f58 	.word	0x1fff8f58
    8f6c:	1fff8f54 	.word	0x1fff8f54

00008f70 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40(void)
{
    8f70:	b500      	push	{lr}
    8f72:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8f74:	f7f7 fe1a 	bl	bac <Sys_GetCoreID>
    8f78:	4603      	mov	r3, r0
    8f7a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId])
    8f7c:	4a10      	ldr	r2, [pc, #64]	; (8fc0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x50>)
    8f7e:	9b01      	ldr	r3, [sp, #4]
    8f80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8f84:	2b00      	cmp	r3, #0
    8f86:	d10d      	bne.n	8fa4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    8f88:	f7f7 fd2f 	bl	9ea <Gpt_schm_read_msr>
    8f8c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    8f8e:	9b00      	ldr	r3, [sp, #0]
    8f90:	f003 0301 	and.w	r3, r3, #1
    8f94:	2b00      	cmp	r3, #0
    8f96:	d100      	bne.n	8f9a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    8f98:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_40[u32CoreId] = msr;
    8f9a:	490a      	ldr	r1, [pc, #40]	; (8fc4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x54>)
    8f9c:	9b01      	ldr	r3, [sp, #4]
    8f9e:	9a00      	ldr	r2, [sp, #0]
    8fa0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId]++;
    8fa4:	4a06      	ldr	r2, [pc, #24]	; (8fc0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x50>)
    8fa6:	9b01      	ldr	r3, [sp, #4]
    8fa8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fac:	1c5a      	adds	r2, r3, #1
    8fae:	4904      	ldr	r1, [pc, #16]	; (8fc0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_40+0x50>)
    8fb0:	9b01      	ldr	r3, [sp, #4]
    8fb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    8fb6:	bf00      	nop
    8fb8:	b003      	add	sp, #12
    8fba:	f85d fb04 	ldr.w	pc, [sp], #4
    8fbe:	bf00      	nop
    8fc0:	1fff8f60 	.word	0x1fff8f60
    8fc4:	1fff8f5c 	.word	0x1fff8f5c

00008fc8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40(void)
{
    8fc8:	b500      	push	{lr}
    8fca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    8fcc:	f7f7 fdee 	bl	bac <Sys_GetCoreID>
    8fd0:	4603      	mov	r3, r0
    8fd2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId]--;
    8fd4:	4a0d      	ldr	r2, [pc, #52]	; (900c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x44>)
    8fd6:	9b01      	ldr	r3, [sp, #4]
    8fd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fdc:	1e5a      	subs	r2, r3, #1
    8fde:	490b      	ldr	r1, [pc, #44]	; (900c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x44>)
    8fe0:	9b01      	ldr	r3, [sp, #4]
    8fe2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_40[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_40[u32CoreId]))         /*if interrupts were enabled*/
    8fe6:	4a0a      	ldr	r2, [pc, #40]	; (9010 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x48>)
    8fe8:	9b01      	ldr	r3, [sp, #4]
    8fea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8fee:	f003 0301 	and.w	r3, r3, #1
    8ff2:	2b00      	cmp	r3, #0
    8ff4:	d106      	bne.n	9004 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x3c>
    8ff6:	4a05      	ldr	r2, [pc, #20]	; (900c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x44>)
    8ff8:	9b01      	ldr	r3, [sp, #4]
    8ffa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ffe:	2b00      	cmp	r3, #0
    9000:	d100      	bne.n	9004 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_40+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9002:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9004:	bf00      	nop
    9006:	b003      	add	sp, #12
    9008:	f85d fb04 	ldr.w	pc, [sp], #4
    900c:	1fff8f60 	.word	0x1fff8f60
    9010:	1fff8f5c 	.word	0x1fff8f5c

00009014 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41(void)
{
    9014:	b500      	push	{lr}
    9016:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9018:	f7f7 fdc8 	bl	bac <Sys_GetCoreID>
    901c:	4603      	mov	r3, r0
    901e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId])
    9020:	4a10      	ldr	r2, [pc, #64]	; (9064 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x50>)
    9022:	9b01      	ldr	r3, [sp, #4]
    9024:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9028:	2b00      	cmp	r3, #0
    902a:	d10d      	bne.n	9048 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    902c:	f7f7 fcdd 	bl	9ea <Gpt_schm_read_msr>
    9030:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9032:	9b00      	ldr	r3, [sp, #0]
    9034:	f003 0301 	and.w	r3, r3, #1
    9038:	2b00      	cmp	r3, #0
    903a:	d100      	bne.n	903e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    903c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_41[u32CoreId] = msr;
    903e:	490a      	ldr	r1, [pc, #40]	; (9068 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x54>)
    9040:	9b01      	ldr	r3, [sp, #4]
    9042:	9a00      	ldr	r2, [sp, #0]
    9044:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId]++;
    9048:	4a06      	ldr	r2, [pc, #24]	; (9064 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x50>)
    904a:	9b01      	ldr	r3, [sp, #4]
    904c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9050:	1c5a      	adds	r2, r3, #1
    9052:	4904      	ldr	r1, [pc, #16]	; (9064 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_41+0x50>)
    9054:	9b01      	ldr	r3, [sp, #4]
    9056:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    905a:	bf00      	nop
    905c:	b003      	add	sp, #12
    905e:	f85d fb04 	ldr.w	pc, [sp], #4
    9062:	bf00      	nop
    9064:	1fff8f68 	.word	0x1fff8f68
    9068:	1fff8f64 	.word	0x1fff8f64

0000906c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41(void)
{
    906c:	b500      	push	{lr}
    906e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9070:	f7f7 fd9c 	bl	bac <Sys_GetCoreID>
    9074:	4603      	mov	r3, r0
    9076:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId]--;
    9078:	4a0d      	ldr	r2, [pc, #52]	; (90b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x44>)
    907a:	9b01      	ldr	r3, [sp, #4]
    907c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9080:	1e5a      	subs	r2, r3, #1
    9082:	490b      	ldr	r1, [pc, #44]	; (90b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x44>)
    9084:	9b01      	ldr	r3, [sp, #4]
    9086:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_41[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_41[u32CoreId]))         /*if interrupts were enabled*/
    908a:	4a0a      	ldr	r2, [pc, #40]	; (90b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x48>)
    908c:	9b01      	ldr	r3, [sp, #4]
    908e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9092:	f003 0301 	and.w	r3, r3, #1
    9096:	2b00      	cmp	r3, #0
    9098:	d106      	bne.n	90a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x3c>
    909a:	4a05      	ldr	r2, [pc, #20]	; (90b0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x44>)
    909c:	9b01      	ldr	r3, [sp, #4]
    909e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90a2:	2b00      	cmp	r3, #0
    90a4:	d100      	bne.n	90a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_41+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    90a6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    90a8:	bf00      	nop
    90aa:	b003      	add	sp, #12
    90ac:	f85d fb04 	ldr.w	pc, [sp], #4
    90b0:	1fff8f68 	.word	0x1fff8f68
    90b4:	1fff8f64 	.word	0x1fff8f64

000090b8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42(void)
{
    90b8:	b500      	push	{lr}
    90ba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    90bc:	f7f7 fd76 	bl	bac <Sys_GetCoreID>
    90c0:	4603      	mov	r3, r0
    90c2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId])
    90c4:	4a10      	ldr	r2, [pc, #64]	; (9108 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x50>)
    90c6:	9b01      	ldr	r3, [sp, #4]
    90c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90cc:	2b00      	cmp	r3, #0
    90ce:	d10d      	bne.n	90ec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    90d0:	f7f7 fc8b 	bl	9ea <Gpt_schm_read_msr>
    90d4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    90d6:	9b00      	ldr	r3, [sp, #0]
    90d8:	f003 0301 	and.w	r3, r3, #1
    90dc:	2b00      	cmp	r3, #0
    90de:	d100      	bne.n	90e2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    90e0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_42[u32CoreId] = msr;
    90e2:	490a      	ldr	r1, [pc, #40]	; (910c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x54>)
    90e4:	9b01      	ldr	r3, [sp, #4]
    90e6:	9a00      	ldr	r2, [sp, #0]
    90e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId]++;
    90ec:	4a06      	ldr	r2, [pc, #24]	; (9108 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x50>)
    90ee:	9b01      	ldr	r3, [sp, #4]
    90f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    90f4:	1c5a      	adds	r2, r3, #1
    90f6:	4904      	ldr	r1, [pc, #16]	; (9108 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_42+0x50>)
    90f8:	9b01      	ldr	r3, [sp, #4]
    90fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    90fe:	bf00      	nop
    9100:	b003      	add	sp, #12
    9102:	f85d fb04 	ldr.w	pc, [sp], #4
    9106:	bf00      	nop
    9108:	1fff8f70 	.word	0x1fff8f70
    910c:	1fff8f6c 	.word	0x1fff8f6c

00009110 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42(void)
{
    9110:	b500      	push	{lr}
    9112:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9114:	f7f7 fd4a 	bl	bac <Sys_GetCoreID>
    9118:	4603      	mov	r3, r0
    911a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId]--;
    911c:	4a0d      	ldr	r2, [pc, #52]	; (9154 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x44>)
    911e:	9b01      	ldr	r3, [sp, #4]
    9120:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9124:	1e5a      	subs	r2, r3, #1
    9126:	490b      	ldr	r1, [pc, #44]	; (9154 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x44>)
    9128:	9b01      	ldr	r3, [sp, #4]
    912a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_42[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_42[u32CoreId]))         /*if interrupts were enabled*/
    912e:	4a0a      	ldr	r2, [pc, #40]	; (9158 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x48>)
    9130:	9b01      	ldr	r3, [sp, #4]
    9132:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9136:	f003 0301 	and.w	r3, r3, #1
    913a:	2b00      	cmp	r3, #0
    913c:	d106      	bne.n	914c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x3c>
    913e:	4a05      	ldr	r2, [pc, #20]	; (9154 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x44>)
    9140:	9b01      	ldr	r3, [sp, #4]
    9142:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9146:	2b00      	cmp	r3, #0
    9148:	d100      	bne.n	914c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_42+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    914a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    914c:	bf00      	nop
    914e:	b003      	add	sp, #12
    9150:	f85d fb04 	ldr.w	pc, [sp], #4
    9154:	1fff8f70 	.word	0x1fff8f70
    9158:	1fff8f6c 	.word	0x1fff8f6c

0000915c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43(void)
{
    915c:	b500      	push	{lr}
    915e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9160:	f7f7 fd24 	bl	bac <Sys_GetCoreID>
    9164:	4603      	mov	r3, r0
    9166:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId])
    9168:	4a10      	ldr	r2, [pc, #64]	; (91ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x50>)
    916a:	9b01      	ldr	r3, [sp, #4]
    916c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9170:	2b00      	cmp	r3, #0
    9172:	d10d      	bne.n	9190 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9174:	f7f7 fc39 	bl	9ea <Gpt_schm_read_msr>
    9178:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    917a:	9b00      	ldr	r3, [sp, #0]
    917c:	f003 0301 	and.w	r3, r3, #1
    9180:	2b00      	cmp	r3, #0
    9182:	d100      	bne.n	9186 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9184:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_43[u32CoreId] = msr;
    9186:	490a      	ldr	r1, [pc, #40]	; (91b0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x54>)
    9188:	9b01      	ldr	r3, [sp, #4]
    918a:	9a00      	ldr	r2, [sp, #0]
    918c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId]++;
    9190:	4a06      	ldr	r2, [pc, #24]	; (91ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x50>)
    9192:	9b01      	ldr	r3, [sp, #4]
    9194:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9198:	1c5a      	adds	r2, r3, #1
    919a:	4904      	ldr	r1, [pc, #16]	; (91ac <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_43+0x50>)
    919c:	9b01      	ldr	r3, [sp, #4]
    919e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    91a2:	bf00      	nop
    91a4:	b003      	add	sp, #12
    91a6:	f85d fb04 	ldr.w	pc, [sp], #4
    91aa:	bf00      	nop
    91ac:	1fff8f78 	.word	0x1fff8f78
    91b0:	1fff8f74 	.word	0x1fff8f74

000091b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43(void)
{
    91b4:	b500      	push	{lr}
    91b6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    91b8:	f7f7 fcf8 	bl	bac <Sys_GetCoreID>
    91bc:	4603      	mov	r3, r0
    91be:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId]--;
    91c0:	4a0d      	ldr	r2, [pc, #52]	; (91f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x44>)
    91c2:	9b01      	ldr	r3, [sp, #4]
    91c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91c8:	1e5a      	subs	r2, r3, #1
    91ca:	490b      	ldr	r1, [pc, #44]	; (91f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x44>)
    91cc:	9b01      	ldr	r3, [sp, #4]
    91ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_43[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_43[u32CoreId]))         /*if interrupts were enabled*/
    91d2:	4a0a      	ldr	r2, [pc, #40]	; (91fc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x48>)
    91d4:	9b01      	ldr	r3, [sp, #4]
    91d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91da:	f003 0301 	and.w	r3, r3, #1
    91de:	2b00      	cmp	r3, #0
    91e0:	d106      	bne.n	91f0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x3c>
    91e2:	4a05      	ldr	r2, [pc, #20]	; (91f8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x44>)
    91e4:	9b01      	ldr	r3, [sp, #4]
    91e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    91ea:	2b00      	cmp	r3, #0
    91ec:	d100      	bne.n	91f0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_43+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    91ee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    91f0:	bf00      	nop
    91f2:	b003      	add	sp, #12
    91f4:	f85d fb04 	ldr.w	pc, [sp], #4
    91f8:	1fff8f78 	.word	0x1fff8f78
    91fc:	1fff8f74 	.word	0x1fff8f74

00009200 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44(void)
{
    9200:	b500      	push	{lr}
    9202:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9204:	f7f7 fcd2 	bl	bac <Sys_GetCoreID>
    9208:	4603      	mov	r3, r0
    920a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId])
    920c:	4a10      	ldr	r2, [pc, #64]	; (9250 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x50>)
    920e:	9b01      	ldr	r3, [sp, #4]
    9210:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9214:	2b00      	cmp	r3, #0
    9216:	d10d      	bne.n	9234 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9218:	f7f7 fbe7 	bl	9ea <Gpt_schm_read_msr>
    921c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    921e:	9b00      	ldr	r3, [sp, #0]
    9220:	f003 0301 	and.w	r3, r3, #1
    9224:	2b00      	cmp	r3, #0
    9226:	d100      	bne.n	922a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9228:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_44[u32CoreId] = msr;
    922a:	490a      	ldr	r1, [pc, #40]	; (9254 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x54>)
    922c:	9b01      	ldr	r3, [sp, #4]
    922e:	9a00      	ldr	r2, [sp, #0]
    9230:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId]++;
    9234:	4a06      	ldr	r2, [pc, #24]	; (9250 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x50>)
    9236:	9b01      	ldr	r3, [sp, #4]
    9238:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    923c:	1c5a      	adds	r2, r3, #1
    923e:	4904      	ldr	r1, [pc, #16]	; (9250 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_44+0x50>)
    9240:	9b01      	ldr	r3, [sp, #4]
    9242:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9246:	bf00      	nop
    9248:	b003      	add	sp, #12
    924a:	f85d fb04 	ldr.w	pc, [sp], #4
    924e:	bf00      	nop
    9250:	1fff8f80 	.word	0x1fff8f80
    9254:	1fff8f7c 	.word	0x1fff8f7c

00009258 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44(void)
{
    9258:	b500      	push	{lr}
    925a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    925c:	f7f7 fca6 	bl	bac <Sys_GetCoreID>
    9260:	4603      	mov	r3, r0
    9262:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId]--;
    9264:	4a0d      	ldr	r2, [pc, #52]	; (929c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x44>)
    9266:	9b01      	ldr	r3, [sp, #4]
    9268:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    926c:	1e5a      	subs	r2, r3, #1
    926e:	490b      	ldr	r1, [pc, #44]	; (929c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x44>)
    9270:	9b01      	ldr	r3, [sp, #4]
    9272:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_44[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_44[u32CoreId]))         /*if interrupts were enabled*/
    9276:	4a0a      	ldr	r2, [pc, #40]	; (92a0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x48>)
    9278:	9b01      	ldr	r3, [sp, #4]
    927a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    927e:	f003 0301 	and.w	r3, r3, #1
    9282:	2b00      	cmp	r3, #0
    9284:	d106      	bne.n	9294 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x3c>
    9286:	4a05      	ldr	r2, [pc, #20]	; (929c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x44>)
    9288:	9b01      	ldr	r3, [sp, #4]
    928a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    928e:	2b00      	cmp	r3, #0
    9290:	d100      	bne.n	9294 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_44+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9292:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9294:	bf00      	nop
    9296:	b003      	add	sp, #12
    9298:	f85d fb04 	ldr.w	pc, [sp], #4
    929c:	1fff8f80 	.word	0x1fff8f80
    92a0:	1fff8f7c 	.word	0x1fff8f7c

000092a4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45(void)
{
    92a4:	b500      	push	{lr}
    92a6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    92a8:	f7f7 fc80 	bl	bac <Sys_GetCoreID>
    92ac:	4603      	mov	r3, r0
    92ae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId])
    92b0:	4a10      	ldr	r2, [pc, #64]	; (92f4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x50>)
    92b2:	9b01      	ldr	r3, [sp, #4]
    92b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92b8:	2b00      	cmp	r3, #0
    92ba:	d10d      	bne.n	92d8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    92bc:	f7f7 fb95 	bl	9ea <Gpt_schm_read_msr>
    92c0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    92c2:	9b00      	ldr	r3, [sp, #0]
    92c4:	f003 0301 	and.w	r3, r3, #1
    92c8:	2b00      	cmp	r3, #0
    92ca:	d100      	bne.n	92ce <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    92cc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_45[u32CoreId] = msr;
    92ce:	490a      	ldr	r1, [pc, #40]	; (92f8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x54>)
    92d0:	9b01      	ldr	r3, [sp, #4]
    92d2:	9a00      	ldr	r2, [sp, #0]
    92d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId]++;
    92d8:	4a06      	ldr	r2, [pc, #24]	; (92f4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x50>)
    92da:	9b01      	ldr	r3, [sp, #4]
    92dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    92e0:	1c5a      	adds	r2, r3, #1
    92e2:	4904      	ldr	r1, [pc, #16]	; (92f4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_45+0x50>)
    92e4:	9b01      	ldr	r3, [sp, #4]
    92e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    92ea:	bf00      	nop
    92ec:	b003      	add	sp, #12
    92ee:	f85d fb04 	ldr.w	pc, [sp], #4
    92f2:	bf00      	nop
    92f4:	1fff8f88 	.word	0x1fff8f88
    92f8:	1fff8f84 	.word	0x1fff8f84

000092fc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45(void)
{
    92fc:	b500      	push	{lr}
    92fe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9300:	f7f7 fc54 	bl	bac <Sys_GetCoreID>
    9304:	4603      	mov	r3, r0
    9306:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId]--;
    9308:	4a0d      	ldr	r2, [pc, #52]	; (9340 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x44>)
    930a:	9b01      	ldr	r3, [sp, #4]
    930c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9310:	1e5a      	subs	r2, r3, #1
    9312:	490b      	ldr	r1, [pc, #44]	; (9340 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x44>)
    9314:	9b01      	ldr	r3, [sp, #4]
    9316:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_45[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_45[u32CoreId]))         /*if interrupts were enabled*/
    931a:	4a0a      	ldr	r2, [pc, #40]	; (9344 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x48>)
    931c:	9b01      	ldr	r3, [sp, #4]
    931e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9322:	f003 0301 	and.w	r3, r3, #1
    9326:	2b00      	cmp	r3, #0
    9328:	d106      	bne.n	9338 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x3c>
    932a:	4a05      	ldr	r2, [pc, #20]	; (9340 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x44>)
    932c:	9b01      	ldr	r3, [sp, #4]
    932e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9332:	2b00      	cmp	r3, #0
    9334:	d100      	bne.n	9338 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_45+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9336:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9338:	bf00      	nop
    933a:	b003      	add	sp, #12
    933c:	f85d fb04 	ldr.w	pc, [sp], #4
    9340:	1fff8f88 	.word	0x1fff8f88
    9344:	1fff8f84 	.word	0x1fff8f84

00009348 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46(void)
{
    9348:	b500      	push	{lr}
    934a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    934c:	f7f7 fc2e 	bl	bac <Sys_GetCoreID>
    9350:	4603      	mov	r3, r0
    9352:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId])
    9354:	4a10      	ldr	r2, [pc, #64]	; (9398 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x50>)
    9356:	9b01      	ldr	r3, [sp, #4]
    9358:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    935c:	2b00      	cmp	r3, #0
    935e:	d10d      	bne.n	937c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9360:	f7f7 fb43 	bl	9ea <Gpt_schm_read_msr>
    9364:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9366:	9b00      	ldr	r3, [sp, #0]
    9368:	f003 0301 	and.w	r3, r3, #1
    936c:	2b00      	cmp	r3, #0
    936e:	d100      	bne.n	9372 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9370:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_46[u32CoreId] = msr;
    9372:	490a      	ldr	r1, [pc, #40]	; (939c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x54>)
    9374:	9b01      	ldr	r3, [sp, #4]
    9376:	9a00      	ldr	r2, [sp, #0]
    9378:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId]++;
    937c:	4a06      	ldr	r2, [pc, #24]	; (9398 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x50>)
    937e:	9b01      	ldr	r3, [sp, #4]
    9380:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9384:	1c5a      	adds	r2, r3, #1
    9386:	4904      	ldr	r1, [pc, #16]	; (9398 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_46+0x50>)
    9388:	9b01      	ldr	r3, [sp, #4]
    938a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    938e:	bf00      	nop
    9390:	b003      	add	sp, #12
    9392:	f85d fb04 	ldr.w	pc, [sp], #4
    9396:	bf00      	nop
    9398:	1fff8f90 	.word	0x1fff8f90
    939c:	1fff8f8c 	.word	0x1fff8f8c

000093a0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46(void)
{
    93a0:	b500      	push	{lr}
    93a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    93a4:	f7f7 fc02 	bl	bac <Sys_GetCoreID>
    93a8:	4603      	mov	r3, r0
    93aa:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId]--;
    93ac:	4a0d      	ldr	r2, [pc, #52]	; (93e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x44>)
    93ae:	9b01      	ldr	r3, [sp, #4]
    93b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93b4:	1e5a      	subs	r2, r3, #1
    93b6:	490b      	ldr	r1, [pc, #44]	; (93e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x44>)
    93b8:	9b01      	ldr	r3, [sp, #4]
    93ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_46[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_46[u32CoreId]))         /*if interrupts were enabled*/
    93be:	4a0a      	ldr	r2, [pc, #40]	; (93e8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x48>)
    93c0:	9b01      	ldr	r3, [sp, #4]
    93c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93c6:	f003 0301 	and.w	r3, r3, #1
    93ca:	2b00      	cmp	r3, #0
    93cc:	d106      	bne.n	93dc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x3c>
    93ce:	4a05      	ldr	r2, [pc, #20]	; (93e4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x44>)
    93d0:	9b01      	ldr	r3, [sp, #4]
    93d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    93d6:	2b00      	cmp	r3, #0
    93d8:	d100      	bne.n	93dc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_46+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    93da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    93dc:	bf00      	nop
    93de:	b003      	add	sp, #12
    93e0:	f85d fb04 	ldr.w	pc, [sp], #4
    93e4:	1fff8f90 	.word	0x1fff8f90
    93e8:	1fff8f8c 	.word	0x1fff8f8c

000093ec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50(void)
{
    93ec:	b500      	push	{lr}
    93ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    93f0:	f7f7 fbdc 	bl	bac <Sys_GetCoreID>
    93f4:	4603      	mov	r3, r0
    93f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId])
    93f8:	4a10      	ldr	r2, [pc, #64]	; (943c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x50>)
    93fa:	9b01      	ldr	r3, [sp, #4]
    93fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9400:	2b00      	cmp	r3, #0
    9402:	d10d      	bne.n	9420 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9404:	f7f7 faf1 	bl	9ea <Gpt_schm_read_msr>
    9408:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    940a:	9b00      	ldr	r3, [sp, #0]
    940c:	f003 0301 	and.w	r3, r3, #1
    9410:	2b00      	cmp	r3, #0
    9412:	d100      	bne.n	9416 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9414:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_50[u32CoreId] = msr;
    9416:	490a      	ldr	r1, [pc, #40]	; (9440 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x54>)
    9418:	9b01      	ldr	r3, [sp, #4]
    941a:	9a00      	ldr	r2, [sp, #0]
    941c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId]++;
    9420:	4a06      	ldr	r2, [pc, #24]	; (943c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x50>)
    9422:	9b01      	ldr	r3, [sp, #4]
    9424:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9428:	1c5a      	adds	r2, r3, #1
    942a:	4904      	ldr	r1, [pc, #16]	; (943c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_50+0x50>)
    942c:	9b01      	ldr	r3, [sp, #4]
    942e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9432:	bf00      	nop
    9434:	b003      	add	sp, #12
    9436:	f85d fb04 	ldr.w	pc, [sp], #4
    943a:	bf00      	nop
    943c:	1fff8f98 	.word	0x1fff8f98
    9440:	1fff8f94 	.word	0x1fff8f94

00009444 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50(void)
{
    9444:	b500      	push	{lr}
    9446:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9448:	f7f7 fbb0 	bl	bac <Sys_GetCoreID>
    944c:	4603      	mov	r3, r0
    944e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId]--;
    9450:	4a0d      	ldr	r2, [pc, #52]	; (9488 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x44>)
    9452:	9b01      	ldr	r3, [sp, #4]
    9454:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9458:	1e5a      	subs	r2, r3, #1
    945a:	490b      	ldr	r1, [pc, #44]	; (9488 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x44>)
    945c:	9b01      	ldr	r3, [sp, #4]
    945e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_50[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_50[u32CoreId]))         /*if interrupts were enabled*/
    9462:	4a0a      	ldr	r2, [pc, #40]	; (948c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x48>)
    9464:	9b01      	ldr	r3, [sp, #4]
    9466:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    946a:	f003 0301 	and.w	r3, r3, #1
    946e:	2b00      	cmp	r3, #0
    9470:	d106      	bne.n	9480 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x3c>
    9472:	4a05      	ldr	r2, [pc, #20]	; (9488 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x44>)
    9474:	9b01      	ldr	r3, [sp, #4]
    9476:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    947a:	2b00      	cmp	r3, #0
    947c:	d100      	bne.n	9480 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_50+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    947e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9480:	bf00      	nop
    9482:	b003      	add	sp, #12
    9484:	f85d fb04 	ldr.w	pc, [sp], #4
    9488:	1fff8f98 	.word	0x1fff8f98
    948c:	1fff8f94 	.word	0x1fff8f94

00009490 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51(void)
{
    9490:	b500      	push	{lr}
    9492:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9494:	f7f7 fb8a 	bl	bac <Sys_GetCoreID>
    9498:	4603      	mov	r3, r0
    949a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId])
    949c:	4a10      	ldr	r2, [pc, #64]	; (94e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x50>)
    949e:	9b01      	ldr	r3, [sp, #4]
    94a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94a4:	2b00      	cmp	r3, #0
    94a6:	d10d      	bne.n	94c4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    94a8:	f7f7 fa9f 	bl	9ea <Gpt_schm_read_msr>
    94ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    94ae:	9b00      	ldr	r3, [sp, #0]
    94b0:	f003 0301 	and.w	r3, r3, #1
    94b4:	2b00      	cmp	r3, #0
    94b6:	d100      	bne.n	94ba <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    94b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_51[u32CoreId] = msr;
    94ba:	490a      	ldr	r1, [pc, #40]	; (94e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x54>)
    94bc:	9b01      	ldr	r3, [sp, #4]
    94be:	9a00      	ldr	r2, [sp, #0]
    94c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId]++;
    94c4:	4a06      	ldr	r2, [pc, #24]	; (94e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x50>)
    94c6:	9b01      	ldr	r3, [sp, #4]
    94c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94cc:	1c5a      	adds	r2, r3, #1
    94ce:	4904      	ldr	r1, [pc, #16]	; (94e0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_51+0x50>)
    94d0:	9b01      	ldr	r3, [sp, #4]
    94d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    94d6:	bf00      	nop
    94d8:	b003      	add	sp, #12
    94da:	f85d fb04 	ldr.w	pc, [sp], #4
    94de:	bf00      	nop
    94e0:	1fff8fa0 	.word	0x1fff8fa0
    94e4:	1fff8f9c 	.word	0x1fff8f9c

000094e8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51(void)
{
    94e8:	b500      	push	{lr}
    94ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    94ec:	f7f7 fb5e 	bl	bac <Sys_GetCoreID>
    94f0:	4603      	mov	r3, r0
    94f2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId]--;
    94f4:	4a0d      	ldr	r2, [pc, #52]	; (952c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x44>)
    94f6:	9b01      	ldr	r3, [sp, #4]
    94f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    94fc:	1e5a      	subs	r2, r3, #1
    94fe:	490b      	ldr	r1, [pc, #44]	; (952c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x44>)
    9500:	9b01      	ldr	r3, [sp, #4]
    9502:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_51[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_51[u32CoreId]))         /*if interrupts were enabled*/
    9506:	4a0a      	ldr	r2, [pc, #40]	; (9530 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x48>)
    9508:	9b01      	ldr	r3, [sp, #4]
    950a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    950e:	f003 0301 	and.w	r3, r3, #1
    9512:	2b00      	cmp	r3, #0
    9514:	d106      	bne.n	9524 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x3c>
    9516:	4a05      	ldr	r2, [pc, #20]	; (952c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x44>)
    9518:	9b01      	ldr	r3, [sp, #4]
    951a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    951e:	2b00      	cmp	r3, #0
    9520:	d100      	bne.n	9524 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_51+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9522:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9524:	bf00      	nop
    9526:	b003      	add	sp, #12
    9528:	f85d fb04 	ldr.w	pc, [sp], #4
    952c:	1fff8fa0 	.word	0x1fff8fa0
    9530:	1fff8f9c 	.word	0x1fff8f9c

00009534 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52(void)
{
    9534:	b500      	push	{lr}
    9536:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9538:	f7f7 fb38 	bl	bac <Sys_GetCoreID>
    953c:	4603      	mov	r3, r0
    953e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId])
    9540:	4a10      	ldr	r2, [pc, #64]	; (9584 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x50>)
    9542:	9b01      	ldr	r3, [sp, #4]
    9544:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9548:	2b00      	cmp	r3, #0
    954a:	d10d      	bne.n	9568 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    954c:	f7f7 fa4d 	bl	9ea <Gpt_schm_read_msr>
    9550:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9552:	9b00      	ldr	r3, [sp, #0]
    9554:	f003 0301 	and.w	r3, r3, #1
    9558:	2b00      	cmp	r3, #0
    955a:	d100      	bne.n	955e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    955c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_52[u32CoreId] = msr;
    955e:	490a      	ldr	r1, [pc, #40]	; (9588 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x54>)
    9560:	9b01      	ldr	r3, [sp, #4]
    9562:	9a00      	ldr	r2, [sp, #0]
    9564:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId]++;
    9568:	4a06      	ldr	r2, [pc, #24]	; (9584 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x50>)
    956a:	9b01      	ldr	r3, [sp, #4]
    956c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9570:	1c5a      	adds	r2, r3, #1
    9572:	4904      	ldr	r1, [pc, #16]	; (9584 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_52+0x50>)
    9574:	9b01      	ldr	r3, [sp, #4]
    9576:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    957a:	bf00      	nop
    957c:	b003      	add	sp, #12
    957e:	f85d fb04 	ldr.w	pc, [sp], #4
    9582:	bf00      	nop
    9584:	1fff8fa8 	.word	0x1fff8fa8
    9588:	1fff8fa4 	.word	0x1fff8fa4

0000958c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52(void)
{
    958c:	b500      	push	{lr}
    958e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9590:	f7f7 fb0c 	bl	bac <Sys_GetCoreID>
    9594:	4603      	mov	r3, r0
    9596:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId]--;
    9598:	4a0d      	ldr	r2, [pc, #52]	; (95d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x44>)
    959a:	9b01      	ldr	r3, [sp, #4]
    959c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95a0:	1e5a      	subs	r2, r3, #1
    95a2:	490b      	ldr	r1, [pc, #44]	; (95d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x44>)
    95a4:	9b01      	ldr	r3, [sp, #4]
    95a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_52[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_52[u32CoreId]))         /*if interrupts were enabled*/
    95aa:	4a0a      	ldr	r2, [pc, #40]	; (95d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x48>)
    95ac:	9b01      	ldr	r3, [sp, #4]
    95ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95b2:	f003 0301 	and.w	r3, r3, #1
    95b6:	2b00      	cmp	r3, #0
    95b8:	d106      	bne.n	95c8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x3c>
    95ba:	4a05      	ldr	r2, [pc, #20]	; (95d0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x44>)
    95bc:	9b01      	ldr	r3, [sp, #4]
    95be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95c2:	2b00      	cmp	r3, #0
    95c4:	d100      	bne.n	95c8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_52+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    95c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    95c8:	bf00      	nop
    95ca:	b003      	add	sp, #12
    95cc:	f85d fb04 	ldr.w	pc, [sp], #4
    95d0:	1fff8fa8 	.word	0x1fff8fa8
    95d4:	1fff8fa4 	.word	0x1fff8fa4

000095d8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53(void)
{
    95d8:	b500      	push	{lr}
    95da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    95dc:	f7f7 fae6 	bl	bac <Sys_GetCoreID>
    95e0:	4603      	mov	r3, r0
    95e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId])
    95e4:	4a10      	ldr	r2, [pc, #64]	; (9628 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x50>)
    95e6:	9b01      	ldr	r3, [sp, #4]
    95e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    95ec:	2b00      	cmp	r3, #0
    95ee:	d10d      	bne.n	960c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    95f0:	f7f7 f9fb 	bl	9ea <Gpt_schm_read_msr>
    95f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    95f6:	9b00      	ldr	r3, [sp, #0]
    95f8:	f003 0301 	and.w	r3, r3, #1
    95fc:	2b00      	cmp	r3, #0
    95fe:	d100      	bne.n	9602 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9600:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_53[u32CoreId] = msr;
    9602:	490a      	ldr	r1, [pc, #40]	; (962c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x54>)
    9604:	9b01      	ldr	r3, [sp, #4]
    9606:	9a00      	ldr	r2, [sp, #0]
    9608:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId]++;
    960c:	4a06      	ldr	r2, [pc, #24]	; (9628 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x50>)
    960e:	9b01      	ldr	r3, [sp, #4]
    9610:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9614:	1c5a      	adds	r2, r3, #1
    9616:	4904      	ldr	r1, [pc, #16]	; (9628 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_53+0x50>)
    9618:	9b01      	ldr	r3, [sp, #4]
    961a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    961e:	bf00      	nop
    9620:	b003      	add	sp, #12
    9622:	f85d fb04 	ldr.w	pc, [sp], #4
    9626:	bf00      	nop
    9628:	1fff8fb0 	.word	0x1fff8fb0
    962c:	1fff8fac 	.word	0x1fff8fac

00009630 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53(void)
{
    9630:	b500      	push	{lr}
    9632:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9634:	f7f7 faba 	bl	bac <Sys_GetCoreID>
    9638:	4603      	mov	r3, r0
    963a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId]--;
    963c:	4a0d      	ldr	r2, [pc, #52]	; (9674 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x44>)
    963e:	9b01      	ldr	r3, [sp, #4]
    9640:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9644:	1e5a      	subs	r2, r3, #1
    9646:	490b      	ldr	r1, [pc, #44]	; (9674 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x44>)
    9648:	9b01      	ldr	r3, [sp, #4]
    964a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_53[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_53[u32CoreId]))         /*if interrupts were enabled*/
    964e:	4a0a      	ldr	r2, [pc, #40]	; (9678 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x48>)
    9650:	9b01      	ldr	r3, [sp, #4]
    9652:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9656:	f003 0301 	and.w	r3, r3, #1
    965a:	2b00      	cmp	r3, #0
    965c:	d106      	bne.n	966c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x3c>
    965e:	4a05      	ldr	r2, [pc, #20]	; (9674 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x44>)
    9660:	9b01      	ldr	r3, [sp, #4]
    9662:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9666:	2b00      	cmp	r3, #0
    9668:	d100      	bne.n	966c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_53+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    966a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    966c:	bf00      	nop
    966e:	b003      	add	sp, #12
    9670:	f85d fb04 	ldr.w	pc, [sp], #4
    9674:	1fff8fb0 	.word	0x1fff8fb0
    9678:	1fff8fac 	.word	0x1fff8fac

0000967c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54(void)
{
    967c:	b500      	push	{lr}
    967e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9680:	f7f7 fa94 	bl	bac <Sys_GetCoreID>
    9684:	4603      	mov	r3, r0
    9686:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId])
    9688:	4a10      	ldr	r2, [pc, #64]	; (96cc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x50>)
    968a:	9b01      	ldr	r3, [sp, #4]
    968c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9690:	2b00      	cmp	r3, #0
    9692:	d10d      	bne.n	96b0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9694:	f7f7 f9a9 	bl	9ea <Gpt_schm_read_msr>
    9698:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    969a:	9b00      	ldr	r3, [sp, #0]
    969c:	f003 0301 	and.w	r3, r3, #1
    96a0:	2b00      	cmp	r3, #0
    96a2:	d100      	bne.n	96a6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    96a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_54[u32CoreId] = msr;
    96a6:	490a      	ldr	r1, [pc, #40]	; (96d0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x54>)
    96a8:	9b01      	ldr	r3, [sp, #4]
    96aa:	9a00      	ldr	r2, [sp, #0]
    96ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId]++;
    96b0:	4a06      	ldr	r2, [pc, #24]	; (96cc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x50>)
    96b2:	9b01      	ldr	r3, [sp, #4]
    96b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96b8:	1c5a      	adds	r2, r3, #1
    96ba:	4904      	ldr	r1, [pc, #16]	; (96cc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_54+0x50>)
    96bc:	9b01      	ldr	r3, [sp, #4]
    96be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    96c2:	bf00      	nop
    96c4:	b003      	add	sp, #12
    96c6:	f85d fb04 	ldr.w	pc, [sp], #4
    96ca:	bf00      	nop
    96cc:	1fff8fb8 	.word	0x1fff8fb8
    96d0:	1fff8fb4 	.word	0x1fff8fb4

000096d4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54(void)
{
    96d4:	b500      	push	{lr}
    96d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    96d8:	f7f7 fa68 	bl	bac <Sys_GetCoreID>
    96dc:	4603      	mov	r3, r0
    96de:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId]--;
    96e0:	4a0d      	ldr	r2, [pc, #52]	; (9718 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x44>)
    96e2:	9b01      	ldr	r3, [sp, #4]
    96e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96e8:	1e5a      	subs	r2, r3, #1
    96ea:	490b      	ldr	r1, [pc, #44]	; (9718 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x44>)
    96ec:	9b01      	ldr	r3, [sp, #4]
    96ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_54[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_54[u32CoreId]))         /*if interrupts were enabled*/
    96f2:	4a0a      	ldr	r2, [pc, #40]	; (971c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x48>)
    96f4:	9b01      	ldr	r3, [sp, #4]
    96f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    96fa:	f003 0301 	and.w	r3, r3, #1
    96fe:	2b00      	cmp	r3, #0
    9700:	d106      	bne.n	9710 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x3c>
    9702:	4a05      	ldr	r2, [pc, #20]	; (9718 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x44>)
    9704:	9b01      	ldr	r3, [sp, #4]
    9706:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    970a:	2b00      	cmp	r3, #0
    970c:	d100      	bne.n	9710 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_54+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    970e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9710:	bf00      	nop
    9712:	b003      	add	sp, #12
    9714:	f85d fb04 	ldr.w	pc, [sp], #4
    9718:	1fff8fb8 	.word	0x1fff8fb8
    971c:	1fff8fb4 	.word	0x1fff8fb4

00009720 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55(void)
{
    9720:	b500      	push	{lr}
    9722:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9724:	f7f7 fa42 	bl	bac <Sys_GetCoreID>
    9728:	4603      	mov	r3, r0
    972a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId])
    972c:	4a10      	ldr	r2, [pc, #64]	; (9770 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x50>)
    972e:	9b01      	ldr	r3, [sp, #4]
    9730:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9734:	2b00      	cmp	r3, #0
    9736:	d10d      	bne.n	9754 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9738:	f7f7 f957 	bl	9ea <Gpt_schm_read_msr>
    973c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    973e:	9b00      	ldr	r3, [sp, #0]
    9740:	f003 0301 	and.w	r3, r3, #1
    9744:	2b00      	cmp	r3, #0
    9746:	d100      	bne.n	974a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9748:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_55[u32CoreId] = msr;
    974a:	490a      	ldr	r1, [pc, #40]	; (9774 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x54>)
    974c:	9b01      	ldr	r3, [sp, #4]
    974e:	9a00      	ldr	r2, [sp, #0]
    9750:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId]++;
    9754:	4a06      	ldr	r2, [pc, #24]	; (9770 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x50>)
    9756:	9b01      	ldr	r3, [sp, #4]
    9758:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    975c:	1c5a      	adds	r2, r3, #1
    975e:	4904      	ldr	r1, [pc, #16]	; (9770 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_55+0x50>)
    9760:	9b01      	ldr	r3, [sp, #4]
    9762:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9766:	bf00      	nop
    9768:	b003      	add	sp, #12
    976a:	f85d fb04 	ldr.w	pc, [sp], #4
    976e:	bf00      	nop
    9770:	1fff8fc0 	.word	0x1fff8fc0
    9774:	1fff8fbc 	.word	0x1fff8fbc

00009778 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55(void)
{
    9778:	b500      	push	{lr}
    977a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    977c:	f7f7 fa16 	bl	bac <Sys_GetCoreID>
    9780:	4603      	mov	r3, r0
    9782:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId]--;
    9784:	4a0d      	ldr	r2, [pc, #52]	; (97bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x44>)
    9786:	9b01      	ldr	r3, [sp, #4]
    9788:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    978c:	1e5a      	subs	r2, r3, #1
    978e:	490b      	ldr	r1, [pc, #44]	; (97bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x44>)
    9790:	9b01      	ldr	r3, [sp, #4]
    9792:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_55[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_55[u32CoreId]))         /*if interrupts were enabled*/
    9796:	4a0a      	ldr	r2, [pc, #40]	; (97c0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x48>)
    9798:	9b01      	ldr	r3, [sp, #4]
    979a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    979e:	f003 0301 	and.w	r3, r3, #1
    97a2:	2b00      	cmp	r3, #0
    97a4:	d106      	bne.n	97b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x3c>
    97a6:	4a05      	ldr	r2, [pc, #20]	; (97bc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x44>)
    97a8:	9b01      	ldr	r3, [sp, #4]
    97aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97ae:	2b00      	cmp	r3, #0
    97b0:	d100      	bne.n	97b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_55+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    97b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    97b4:	bf00      	nop
    97b6:	b003      	add	sp, #12
    97b8:	f85d fb04 	ldr.w	pc, [sp], #4
    97bc:	1fff8fc0 	.word	0x1fff8fc0
    97c0:	1fff8fbc 	.word	0x1fff8fbc

000097c4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56(void)
{
    97c4:	b500      	push	{lr}
    97c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    97c8:	f7f7 f9f0 	bl	bac <Sys_GetCoreID>
    97cc:	4603      	mov	r3, r0
    97ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId])
    97d0:	4a10      	ldr	r2, [pc, #64]	; (9814 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x50>)
    97d2:	9b01      	ldr	r3, [sp, #4]
    97d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97d8:	2b00      	cmp	r3, #0
    97da:	d10d      	bne.n	97f8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    97dc:	f7f7 f905 	bl	9ea <Gpt_schm_read_msr>
    97e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    97e2:	9b00      	ldr	r3, [sp, #0]
    97e4:	f003 0301 	and.w	r3, r3, #1
    97e8:	2b00      	cmp	r3, #0
    97ea:	d100      	bne.n	97ee <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    97ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_56[u32CoreId] = msr;
    97ee:	490a      	ldr	r1, [pc, #40]	; (9818 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x54>)
    97f0:	9b01      	ldr	r3, [sp, #4]
    97f2:	9a00      	ldr	r2, [sp, #0]
    97f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId]++;
    97f8:	4a06      	ldr	r2, [pc, #24]	; (9814 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x50>)
    97fa:	9b01      	ldr	r3, [sp, #4]
    97fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9800:	1c5a      	adds	r2, r3, #1
    9802:	4904      	ldr	r1, [pc, #16]	; (9814 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_56+0x50>)
    9804:	9b01      	ldr	r3, [sp, #4]
    9806:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    980a:	bf00      	nop
    980c:	b003      	add	sp, #12
    980e:	f85d fb04 	ldr.w	pc, [sp], #4
    9812:	bf00      	nop
    9814:	1fff8fc8 	.word	0x1fff8fc8
    9818:	1fff8fc4 	.word	0x1fff8fc4

0000981c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56(void)
{
    981c:	b500      	push	{lr}
    981e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9820:	f7f7 f9c4 	bl	bac <Sys_GetCoreID>
    9824:	4603      	mov	r3, r0
    9826:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId]--;
    9828:	4a0d      	ldr	r2, [pc, #52]	; (9860 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x44>)
    982a:	9b01      	ldr	r3, [sp, #4]
    982c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9830:	1e5a      	subs	r2, r3, #1
    9832:	490b      	ldr	r1, [pc, #44]	; (9860 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x44>)
    9834:	9b01      	ldr	r3, [sp, #4]
    9836:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_56[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_56[u32CoreId]))         /*if interrupts were enabled*/
    983a:	4a0a      	ldr	r2, [pc, #40]	; (9864 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x48>)
    983c:	9b01      	ldr	r3, [sp, #4]
    983e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9842:	f003 0301 	and.w	r3, r3, #1
    9846:	2b00      	cmp	r3, #0
    9848:	d106      	bne.n	9858 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x3c>
    984a:	4a05      	ldr	r2, [pc, #20]	; (9860 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x44>)
    984c:	9b01      	ldr	r3, [sp, #4]
    984e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9852:	2b00      	cmp	r3, #0
    9854:	d100      	bne.n	9858 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_56+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9856:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9858:	bf00      	nop
    985a:	b003      	add	sp, #12
    985c:	f85d fb04 	ldr.w	pc, [sp], #4
    9860:	1fff8fc8 	.word	0x1fff8fc8
    9864:	1fff8fc4 	.word	0x1fff8fc4

00009868 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60(void)
{
    9868:	b500      	push	{lr}
    986a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    986c:	f7f7 f99e 	bl	bac <Sys_GetCoreID>
    9870:	4603      	mov	r3, r0
    9872:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId])
    9874:	4a10      	ldr	r2, [pc, #64]	; (98b8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x50>)
    9876:	9b01      	ldr	r3, [sp, #4]
    9878:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    987c:	2b00      	cmp	r3, #0
    987e:	d10d      	bne.n	989c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9880:	f7f7 f8b3 	bl	9ea <Gpt_schm_read_msr>
    9884:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9886:	9b00      	ldr	r3, [sp, #0]
    9888:	f003 0301 	and.w	r3, r3, #1
    988c:	2b00      	cmp	r3, #0
    988e:	d100      	bne.n	9892 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9890:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_60[u32CoreId] = msr;
    9892:	490a      	ldr	r1, [pc, #40]	; (98bc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x54>)
    9894:	9b01      	ldr	r3, [sp, #4]
    9896:	9a00      	ldr	r2, [sp, #0]
    9898:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId]++;
    989c:	4a06      	ldr	r2, [pc, #24]	; (98b8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x50>)
    989e:	9b01      	ldr	r3, [sp, #4]
    98a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98a4:	1c5a      	adds	r2, r3, #1
    98a6:	4904      	ldr	r1, [pc, #16]	; (98b8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_60+0x50>)
    98a8:	9b01      	ldr	r3, [sp, #4]
    98aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    98ae:	bf00      	nop
    98b0:	b003      	add	sp, #12
    98b2:	f85d fb04 	ldr.w	pc, [sp], #4
    98b6:	bf00      	nop
    98b8:	1fff8fd0 	.word	0x1fff8fd0
    98bc:	1fff8fcc 	.word	0x1fff8fcc

000098c0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60(void)
{
    98c0:	b500      	push	{lr}
    98c2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    98c4:	f7f7 f972 	bl	bac <Sys_GetCoreID>
    98c8:	4603      	mov	r3, r0
    98ca:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId]--;
    98cc:	4a0d      	ldr	r2, [pc, #52]	; (9904 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x44>)
    98ce:	9b01      	ldr	r3, [sp, #4]
    98d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98d4:	1e5a      	subs	r2, r3, #1
    98d6:	490b      	ldr	r1, [pc, #44]	; (9904 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x44>)
    98d8:	9b01      	ldr	r3, [sp, #4]
    98da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_60[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_60[u32CoreId]))         /*if interrupts were enabled*/
    98de:	4a0a      	ldr	r2, [pc, #40]	; (9908 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x48>)
    98e0:	9b01      	ldr	r3, [sp, #4]
    98e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98e6:	f003 0301 	and.w	r3, r3, #1
    98ea:	2b00      	cmp	r3, #0
    98ec:	d106      	bne.n	98fc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x3c>
    98ee:	4a05      	ldr	r2, [pc, #20]	; (9904 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x44>)
    98f0:	9b01      	ldr	r3, [sp, #4]
    98f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    98f6:	2b00      	cmp	r3, #0
    98f8:	d100      	bne.n	98fc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_60+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    98fa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    98fc:	bf00      	nop
    98fe:	b003      	add	sp, #12
    9900:	f85d fb04 	ldr.w	pc, [sp], #4
    9904:	1fff8fd0 	.word	0x1fff8fd0
    9908:	1fff8fcc 	.word	0x1fff8fcc

0000990c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61(void)
{
    990c:	b500      	push	{lr}
    990e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9910:	f7f7 f94c 	bl	bac <Sys_GetCoreID>
    9914:	4603      	mov	r3, r0
    9916:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId])
    9918:	4a10      	ldr	r2, [pc, #64]	; (995c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x50>)
    991a:	9b01      	ldr	r3, [sp, #4]
    991c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9920:	2b00      	cmp	r3, #0
    9922:	d10d      	bne.n	9940 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9924:	f7f7 f861 	bl	9ea <Gpt_schm_read_msr>
    9928:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    992a:	9b00      	ldr	r3, [sp, #0]
    992c:	f003 0301 	and.w	r3, r3, #1
    9930:	2b00      	cmp	r3, #0
    9932:	d100      	bne.n	9936 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9934:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_61[u32CoreId] = msr;
    9936:	490a      	ldr	r1, [pc, #40]	; (9960 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x54>)
    9938:	9b01      	ldr	r3, [sp, #4]
    993a:	9a00      	ldr	r2, [sp, #0]
    993c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId]++;
    9940:	4a06      	ldr	r2, [pc, #24]	; (995c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x50>)
    9942:	9b01      	ldr	r3, [sp, #4]
    9944:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9948:	1c5a      	adds	r2, r3, #1
    994a:	4904      	ldr	r1, [pc, #16]	; (995c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_61+0x50>)
    994c:	9b01      	ldr	r3, [sp, #4]
    994e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9952:	bf00      	nop
    9954:	b003      	add	sp, #12
    9956:	f85d fb04 	ldr.w	pc, [sp], #4
    995a:	bf00      	nop
    995c:	1fff8fd8 	.word	0x1fff8fd8
    9960:	1fff8fd4 	.word	0x1fff8fd4

00009964 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61(void)
{
    9964:	b500      	push	{lr}
    9966:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9968:	f7f7 f920 	bl	bac <Sys_GetCoreID>
    996c:	4603      	mov	r3, r0
    996e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId]--;
    9970:	4a0d      	ldr	r2, [pc, #52]	; (99a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x44>)
    9972:	9b01      	ldr	r3, [sp, #4]
    9974:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9978:	1e5a      	subs	r2, r3, #1
    997a:	490b      	ldr	r1, [pc, #44]	; (99a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x44>)
    997c:	9b01      	ldr	r3, [sp, #4]
    997e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_61[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_61[u32CoreId]))         /*if interrupts were enabled*/
    9982:	4a0a      	ldr	r2, [pc, #40]	; (99ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x48>)
    9984:	9b01      	ldr	r3, [sp, #4]
    9986:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    998a:	f003 0301 	and.w	r3, r3, #1
    998e:	2b00      	cmp	r3, #0
    9990:	d106      	bne.n	99a0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x3c>
    9992:	4a05      	ldr	r2, [pc, #20]	; (99a8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x44>)
    9994:	9b01      	ldr	r3, [sp, #4]
    9996:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    999a:	2b00      	cmp	r3, #0
    999c:	d100      	bne.n	99a0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_61+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    999e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    99a0:	bf00      	nop
    99a2:	b003      	add	sp, #12
    99a4:	f85d fb04 	ldr.w	pc, [sp], #4
    99a8:	1fff8fd8 	.word	0x1fff8fd8
    99ac:	1fff8fd4 	.word	0x1fff8fd4

000099b0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62(void)
{
    99b0:	b500      	push	{lr}
    99b2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    99b4:	f7f7 f8fa 	bl	bac <Sys_GetCoreID>
    99b8:	4603      	mov	r3, r0
    99ba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId])
    99bc:	4a10      	ldr	r2, [pc, #64]	; (9a00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x50>)
    99be:	9b01      	ldr	r3, [sp, #4]
    99c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99c4:	2b00      	cmp	r3, #0
    99c6:	d10d      	bne.n	99e4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    99c8:	f7f7 f80f 	bl	9ea <Gpt_schm_read_msr>
    99cc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    99ce:	9b00      	ldr	r3, [sp, #0]
    99d0:	f003 0301 	and.w	r3, r3, #1
    99d4:	2b00      	cmp	r3, #0
    99d6:	d100      	bne.n	99da <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    99d8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_62[u32CoreId] = msr;
    99da:	490a      	ldr	r1, [pc, #40]	; (9a04 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x54>)
    99dc:	9b01      	ldr	r3, [sp, #4]
    99de:	9a00      	ldr	r2, [sp, #0]
    99e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId]++;
    99e4:	4a06      	ldr	r2, [pc, #24]	; (9a00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x50>)
    99e6:	9b01      	ldr	r3, [sp, #4]
    99e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99ec:	1c5a      	adds	r2, r3, #1
    99ee:	4904      	ldr	r1, [pc, #16]	; (9a00 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_62+0x50>)
    99f0:	9b01      	ldr	r3, [sp, #4]
    99f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    99f6:	bf00      	nop
    99f8:	b003      	add	sp, #12
    99fa:	f85d fb04 	ldr.w	pc, [sp], #4
    99fe:	bf00      	nop
    9a00:	1fff8fe0 	.word	0x1fff8fe0
    9a04:	1fff8fdc 	.word	0x1fff8fdc

00009a08 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62(void)
{
    9a08:	b500      	push	{lr}
    9a0a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9a0c:	f7f7 f8ce 	bl	bac <Sys_GetCoreID>
    9a10:	4603      	mov	r3, r0
    9a12:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId]--;
    9a14:	4a0d      	ldr	r2, [pc, #52]	; (9a4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x44>)
    9a16:	9b01      	ldr	r3, [sp, #4]
    9a18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a1c:	1e5a      	subs	r2, r3, #1
    9a1e:	490b      	ldr	r1, [pc, #44]	; (9a4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x44>)
    9a20:	9b01      	ldr	r3, [sp, #4]
    9a22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_62[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_62[u32CoreId]))         /*if interrupts were enabled*/
    9a26:	4a0a      	ldr	r2, [pc, #40]	; (9a50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x48>)
    9a28:	9b01      	ldr	r3, [sp, #4]
    9a2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a2e:	f003 0301 	and.w	r3, r3, #1
    9a32:	2b00      	cmp	r3, #0
    9a34:	d106      	bne.n	9a44 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x3c>
    9a36:	4a05      	ldr	r2, [pc, #20]	; (9a4c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x44>)
    9a38:	9b01      	ldr	r3, [sp, #4]
    9a3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a3e:	2b00      	cmp	r3, #0
    9a40:	d100      	bne.n	9a44 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_62+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9a42:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9a44:	bf00      	nop
    9a46:	b003      	add	sp, #12
    9a48:	f85d fb04 	ldr.w	pc, [sp], #4
    9a4c:	1fff8fe0 	.word	0x1fff8fe0
    9a50:	1fff8fdc 	.word	0x1fff8fdc

00009a54 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63(void)
{
    9a54:	b500      	push	{lr}
    9a56:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9a58:	f7f7 f8a8 	bl	bac <Sys_GetCoreID>
    9a5c:	4603      	mov	r3, r0
    9a5e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId])
    9a60:	4a10      	ldr	r2, [pc, #64]	; (9aa4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x50>)
    9a62:	9b01      	ldr	r3, [sp, #4]
    9a64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a68:	2b00      	cmp	r3, #0
    9a6a:	d10d      	bne.n	9a88 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9a6c:	f7f6 ffbd 	bl	9ea <Gpt_schm_read_msr>
    9a70:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9a72:	9b00      	ldr	r3, [sp, #0]
    9a74:	f003 0301 	and.w	r3, r3, #1
    9a78:	2b00      	cmp	r3, #0
    9a7a:	d100      	bne.n	9a7e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9a7c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_63[u32CoreId] = msr;
    9a7e:	490a      	ldr	r1, [pc, #40]	; (9aa8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x54>)
    9a80:	9b01      	ldr	r3, [sp, #4]
    9a82:	9a00      	ldr	r2, [sp, #0]
    9a84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId]++;
    9a88:	4a06      	ldr	r2, [pc, #24]	; (9aa4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x50>)
    9a8a:	9b01      	ldr	r3, [sp, #4]
    9a8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a90:	1c5a      	adds	r2, r3, #1
    9a92:	4904      	ldr	r1, [pc, #16]	; (9aa4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_63+0x50>)
    9a94:	9b01      	ldr	r3, [sp, #4]
    9a96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9a9a:	bf00      	nop
    9a9c:	b003      	add	sp, #12
    9a9e:	f85d fb04 	ldr.w	pc, [sp], #4
    9aa2:	bf00      	nop
    9aa4:	1fff8fe8 	.word	0x1fff8fe8
    9aa8:	1fff8fe4 	.word	0x1fff8fe4

00009aac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63(void)
{
    9aac:	b500      	push	{lr}
    9aae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ab0:	f7f7 f87c 	bl	bac <Sys_GetCoreID>
    9ab4:	4603      	mov	r3, r0
    9ab6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId]--;
    9ab8:	4a0d      	ldr	r2, [pc, #52]	; (9af0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x44>)
    9aba:	9b01      	ldr	r3, [sp, #4]
    9abc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ac0:	1e5a      	subs	r2, r3, #1
    9ac2:	490b      	ldr	r1, [pc, #44]	; (9af0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x44>)
    9ac4:	9b01      	ldr	r3, [sp, #4]
    9ac6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_63[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_63[u32CoreId]))         /*if interrupts were enabled*/
    9aca:	4a0a      	ldr	r2, [pc, #40]	; (9af4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x48>)
    9acc:	9b01      	ldr	r3, [sp, #4]
    9ace:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ad2:	f003 0301 	and.w	r3, r3, #1
    9ad6:	2b00      	cmp	r3, #0
    9ad8:	d106      	bne.n	9ae8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x3c>
    9ada:	4a05      	ldr	r2, [pc, #20]	; (9af0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x44>)
    9adc:	9b01      	ldr	r3, [sp, #4]
    9ade:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ae2:	2b00      	cmp	r3, #0
    9ae4:	d100      	bne.n	9ae8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_63+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9ae6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9ae8:	bf00      	nop
    9aea:	b003      	add	sp, #12
    9aec:	f85d fb04 	ldr.w	pc, [sp], #4
    9af0:	1fff8fe8 	.word	0x1fff8fe8
    9af4:	1fff8fe4 	.word	0x1fff8fe4

00009af8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64(void)
{
    9af8:	b500      	push	{lr}
    9afa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9afc:	f7f7 f856 	bl	bac <Sys_GetCoreID>
    9b00:	4603      	mov	r3, r0
    9b02:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId])
    9b04:	4a10      	ldr	r2, [pc, #64]	; (9b48 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x50>)
    9b06:	9b01      	ldr	r3, [sp, #4]
    9b08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b0c:	2b00      	cmp	r3, #0
    9b0e:	d10d      	bne.n	9b2c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9b10:	f7f6 ff6b 	bl	9ea <Gpt_schm_read_msr>
    9b14:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9b16:	9b00      	ldr	r3, [sp, #0]
    9b18:	f003 0301 	and.w	r3, r3, #1
    9b1c:	2b00      	cmp	r3, #0
    9b1e:	d100      	bne.n	9b22 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9b20:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_64[u32CoreId] = msr;
    9b22:	490a      	ldr	r1, [pc, #40]	; (9b4c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x54>)
    9b24:	9b01      	ldr	r3, [sp, #4]
    9b26:	9a00      	ldr	r2, [sp, #0]
    9b28:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId]++;
    9b2c:	4a06      	ldr	r2, [pc, #24]	; (9b48 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x50>)
    9b2e:	9b01      	ldr	r3, [sp, #4]
    9b30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b34:	1c5a      	adds	r2, r3, #1
    9b36:	4904      	ldr	r1, [pc, #16]	; (9b48 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_64+0x50>)
    9b38:	9b01      	ldr	r3, [sp, #4]
    9b3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9b3e:	bf00      	nop
    9b40:	b003      	add	sp, #12
    9b42:	f85d fb04 	ldr.w	pc, [sp], #4
    9b46:	bf00      	nop
    9b48:	1fff8ff0 	.word	0x1fff8ff0
    9b4c:	1fff8fec 	.word	0x1fff8fec

00009b50 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64(void)
{
    9b50:	b500      	push	{lr}
    9b52:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9b54:	f7f7 f82a 	bl	bac <Sys_GetCoreID>
    9b58:	4603      	mov	r3, r0
    9b5a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId]--;
    9b5c:	4a0d      	ldr	r2, [pc, #52]	; (9b94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x44>)
    9b5e:	9b01      	ldr	r3, [sp, #4]
    9b60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b64:	1e5a      	subs	r2, r3, #1
    9b66:	490b      	ldr	r1, [pc, #44]	; (9b94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x44>)
    9b68:	9b01      	ldr	r3, [sp, #4]
    9b6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_64[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_64[u32CoreId]))         /*if interrupts were enabled*/
    9b6e:	4a0a      	ldr	r2, [pc, #40]	; (9b98 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x48>)
    9b70:	9b01      	ldr	r3, [sp, #4]
    9b72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b76:	f003 0301 	and.w	r3, r3, #1
    9b7a:	2b00      	cmp	r3, #0
    9b7c:	d106      	bne.n	9b8c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x3c>
    9b7e:	4a05      	ldr	r2, [pc, #20]	; (9b94 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x44>)
    9b80:	9b01      	ldr	r3, [sp, #4]
    9b82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b86:	2b00      	cmp	r3, #0
    9b88:	d100      	bne.n	9b8c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_64+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9b8a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9b8c:	bf00      	nop
    9b8e:	b003      	add	sp, #12
    9b90:	f85d fb04 	ldr.w	pc, [sp], #4
    9b94:	1fff8ff0 	.word	0x1fff8ff0
    9b98:	1fff8fec 	.word	0x1fff8fec

00009b9c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65(void)
{
    9b9c:	b500      	push	{lr}
    9b9e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ba0:	f7f7 f804 	bl	bac <Sys_GetCoreID>
    9ba4:	4603      	mov	r3, r0
    9ba6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId])
    9ba8:	4a10      	ldr	r2, [pc, #64]	; (9bec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x50>)
    9baa:	9b01      	ldr	r3, [sp, #4]
    9bac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bb0:	2b00      	cmp	r3, #0
    9bb2:	d10d      	bne.n	9bd0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9bb4:	f7f6 ff19 	bl	9ea <Gpt_schm_read_msr>
    9bb8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9bba:	9b00      	ldr	r3, [sp, #0]
    9bbc:	f003 0301 	and.w	r3, r3, #1
    9bc0:	2b00      	cmp	r3, #0
    9bc2:	d100      	bne.n	9bc6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9bc4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_65[u32CoreId] = msr;
    9bc6:	490a      	ldr	r1, [pc, #40]	; (9bf0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x54>)
    9bc8:	9b01      	ldr	r3, [sp, #4]
    9bca:	9a00      	ldr	r2, [sp, #0]
    9bcc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId]++;
    9bd0:	4a06      	ldr	r2, [pc, #24]	; (9bec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x50>)
    9bd2:	9b01      	ldr	r3, [sp, #4]
    9bd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bd8:	1c5a      	adds	r2, r3, #1
    9bda:	4904      	ldr	r1, [pc, #16]	; (9bec <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_65+0x50>)
    9bdc:	9b01      	ldr	r3, [sp, #4]
    9bde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9be2:	bf00      	nop
    9be4:	b003      	add	sp, #12
    9be6:	f85d fb04 	ldr.w	pc, [sp], #4
    9bea:	bf00      	nop
    9bec:	1fff8ff8 	.word	0x1fff8ff8
    9bf0:	1fff8ff4 	.word	0x1fff8ff4

00009bf4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65(void)
{
    9bf4:	b500      	push	{lr}
    9bf6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9bf8:	f7f6 ffd8 	bl	bac <Sys_GetCoreID>
    9bfc:	4603      	mov	r3, r0
    9bfe:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId]--;
    9c00:	4a0d      	ldr	r2, [pc, #52]	; (9c38 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x44>)
    9c02:	9b01      	ldr	r3, [sp, #4]
    9c04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c08:	1e5a      	subs	r2, r3, #1
    9c0a:	490b      	ldr	r1, [pc, #44]	; (9c38 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x44>)
    9c0c:	9b01      	ldr	r3, [sp, #4]
    9c0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_65[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_65[u32CoreId]))         /*if interrupts were enabled*/
    9c12:	4a0a      	ldr	r2, [pc, #40]	; (9c3c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x48>)
    9c14:	9b01      	ldr	r3, [sp, #4]
    9c16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c1a:	f003 0301 	and.w	r3, r3, #1
    9c1e:	2b00      	cmp	r3, #0
    9c20:	d106      	bne.n	9c30 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x3c>
    9c22:	4a05      	ldr	r2, [pc, #20]	; (9c38 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x44>)
    9c24:	9b01      	ldr	r3, [sp, #4]
    9c26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c2a:	2b00      	cmp	r3, #0
    9c2c:	d100      	bne.n	9c30 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_65+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9c2e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9c30:	bf00      	nop
    9c32:	b003      	add	sp, #12
    9c34:	f85d fb04 	ldr.w	pc, [sp], #4
    9c38:	1fff8ff8 	.word	0x1fff8ff8
    9c3c:	1fff8ff4 	.word	0x1fff8ff4

00009c40 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66(void)
{
    9c40:	b500      	push	{lr}
    9c42:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9c44:	f7f6 ffb2 	bl	bac <Sys_GetCoreID>
    9c48:	4603      	mov	r3, r0
    9c4a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId])
    9c4c:	4a10      	ldr	r2, [pc, #64]	; (9c90 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x50>)
    9c4e:	9b01      	ldr	r3, [sp, #4]
    9c50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c54:	2b00      	cmp	r3, #0
    9c56:	d10d      	bne.n	9c74 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9c58:	f7f6 fec7 	bl	9ea <Gpt_schm_read_msr>
    9c5c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9c5e:	9b00      	ldr	r3, [sp, #0]
    9c60:	f003 0301 	and.w	r3, r3, #1
    9c64:	2b00      	cmp	r3, #0
    9c66:	d100      	bne.n	9c6a <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9c68:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_66[u32CoreId] = msr;
    9c6a:	490a      	ldr	r1, [pc, #40]	; (9c94 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x54>)
    9c6c:	9b01      	ldr	r3, [sp, #4]
    9c6e:	9a00      	ldr	r2, [sp, #0]
    9c70:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId]++;
    9c74:	4a06      	ldr	r2, [pc, #24]	; (9c90 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x50>)
    9c76:	9b01      	ldr	r3, [sp, #4]
    9c78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c7c:	1c5a      	adds	r2, r3, #1
    9c7e:	4904      	ldr	r1, [pc, #16]	; (9c90 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_66+0x50>)
    9c80:	9b01      	ldr	r3, [sp, #4]
    9c82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9c86:	bf00      	nop
    9c88:	b003      	add	sp, #12
    9c8a:	f85d fb04 	ldr.w	pc, [sp], #4
    9c8e:	bf00      	nop
    9c90:	1fff9000 	.word	0x1fff9000
    9c94:	1fff8ffc 	.word	0x1fff8ffc

00009c98 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66(void)
{
    9c98:	b500      	push	{lr}
    9c9a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9c9c:	f7f6 ff86 	bl	bac <Sys_GetCoreID>
    9ca0:	4603      	mov	r3, r0
    9ca2:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId]--;
    9ca4:	4a0d      	ldr	r2, [pc, #52]	; (9cdc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x44>)
    9ca6:	9b01      	ldr	r3, [sp, #4]
    9ca8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cac:	1e5a      	subs	r2, r3, #1
    9cae:	490b      	ldr	r1, [pc, #44]	; (9cdc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x44>)
    9cb0:	9b01      	ldr	r3, [sp, #4]
    9cb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_66[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_66[u32CoreId]))         /*if interrupts were enabled*/
    9cb6:	4a0a      	ldr	r2, [pc, #40]	; (9ce0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x48>)
    9cb8:	9b01      	ldr	r3, [sp, #4]
    9cba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cbe:	f003 0301 	and.w	r3, r3, #1
    9cc2:	2b00      	cmp	r3, #0
    9cc4:	d106      	bne.n	9cd4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x3c>
    9cc6:	4a05      	ldr	r2, [pc, #20]	; (9cdc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x44>)
    9cc8:	9b01      	ldr	r3, [sp, #4]
    9cca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cce:	2b00      	cmp	r3, #0
    9cd0:	d100      	bne.n	9cd4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_66+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9cd2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9cd4:	bf00      	nop
    9cd6:	b003      	add	sp, #12
    9cd8:	f85d fb04 	ldr.w	pc, [sp], #4
    9cdc:	1fff9000 	.word	0x1fff9000
    9ce0:	1fff8ffc 	.word	0x1fff8ffc

00009ce4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67(void)
{
    9ce4:	b500      	push	{lr}
    9ce6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ce8:	f7f6 ff60 	bl	bac <Sys_GetCoreID>
    9cec:	4603      	mov	r3, r0
    9cee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId])
    9cf0:	4a10      	ldr	r2, [pc, #64]	; (9d34 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x50>)
    9cf2:	9b01      	ldr	r3, [sp, #4]
    9cf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cf8:	2b00      	cmp	r3, #0
    9cfa:	d10d      	bne.n	9d18 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9cfc:	f7f6 fe75 	bl	9ea <Gpt_schm_read_msr>
    9d00:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9d02:	9b00      	ldr	r3, [sp, #0]
    9d04:	f003 0301 	and.w	r3, r3, #1
    9d08:	2b00      	cmp	r3, #0
    9d0a:	d100      	bne.n	9d0e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9d0c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_67[u32CoreId] = msr;
    9d0e:	490a      	ldr	r1, [pc, #40]	; (9d38 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x54>)
    9d10:	9b01      	ldr	r3, [sp, #4]
    9d12:	9a00      	ldr	r2, [sp, #0]
    9d14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId]++;
    9d18:	4a06      	ldr	r2, [pc, #24]	; (9d34 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x50>)
    9d1a:	9b01      	ldr	r3, [sp, #4]
    9d1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d20:	1c5a      	adds	r2, r3, #1
    9d22:	4904      	ldr	r1, [pc, #16]	; (9d34 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_67+0x50>)
    9d24:	9b01      	ldr	r3, [sp, #4]
    9d26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9d2a:	bf00      	nop
    9d2c:	b003      	add	sp, #12
    9d2e:	f85d fb04 	ldr.w	pc, [sp], #4
    9d32:	bf00      	nop
    9d34:	1fff9008 	.word	0x1fff9008
    9d38:	1fff9004 	.word	0x1fff9004

00009d3c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67(void)
{
    9d3c:	b500      	push	{lr}
    9d3e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9d40:	f7f6 ff34 	bl	bac <Sys_GetCoreID>
    9d44:	4603      	mov	r3, r0
    9d46:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId]--;
    9d48:	4a0d      	ldr	r2, [pc, #52]	; (9d80 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x44>)
    9d4a:	9b01      	ldr	r3, [sp, #4]
    9d4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d50:	1e5a      	subs	r2, r3, #1
    9d52:	490b      	ldr	r1, [pc, #44]	; (9d80 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x44>)
    9d54:	9b01      	ldr	r3, [sp, #4]
    9d56:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_67[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_67[u32CoreId]))         /*if interrupts were enabled*/
    9d5a:	4a0a      	ldr	r2, [pc, #40]	; (9d84 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x48>)
    9d5c:	9b01      	ldr	r3, [sp, #4]
    9d5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d62:	f003 0301 	and.w	r3, r3, #1
    9d66:	2b00      	cmp	r3, #0
    9d68:	d106      	bne.n	9d78 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x3c>
    9d6a:	4a05      	ldr	r2, [pc, #20]	; (9d80 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x44>)
    9d6c:	9b01      	ldr	r3, [sp, #4]
    9d6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d72:	2b00      	cmp	r3, #0
    9d74:	d100      	bne.n	9d78 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_67+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9d76:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9d78:	bf00      	nop
    9d7a:	b003      	add	sp, #12
    9d7c:	f85d fb04 	ldr.w	pc, [sp], #4
    9d80:	1fff9008 	.word	0x1fff9008
    9d84:	1fff9004 	.word	0x1fff9004

00009d88 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68(void)
{
    9d88:	b500      	push	{lr}
    9d8a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9d8c:	f7f6 ff0e 	bl	bac <Sys_GetCoreID>
    9d90:	4603      	mov	r3, r0
    9d92:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId])
    9d94:	4a10      	ldr	r2, [pc, #64]	; (9dd8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x50>)
    9d96:	9b01      	ldr	r3, [sp, #4]
    9d98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d9c:	2b00      	cmp	r3, #0
    9d9e:	d10d      	bne.n	9dbc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9da0:	f7f6 fe23 	bl	9ea <Gpt_schm_read_msr>
    9da4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9da6:	9b00      	ldr	r3, [sp, #0]
    9da8:	f003 0301 	and.w	r3, r3, #1
    9dac:	2b00      	cmp	r3, #0
    9dae:	d100      	bne.n	9db2 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9db0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_68[u32CoreId] = msr;
    9db2:	490a      	ldr	r1, [pc, #40]	; (9ddc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x54>)
    9db4:	9b01      	ldr	r3, [sp, #4]
    9db6:	9a00      	ldr	r2, [sp, #0]
    9db8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId]++;
    9dbc:	4a06      	ldr	r2, [pc, #24]	; (9dd8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x50>)
    9dbe:	9b01      	ldr	r3, [sp, #4]
    9dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9dc4:	1c5a      	adds	r2, r3, #1
    9dc6:	4904      	ldr	r1, [pc, #16]	; (9dd8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_68+0x50>)
    9dc8:	9b01      	ldr	r3, [sp, #4]
    9dca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9dce:	bf00      	nop
    9dd0:	b003      	add	sp, #12
    9dd2:	f85d fb04 	ldr.w	pc, [sp], #4
    9dd6:	bf00      	nop
    9dd8:	1fff9010 	.word	0x1fff9010
    9ddc:	1fff900c 	.word	0x1fff900c

00009de0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68(void)
{
    9de0:	b500      	push	{lr}
    9de2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9de4:	f7f6 fee2 	bl	bac <Sys_GetCoreID>
    9de8:	4603      	mov	r3, r0
    9dea:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId]--;
    9dec:	4a0d      	ldr	r2, [pc, #52]	; (9e24 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x44>)
    9dee:	9b01      	ldr	r3, [sp, #4]
    9df0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9df4:	1e5a      	subs	r2, r3, #1
    9df6:	490b      	ldr	r1, [pc, #44]	; (9e24 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x44>)
    9df8:	9b01      	ldr	r3, [sp, #4]
    9dfa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_68[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_68[u32CoreId]))         /*if interrupts were enabled*/
    9dfe:	4a0a      	ldr	r2, [pc, #40]	; (9e28 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x48>)
    9e00:	9b01      	ldr	r3, [sp, #4]
    9e02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e06:	f003 0301 	and.w	r3, r3, #1
    9e0a:	2b00      	cmp	r3, #0
    9e0c:	d106      	bne.n	9e1c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x3c>
    9e0e:	4a05      	ldr	r2, [pc, #20]	; (9e24 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x44>)
    9e10:	9b01      	ldr	r3, [sp, #4]
    9e12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e16:	2b00      	cmp	r3, #0
    9e18:	d100      	bne.n	9e1c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_68+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9e1a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9e1c:	bf00      	nop
    9e1e:	b003      	add	sp, #12
    9e20:	f85d fb04 	ldr.w	pc, [sp], #4
    9e24:	1fff9010 	.word	0x1fff9010
    9e28:	1fff900c 	.word	0x1fff900c

00009e2c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69(void)
{
    9e2c:	b500      	push	{lr}
    9e2e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9e30:	f7f6 febc 	bl	bac <Sys_GetCoreID>
    9e34:	4603      	mov	r3, r0
    9e36:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId])
    9e38:	4a10      	ldr	r2, [pc, #64]	; (9e7c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x50>)
    9e3a:	9b01      	ldr	r3, [sp, #4]
    9e3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e40:	2b00      	cmp	r3, #0
    9e42:	d10d      	bne.n	9e60 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9e44:	f7f6 fdd1 	bl	9ea <Gpt_schm_read_msr>
    9e48:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9e4a:	9b00      	ldr	r3, [sp, #0]
    9e4c:	f003 0301 	and.w	r3, r3, #1
    9e50:	2b00      	cmp	r3, #0
    9e52:	d100      	bne.n	9e56 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9e54:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_69[u32CoreId] = msr;
    9e56:	490a      	ldr	r1, [pc, #40]	; (9e80 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x54>)
    9e58:	9b01      	ldr	r3, [sp, #4]
    9e5a:	9a00      	ldr	r2, [sp, #0]
    9e5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId]++;
    9e60:	4a06      	ldr	r2, [pc, #24]	; (9e7c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x50>)
    9e62:	9b01      	ldr	r3, [sp, #4]
    9e64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e68:	1c5a      	adds	r2, r3, #1
    9e6a:	4904      	ldr	r1, [pc, #16]	; (9e7c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_69+0x50>)
    9e6c:	9b01      	ldr	r3, [sp, #4]
    9e6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9e72:	bf00      	nop
    9e74:	b003      	add	sp, #12
    9e76:	f85d fb04 	ldr.w	pc, [sp], #4
    9e7a:	bf00      	nop
    9e7c:	1fff9018 	.word	0x1fff9018
    9e80:	1fff9014 	.word	0x1fff9014

00009e84 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69(void)
{
    9e84:	b500      	push	{lr}
    9e86:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9e88:	f7f6 fe90 	bl	bac <Sys_GetCoreID>
    9e8c:	4603      	mov	r3, r0
    9e8e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId]--;
    9e90:	4a0d      	ldr	r2, [pc, #52]	; (9ec8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x44>)
    9e92:	9b01      	ldr	r3, [sp, #4]
    9e94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9e98:	1e5a      	subs	r2, r3, #1
    9e9a:	490b      	ldr	r1, [pc, #44]	; (9ec8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x44>)
    9e9c:	9b01      	ldr	r3, [sp, #4]
    9e9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_69[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_69[u32CoreId]))         /*if interrupts were enabled*/
    9ea2:	4a0a      	ldr	r2, [pc, #40]	; (9ecc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x48>)
    9ea4:	9b01      	ldr	r3, [sp, #4]
    9ea6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9eaa:	f003 0301 	and.w	r3, r3, #1
    9eae:	2b00      	cmp	r3, #0
    9eb0:	d106      	bne.n	9ec0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x3c>
    9eb2:	4a05      	ldr	r2, [pc, #20]	; (9ec8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x44>)
    9eb4:	9b01      	ldr	r3, [sp, #4]
    9eb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9eba:	2b00      	cmp	r3, #0
    9ebc:	d100      	bne.n	9ec0 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_69+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9ebe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9ec0:	bf00      	nop
    9ec2:	b003      	add	sp, #12
    9ec4:	f85d fb04 	ldr.w	pc, [sp], #4
    9ec8:	1fff9018 	.word	0x1fff9018
    9ecc:	1fff9014 	.word	0x1fff9014

00009ed0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70(void)
{
    9ed0:	b500      	push	{lr}
    9ed2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9ed4:	f7f6 fe6a 	bl	bac <Sys_GetCoreID>
    9ed8:	4603      	mov	r3, r0
    9eda:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId])
    9edc:	4a10      	ldr	r2, [pc, #64]	; (9f20 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x50>)
    9ede:	9b01      	ldr	r3, [sp, #4]
    9ee0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ee4:	2b00      	cmp	r3, #0
    9ee6:	d10d      	bne.n	9f04 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9ee8:	f7f6 fd7f 	bl	9ea <Gpt_schm_read_msr>
    9eec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9eee:	9b00      	ldr	r3, [sp, #0]
    9ef0:	f003 0301 	and.w	r3, r3, #1
    9ef4:	2b00      	cmp	r3, #0
    9ef6:	d100      	bne.n	9efa <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9ef8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_70[u32CoreId] = msr;
    9efa:	490a      	ldr	r1, [pc, #40]	; (9f24 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x54>)
    9efc:	9b01      	ldr	r3, [sp, #4]
    9efe:	9a00      	ldr	r2, [sp, #0]
    9f00:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId]++;
    9f04:	4a06      	ldr	r2, [pc, #24]	; (9f20 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x50>)
    9f06:	9b01      	ldr	r3, [sp, #4]
    9f08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f0c:	1c5a      	adds	r2, r3, #1
    9f0e:	4904      	ldr	r1, [pc, #16]	; (9f20 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_70+0x50>)
    9f10:	9b01      	ldr	r3, [sp, #4]
    9f12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9f16:	bf00      	nop
    9f18:	b003      	add	sp, #12
    9f1a:	f85d fb04 	ldr.w	pc, [sp], #4
    9f1e:	bf00      	nop
    9f20:	1fff9020 	.word	0x1fff9020
    9f24:	1fff901c 	.word	0x1fff901c

00009f28 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70(void)
{
    9f28:	b500      	push	{lr}
    9f2a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9f2c:	f7f6 fe3e 	bl	bac <Sys_GetCoreID>
    9f30:	4603      	mov	r3, r0
    9f32:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId]--;
    9f34:	4a0d      	ldr	r2, [pc, #52]	; (9f6c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x44>)
    9f36:	9b01      	ldr	r3, [sp, #4]
    9f38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f3c:	1e5a      	subs	r2, r3, #1
    9f3e:	490b      	ldr	r1, [pc, #44]	; (9f6c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x44>)
    9f40:	9b01      	ldr	r3, [sp, #4]
    9f42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_70[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_70[u32CoreId]))         /*if interrupts were enabled*/
    9f46:	4a0a      	ldr	r2, [pc, #40]	; (9f70 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x48>)
    9f48:	9b01      	ldr	r3, [sp, #4]
    9f4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f4e:	f003 0301 	and.w	r3, r3, #1
    9f52:	2b00      	cmp	r3, #0
    9f54:	d106      	bne.n	9f64 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x3c>
    9f56:	4a05      	ldr	r2, [pc, #20]	; (9f6c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x44>)
    9f58:	9b01      	ldr	r3, [sp, #4]
    9f5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f5e:	2b00      	cmp	r3, #0
    9f60:	d100      	bne.n	9f64 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_70+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    9f62:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    9f64:	bf00      	nop
    9f66:	b003      	add	sp, #12
    9f68:	f85d fb04 	ldr.w	pc, [sp], #4
    9f6c:	1fff9020 	.word	0x1fff9020
    9f70:	1fff901c 	.word	0x1fff901c

00009f74 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71(void)
{
    9f74:	b500      	push	{lr}
    9f76:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9f78:	f7f6 fe18 	bl	bac <Sys_GetCoreID>
    9f7c:	4603      	mov	r3, r0
    9f7e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId])
    9f80:	4a10      	ldr	r2, [pc, #64]	; (9fc4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x50>)
    9f82:	9b01      	ldr	r3, [sp, #4]
    9f84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f88:	2b00      	cmp	r3, #0
    9f8a:	d10d      	bne.n	9fa8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    9f8c:	f7f6 fd2d 	bl	9ea <Gpt_schm_read_msr>
    9f90:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    9f92:	9b00      	ldr	r3, [sp, #0]
    9f94:	f003 0301 	and.w	r3, r3, #1
    9f98:	2b00      	cmp	r3, #0
    9f9a:	d100      	bne.n	9f9e <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    9f9c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_71[u32CoreId] = msr;
    9f9e:	490a      	ldr	r1, [pc, #40]	; (9fc8 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x54>)
    9fa0:	9b01      	ldr	r3, [sp, #4]
    9fa2:	9a00      	ldr	r2, [sp, #0]
    9fa4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId]++;
    9fa8:	4a06      	ldr	r2, [pc, #24]	; (9fc4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x50>)
    9faa:	9b01      	ldr	r3, [sp, #4]
    9fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9fb0:	1c5a      	adds	r2, r3, #1
    9fb2:	4904      	ldr	r1, [pc, #16]	; (9fc4 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_71+0x50>)
    9fb4:	9b01      	ldr	r3, [sp, #4]
    9fb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    9fba:	bf00      	nop
    9fbc:	b003      	add	sp, #12
    9fbe:	f85d fb04 	ldr.w	pc, [sp], #4
    9fc2:	bf00      	nop
    9fc4:	1fff9028 	.word	0x1fff9028
    9fc8:	1fff9024 	.word	0x1fff9024

00009fcc <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71(void)
{
    9fcc:	b500      	push	{lr}
    9fce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    9fd0:	f7f6 fdec 	bl	bac <Sys_GetCoreID>
    9fd4:	4603      	mov	r3, r0
    9fd6:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId]--;
    9fd8:	4a0d      	ldr	r2, [pc, #52]	; (a010 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x44>)
    9fda:	9b01      	ldr	r3, [sp, #4]
    9fdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9fe0:	1e5a      	subs	r2, r3, #1
    9fe2:	490b      	ldr	r1, [pc, #44]	; (a010 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x44>)
    9fe4:	9b01      	ldr	r3, [sp, #4]
    9fe6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_71[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_71[u32CoreId]))         /*if interrupts were enabled*/
    9fea:	4a0a      	ldr	r2, [pc, #40]	; (a014 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x48>)
    9fec:	9b01      	ldr	r3, [sp, #4]
    9fee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ff2:	f003 0301 	and.w	r3, r3, #1
    9ff6:	2b00      	cmp	r3, #0
    9ff8:	d106      	bne.n	a008 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x3c>
    9ffa:	4a05      	ldr	r2, [pc, #20]	; (a010 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x44>)
    9ffc:	9b01      	ldr	r3, [sp, #4]
    9ffe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a002:	2b00      	cmp	r3, #0
    a004:	d100      	bne.n	a008 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_71+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a006:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a008:	bf00      	nop
    a00a:	b003      	add	sp, #12
    a00c:	f85d fb04 	ldr.w	pc, [sp], #4
    a010:	1fff9028 	.word	0x1fff9028
    a014:	1fff9024 	.word	0x1fff9024

0000a018 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72(void)
{
    a018:	b500      	push	{lr}
    a01a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a01c:	f7f6 fdc6 	bl	bac <Sys_GetCoreID>
    a020:	4603      	mov	r3, r0
    a022:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId])
    a024:	4a10      	ldr	r2, [pc, #64]	; (a068 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x50>)
    a026:	9b01      	ldr	r3, [sp, #4]
    a028:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a02c:	2b00      	cmp	r3, #0
    a02e:	d10d      	bne.n	a04c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a030:	f7f6 fcdb 	bl	9ea <Gpt_schm_read_msr>
    a034:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a036:	9b00      	ldr	r3, [sp, #0]
    a038:	f003 0301 	and.w	r3, r3, #1
    a03c:	2b00      	cmp	r3, #0
    a03e:	d100      	bne.n	a042 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a040:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_72[u32CoreId] = msr;
    a042:	490a      	ldr	r1, [pc, #40]	; (a06c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x54>)
    a044:	9b01      	ldr	r3, [sp, #4]
    a046:	9a00      	ldr	r2, [sp, #0]
    a048:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId]++;
    a04c:	4a06      	ldr	r2, [pc, #24]	; (a068 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x50>)
    a04e:	9b01      	ldr	r3, [sp, #4]
    a050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a054:	1c5a      	adds	r2, r3, #1
    a056:	4904      	ldr	r1, [pc, #16]	; (a068 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_72+0x50>)
    a058:	9b01      	ldr	r3, [sp, #4]
    a05a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a05e:	bf00      	nop
    a060:	b003      	add	sp, #12
    a062:	f85d fb04 	ldr.w	pc, [sp], #4
    a066:	bf00      	nop
    a068:	1fff9030 	.word	0x1fff9030
    a06c:	1fff902c 	.word	0x1fff902c

0000a070 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72(void)
{
    a070:	b500      	push	{lr}
    a072:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a074:	f7f6 fd9a 	bl	bac <Sys_GetCoreID>
    a078:	4603      	mov	r3, r0
    a07a:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId]--;
    a07c:	4a0d      	ldr	r2, [pc, #52]	; (a0b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x44>)
    a07e:	9b01      	ldr	r3, [sp, #4]
    a080:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a084:	1e5a      	subs	r2, r3, #1
    a086:	490b      	ldr	r1, [pc, #44]	; (a0b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x44>)
    a088:	9b01      	ldr	r3, [sp, #4]
    a08a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_72[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_72[u32CoreId]))         /*if interrupts were enabled*/
    a08e:	4a0a      	ldr	r2, [pc, #40]	; (a0b8 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x48>)
    a090:	9b01      	ldr	r3, [sp, #4]
    a092:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a096:	f003 0301 	and.w	r3, r3, #1
    a09a:	2b00      	cmp	r3, #0
    a09c:	d106      	bne.n	a0ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x3c>
    a09e:	4a05      	ldr	r2, [pc, #20]	; (a0b4 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x44>)
    a0a0:	9b01      	ldr	r3, [sp, #4]
    a0a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0a6:	2b00      	cmp	r3, #0
    a0a8:	d100      	bne.n	a0ac <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_72+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a0aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a0ac:	bf00      	nop
    a0ae:	b003      	add	sp, #12
    a0b0:	f85d fb04 	ldr.w	pc, [sp], #4
    a0b4:	1fff9030 	.word	0x1fff9030
    a0b8:	1fff902c 	.word	0x1fff902c

0000a0bc <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73>:

void SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73(void)
{
    a0bc:	b500      	push	{lr}
    a0be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a0c0:	f7f6 fd74 	bl	bac <Sys_GetCoreID>
    a0c4:	4603      	mov	r3, r0
    a0c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId])
    a0c8:	4a10      	ldr	r2, [pc, #64]	; (a10c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x50>)
    a0ca:	9b01      	ldr	r3, [sp, #4]
    a0cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0d0:	2b00      	cmp	r3, #0
    a0d2:	d10d      	bne.n	a0f0 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Gpt_schm_read_msr);
#else
        msr = Gpt_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a0d4:	f7f6 fc89 	bl	9ea <Gpt_schm_read_msr>
    a0d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a0da:	9b00      	ldr	r3, [sp, #0]
    a0dc:	f003 0301 	and.w	r3, r3, #1
    a0e0:	2b00      	cmp	r3, #0
    a0e2:	d100      	bne.n	a0e6 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a0e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_GPT_EXCLUSIVE_AREA_73[u32CoreId] = msr;
    a0e6:	490a      	ldr	r1, [pc, #40]	; (a110 <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x54>)
    a0e8:	9b01      	ldr	r3, [sp, #4]
    a0ea:	9a00      	ldr	r2, [sp, #0]
    a0ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId]++;
    a0f0:	4a06      	ldr	r2, [pc, #24]	; (a10c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x50>)
    a0f2:	9b01      	ldr	r3, [sp, #4]
    a0f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a0f8:	1c5a      	adds	r2, r3, #1
    a0fa:	4904      	ldr	r1, [pc, #16]	; (a10c <SchM_Enter_Gpt_GPT_EXCLUSIVE_AREA_73+0x50>)
    a0fc:	9b01      	ldr	r3, [sp, #4]
    a0fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a102:	bf00      	nop
    a104:	b003      	add	sp, #12
    a106:	f85d fb04 	ldr.w	pc, [sp], #4
    a10a:	bf00      	nop
    a10c:	1fff9038 	.word	0x1fff9038
    a110:	1fff9034 	.word	0x1fff9034

0000a114 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73>:

void SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73(void)
{
    a114:	b500      	push	{lr}
    a116:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a118:	f7f6 fd48 	bl	bac <Sys_GetCoreID>
    a11c:	4603      	mov	r3, r0
    a11e:	9301      	str	r3, [sp, #4]

    reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId]--;
    a120:	4a0d      	ldr	r2, [pc, #52]	; (a158 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x44>)
    a122:	9b01      	ldr	r3, [sp, #4]
    a124:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a128:	1e5a      	subs	r2, r3, #1
    a12a:	490b      	ldr	r1, [pc, #44]	; (a158 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x44>)
    a12c:	9b01      	ldr	r3, [sp, #4]
    a12e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_GPT_EXCLUSIVE_AREA_73[u32CoreId]))&&(0UL == reentry_guard_GPT_EXCLUSIVE_AREA_73[u32CoreId]))         /*if interrupts were enabled*/
    a132:	4a0a      	ldr	r2, [pc, #40]	; (a15c <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x48>)
    a134:	9b01      	ldr	r3, [sp, #4]
    a136:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a13a:	f003 0301 	and.w	r3, r3, #1
    a13e:	2b00      	cmp	r3, #0
    a140:	d106      	bne.n	a150 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x3c>
    a142:	4a05      	ldr	r2, [pc, #20]	; (a158 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x44>)
    a144:	9b01      	ldr	r3, [sp, #4]
    a146:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a14a:	2b00      	cmp	r3, #0
    a14c:	d100      	bne.n	a150 <SchM_Exit_Gpt_GPT_EXCLUSIVE_AREA_73+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a14e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a150:	bf00      	nop
    a152:	b003      	add	sp, #12
    a154:	f85d fb04 	ldr.w	pc, [sp], #4
    a158:	1fff9038 	.word	0x1fff9038
    a15c:	1fff9034 	.word	0x1fff9034

0000a160 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    a160:	b500      	push	{lr}
    a162:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a164:	f7f6 fd22 	bl	bac <Sys_GetCoreID>
    a168:	4603      	mov	r3, r0
    a16a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
    a16c:	4a10      	ldr	r2, [pc, #64]	; (a1b0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    a16e:	9b01      	ldr	r3, [sp, #4]
    a170:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a174:	2b00      	cmp	r3, #0
    a176:	d10d      	bne.n	a194 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a178:	f7f6 fc40 	bl	9fc <Mcu_schm_read_msr>
    a17c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a17e:	9b00      	ldr	r3, [sp, #0]
    a180:	f003 0301 	and.w	r3, r3, #1
    a184:	2b00      	cmp	r3, #0
    a186:	d100      	bne.n	a18a <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a188:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    a18a:	490a      	ldr	r1, [pc, #40]	; (a1b4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
    a18c:	9b01      	ldr	r3, [sp, #4]
    a18e:	9a00      	ldr	r2, [sp, #0]
    a190:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
    a194:	4a06      	ldr	r2, [pc, #24]	; (a1b0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    a196:	9b01      	ldr	r3, [sp, #4]
    a198:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a19c:	1c5a      	adds	r2, r3, #1
    a19e:	4904      	ldr	r1, [pc, #16]	; (a1b0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
    a1a0:	9b01      	ldr	r3, [sp, #4]
    a1a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a1a6:	bf00      	nop
    a1a8:	b003      	add	sp, #12
    a1aa:	f85d fb04 	ldr.w	pc, [sp], #4
    a1ae:	bf00      	nop
    a1b0:	1fff9040 	.word	0x1fff9040
    a1b4:	1fff903c 	.word	0x1fff903c

0000a1b8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
    a1b8:	b500      	push	{lr}
    a1ba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a1bc:	f7f6 fcf6 	bl	bac <Sys_GetCoreID>
    a1c0:	4603      	mov	r3, r0
    a1c2:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
    a1c4:	4a0d      	ldr	r2, [pc, #52]	; (a1fc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    a1c6:	9b01      	ldr	r3, [sp, #4]
    a1c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1cc:	1e5a      	subs	r2, r3, #1
    a1ce:	490b      	ldr	r1, [pc, #44]	; (a1fc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    a1d0:	9b01      	ldr	r3, [sp, #4]
    a1d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    a1d6:	4a0a      	ldr	r2, [pc, #40]	; (a200 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
    a1d8:	9b01      	ldr	r3, [sp, #4]
    a1da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1de:	f003 0301 	and.w	r3, r3, #1
    a1e2:	2b00      	cmp	r3, #0
    a1e4:	d106      	bne.n	a1f4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    a1e6:	4a05      	ldr	r2, [pc, #20]	; (a1fc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
    a1e8:	9b01      	ldr	r3, [sp, #4]
    a1ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1ee:	2b00      	cmp	r3, #0
    a1f0:	d100      	bne.n	a1f4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a1f2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a1f4:	bf00      	nop
    a1f6:	b003      	add	sp, #12
    a1f8:	f85d fb04 	ldr.w	pc, [sp], #4
    a1fc:	1fff9040 	.word	0x1fff9040
    a200:	1fff903c 	.word	0x1fff903c

0000a204 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    a204:	b500      	push	{lr}
    a206:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a208:	f7f6 fcd0 	bl	bac <Sys_GetCoreID>
    a20c:	4603      	mov	r3, r0
    a20e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
    a210:	4a10      	ldr	r2, [pc, #64]	; (a254 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    a212:	9b01      	ldr	r3, [sp, #4]
    a214:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a218:	2b00      	cmp	r3, #0
    a21a:	d10d      	bne.n	a238 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a21c:	f7f6 fbee 	bl	9fc <Mcu_schm_read_msr>
    a220:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a222:	9b00      	ldr	r3, [sp, #0]
    a224:	f003 0301 	and.w	r3, r3, #1
    a228:	2b00      	cmp	r3, #0
    a22a:	d100      	bne.n	a22e <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a22c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    a22e:	490a      	ldr	r1, [pc, #40]	; (a258 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
    a230:	9b01      	ldr	r3, [sp, #4]
    a232:	9a00      	ldr	r2, [sp, #0]
    a234:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
    a238:	4a06      	ldr	r2, [pc, #24]	; (a254 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    a23a:	9b01      	ldr	r3, [sp, #4]
    a23c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a240:	1c5a      	adds	r2, r3, #1
    a242:	4904      	ldr	r1, [pc, #16]	; (a254 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
    a244:	9b01      	ldr	r3, [sp, #4]
    a246:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a24a:	bf00      	nop
    a24c:	b003      	add	sp, #12
    a24e:	f85d fb04 	ldr.w	pc, [sp], #4
    a252:	bf00      	nop
    a254:	1fff9048 	.word	0x1fff9048
    a258:	1fff9044 	.word	0x1fff9044

0000a25c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
    a25c:	b500      	push	{lr}
    a25e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a260:	f7f6 fca4 	bl	bac <Sys_GetCoreID>
    a264:	4603      	mov	r3, r0
    a266:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
    a268:	4a0d      	ldr	r2, [pc, #52]	; (a2a0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    a26a:	9b01      	ldr	r3, [sp, #4]
    a26c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a270:	1e5a      	subs	r2, r3, #1
    a272:	490b      	ldr	r1, [pc, #44]	; (a2a0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    a274:	9b01      	ldr	r3, [sp, #4]
    a276:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    a27a:	4a0a      	ldr	r2, [pc, #40]	; (a2a4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
    a27c:	9b01      	ldr	r3, [sp, #4]
    a27e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a282:	f003 0301 	and.w	r3, r3, #1
    a286:	2b00      	cmp	r3, #0
    a288:	d106      	bne.n	a298 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    a28a:	4a05      	ldr	r2, [pc, #20]	; (a2a0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
    a28c:	9b01      	ldr	r3, [sp, #4]
    a28e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a292:	2b00      	cmp	r3, #0
    a294:	d100      	bne.n	a298 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a296:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a298:	bf00      	nop
    a29a:	b003      	add	sp, #12
    a29c:	f85d fb04 	ldr.w	pc, [sp], #4
    a2a0:	1fff9048 	.word	0x1fff9048
    a2a4:	1fff9044 	.word	0x1fff9044

0000a2a8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    a2a8:	b500      	push	{lr}
    a2aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a2ac:	f7f6 fc7e 	bl	bac <Sys_GetCoreID>
    a2b0:	4603      	mov	r3, r0
    a2b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
    a2b4:	4a10      	ldr	r2, [pc, #64]	; (a2f8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    a2b6:	9b01      	ldr	r3, [sp, #4]
    a2b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2bc:	2b00      	cmp	r3, #0
    a2be:	d10d      	bne.n	a2dc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a2c0:	f7f6 fb9c 	bl	9fc <Mcu_schm_read_msr>
    a2c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a2c6:	9b00      	ldr	r3, [sp, #0]
    a2c8:	f003 0301 	and.w	r3, r3, #1
    a2cc:	2b00      	cmp	r3, #0
    a2ce:	d100      	bne.n	a2d2 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a2d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    a2d2:	490a      	ldr	r1, [pc, #40]	; (a2fc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
    a2d4:	9b01      	ldr	r3, [sp, #4]
    a2d6:	9a00      	ldr	r2, [sp, #0]
    a2d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
    a2dc:	4a06      	ldr	r2, [pc, #24]	; (a2f8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    a2de:	9b01      	ldr	r3, [sp, #4]
    a2e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2e4:	1c5a      	adds	r2, r3, #1
    a2e6:	4904      	ldr	r1, [pc, #16]	; (a2f8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
    a2e8:	9b01      	ldr	r3, [sp, #4]
    a2ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a2ee:	bf00      	nop
    a2f0:	b003      	add	sp, #12
    a2f2:	f85d fb04 	ldr.w	pc, [sp], #4
    a2f6:	bf00      	nop
    a2f8:	1fff9050 	.word	0x1fff9050
    a2fc:	1fff904c 	.word	0x1fff904c

0000a300 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
    a300:	b500      	push	{lr}
    a302:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a304:	f7f6 fc52 	bl	bac <Sys_GetCoreID>
    a308:	4603      	mov	r3, r0
    a30a:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
    a30c:	4a0d      	ldr	r2, [pc, #52]	; (a344 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    a30e:	9b01      	ldr	r3, [sp, #4]
    a310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a314:	1e5a      	subs	r2, r3, #1
    a316:	490b      	ldr	r1, [pc, #44]	; (a344 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    a318:	9b01      	ldr	r3, [sp, #4]
    a31a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    a31e:	4a0a      	ldr	r2, [pc, #40]	; (a348 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
    a320:	9b01      	ldr	r3, [sp, #4]
    a322:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a326:	f003 0301 	and.w	r3, r3, #1
    a32a:	2b00      	cmp	r3, #0
    a32c:	d106      	bne.n	a33c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    a32e:	4a05      	ldr	r2, [pc, #20]	; (a344 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
    a330:	9b01      	ldr	r3, [sp, #4]
    a332:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a336:	2b00      	cmp	r3, #0
    a338:	d100      	bne.n	a33c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a33a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a33c:	bf00      	nop
    a33e:	b003      	add	sp, #12
    a340:	f85d fb04 	ldr.w	pc, [sp], #4
    a344:	1fff9050 	.word	0x1fff9050
    a348:	1fff904c 	.word	0x1fff904c

0000a34c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00(void)
{
    a34c:	b500      	push	{lr}
    a34e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a350:	f7f6 fc2c 	bl	bac <Sys_GetCoreID>
    a354:	4603      	mov	r3, r0
    a356:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId])
    a358:	4a10      	ldr	r2, [pc, #64]	; (a39c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    a35a:	9b01      	ldr	r3, [sp, #4]
    a35c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a360:	2b00      	cmp	r3, #0
    a362:	d10d      	bne.n	a380 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Dio_schm_read_msr);
#else
        msr = Dio_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a364:	f7f6 fb53 	bl	a0e <Dio_schm_read_msr>
    a368:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a36a:	9b00      	ldr	r3, [sp, #0]
    a36c:	f003 0301 	and.w	r3, r3, #1
    a370:	2b00      	cmp	r3, #0
    a372:	d100      	bne.n	a376 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a374:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_DIO_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    a376:	490a      	ldr	r1, [pc, #40]	; (a3a0 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x54>)
    a378:	9b01      	ldr	r3, [sp, #4]
    a37a:	9a00      	ldr	r2, [sp, #0]
    a37c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]++;
    a380:	4a06      	ldr	r2, [pc, #24]	; (a39c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    a382:	9b01      	ldr	r3, [sp, #4]
    a384:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a388:	1c5a      	adds	r2, r3, #1
    a38a:	4904      	ldr	r1, [pc, #16]	; (a39c <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_00+0x50>)
    a38c:	9b01      	ldr	r3, [sp, #4]
    a38e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a392:	bf00      	nop
    a394:	b003      	add	sp, #12
    a396:	f85d fb04 	ldr.w	pc, [sp], #4
    a39a:	bf00      	nop
    a39c:	1fff9058 	.word	0x1fff9058
    a3a0:	1fff9054 	.word	0x1fff9054

0000a3a4 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00>:

void SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00(void)
{
    a3a4:	b500      	push	{lr}
    a3a6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a3a8:	f7f6 fc00 	bl	bac <Sys_GetCoreID>
    a3ac:	4603      	mov	r3, r0
    a3ae:	9301      	str	r3, [sp, #4]

    reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]--;
    a3b0:	4a0d      	ldr	r2, [pc, #52]	; (a3e8 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    a3b2:	9b01      	ldr	r3, [sp, #4]
    a3b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3b8:	1e5a      	subs	r2, r3, #1
    a3ba:	490b      	ldr	r1, [pc, #44]	; (a3e8 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    a3bc:	9b01      	ldr	r3, [sp, #4]
    a3be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_DIO_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    a3c2:	4a0a      	ldr	r2, [pc, #40]	; (a3ec <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x48>)
    a3c4:	9b01      	ldr	r3, [sp, #4]
    a3c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3ca:	f003 0301 	and.w	r3, r3, #1
    a3ce:	2b00      	cmp	r3, #0
    a3d0:	d106      	bne.n	a3e0 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x3c>
    a3d2:	4a05      	ldr	r2, [pc, #20]	; (a3e8 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x44>)
    a3d4:	9b01      	ldr	r3, [sp, #4]
    a3d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a3da:	2b00      	cmp	r3, #0
    a3dc:	d100      	bne.n	a3e0 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a3de:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a3e0:	bf00      	nop
    a3e2:	b003      	add	sp, #12
    a3e4:	f85d fb04 	ldr.w	pc, [sp], #4
    a3e8:	1fff9058 	.word	0x1fff9058
    a3ec:	1fff9054 	.word	0x1fff9054

0000a3f0 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01>:

void SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01(void)
{
    a3f0:	b500      	push	{lr}
    a3f2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a3f4:	f7f6 fbda 	bl	bac <Sys_GetCoreID>
    a3f8:	4603      	mov	r3, r0
    a3fa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId])
    a3fc:	4a10      	ldr	r2, [pc, #64]	; (a440 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    a3fe:	9b01      	ldr	r3, [sp, #4]
    a400:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a404:	2b00      	cmp	r3, #0
    a406:	d10d      	bne.n	a424 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Dio_schm_read_msr);
#else
        msr = Dio_schm_read_msr();  /*read MSR (to store interrupts state)*/
    a408:	f7f6 fb01 	bl	a0e <Dio_schm_read_msr>
    a40c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    a40e:	9b00      	ldr	r3, [sp, #0]
    a410:	f003 0301 	and.w	r3, r3, #1
    a414:	2b00      	cmp	r3, #0
    a416:	d100      	bne.n	a41a <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    a418:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_DIO_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    a41a:	490a      	ldr	r1, [pc, #40]	; (a444 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x54>)
    a41c:	9b01      	ldr	r3, [sp, #4]
    a41e:	9a00      	ldr	r2, [sp, #0]
    a420:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]++;
    a424:	4a06      	ldr	r2, [pc, #24]	; (a440 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    a426:	9b01      	ldr	r3, [sp, #4]
    a428:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a42c:	1c5a      	adds	r2, r3, #1
    a42e:	4904      	ldr	r1, [pc, #16]	; (a440 <SchM_Enter_Dio_DIO_EXCLUSIVE_AREA_01+0x50>)
    a430:	9b01      	ldr	r3, [sp, #4]
    a432:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    a436:	bf00      	nop
    a438:	b003      	add	sp, #12
    a43a:	f85d fb04 	ldr.w	pc, [sp], #4
    a43e:	bf00      	nop
    a440:	1fff9060 	.word	0x1fff9060
    a444:	1fff905c 	.word	0x1fff905c

0000a448 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01>:

void SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01(void)
{
    a448:	b500      	push	{lr}
    a44a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a44c:	f7f6 fbae 	bl	bac <Sys_GetCoreID>
    a450:	4603      	mov	r3, r0
    a452:	9301      	str	r3, [sp, #4]

    reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]--;
    a454:	4a0d      	ldr	r2, [pc, #52]	; (a48c <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    a456:	9b01      	ldr	r3, [sp, #4]
    a458:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a45c:	1e5a      	subs	r2, r3, #1
    a45e:	490b      	ldr	r1, [pc, #44]	; (a48c <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    a460:	9b01      	ldr	r3, [sp, #4]
    a462:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_DIO_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_DIO_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    a466:	4a0a      	ldr	r2, [pc, #40]	; (a490 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x48>)
    a468:	9b01      	ldr	r3, [sp, #4]
    a46a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a46e:	f003 0301 	and.w	r3, r3, #1
    a472:	2b00      	cmp	r3, #0
    a474:	d106      	bne.n	a484 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x3c>
    a476:	4a05      	ldr	r2, [pc, #20]	; (a48c <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x44>)
    a478:	9b01      	ldr	r3, [sp, #4]
    a47a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a47e:	2b00      	cmp	r3, #0
    a480:	d100      	bne.n	a484 <SchM_Exit_Dio_DIO_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    a482:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    a484:	bf00      	nop
    a486:	b003      	add	sp, #12
    a488:	f85d fb04 	ldr.w	pc, [sp], #4
    a48c:	1fff9060 	.word	0x1fff9060
    a490:	1fff905c 	.word	0x1fff905c

0000a494 <Det_Init>:
*
*/
void Det_Init(void)
{
    /* Do nothing */
}
    a494:	bf00      	nop
    a496:	4770      	bx	lr

0000a498 <Det_ReportError>:
*/
Std_ReturnType Det_ReportError(uint16 ModuleId,
                               uint8 InstanceId,
                               uint8 ApiId,
                               uint8 ErrorId)
{
    a498:	b510      	push	{r4, lr}
    a49a:	b084      	sub	sp, #16
    a49c:	4604      	mov	r4, r0
    a49e:	4608      	mov	r0, r1
    a4a0:	4611      	mov	r1, r2
    a4a2:	461a      	mov	r2, r3
    a4a4:	4623      	mov	r3, r4
    a4a6:	f8ad 3006 	strh.w	r3, [sp, #6]
    a4aa:	4603      	mov	r3, r0
    a4ac:	f88d 3005 	strb.w	r3, [sp, #5]
    a4b0:	460b      	mov	r3, r1
    a4b2:	f88d 3004 	strb.w	r3, [sp, #4]
    a4b6:	4613      	mov	r3, r2
    a4b8:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a4bc:	f7f6 fb76 	bl	bac <Sys_GetCoreID>
    a4c0:	4603      	mov	r3, r0
    a4c2:	9303      	str	r3, [sp, #12]

    Det_ModuleId[u32CoreId] = ModuleId;
    a4c4:	490d      	ldr	r1, [pc, #52]	; (a4fc <Det_ReportError+0x64>)
    a4c6:	9b03      	ldr	r3, [sp, #12]
    a4c8:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    a4cc:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_InstanceId[u32CoreId] = InstanceId;
    a4d0:	4a0b      	ldr	r2, [pc, #44]	; (a500 <Det_ReportError+0x68>)
    a4d2:	9b03      	ldr	r3, [sp, #12]
    a4d4:	4413      	add	r3, r2
    a4d6:	f89d 2005 	ldrb.w	r2, [sp, #5]
    a4da:	701a      	strb	r2, [r3, #0]
    Det_ApiId[u32CoreId] = ApiId;
    a4dc:	4a09      	ldr	r2, [pc, #36]	; (a504 <Det_ReportError+0x6c>)
    a4de:	9b03      	ldr	r3, [sp, #12]
    a4e0:	4413      	add	r3, r2
    a4e2:	f89d 2004 	ldrb.w	r2, [sp, #4]
    a4e6:	701a      	strb	r2, [r3, #0]
    Det_ErrorId[u32CoreId] = ErrorId;
    a4e8:	4a07      	ldr	r2, [pc, #28]	; (a508 <Det_ReportError+0x70>)
    a4ea:	9b03      	ldr	r3, [sp, #12]
    a4ec:	4413      	add	r3, r2
    a4ee:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a4f2:	701a      	strb	r2, [r3, #0]

    return E_OK;
    a4f4:	2300      	movs	r3, #0
}
    a4f6:	4618      	mov	r0, r3
    a4f8:	b004      	add	sp, #16
    a4fa:	bd10      	pop	{r4, pc}
    a4fc:	1fff908c 	.word	0x1fff908c
    a500:	1fff9064 	.word	0x1fff9064
    a504:	1fff9068 	.word	0x1fff9068
    a508:	1fff906c 	.word	0x1fff906c

0000a50c <Det_ReportRuntimeError>:
*/
Std_ReturnType Det_ReportRuntimeError(uint16 ModuleId,
                                      uint8 InstanceId,
                                      uint8 ApiId,
                                      uint8 ErrorId)
{
    a50c:	b510      	push	{r4, lr}
    a50e:	b084      	sub	sp, #16
    a510:	4604      	mov	r4, r0
    a512:	4608      	mov	r0, r1
    a514:	4611      	mov	r1, r2
    a516:	461a      	mov	r2, r3
    a518:	4623      	mov	r3, r4
    a51a:	f8ad 3006 	strh.w	r3, [sp, #6]
    a51e:	4603      	mov	r3, r0
    a520:	f88d 3005 	strb.w	r3, [sp, #5]
    a524:	460b      	mov	r3, r1
    a526:	f88d 3004 	strb.w	r3, [sp, #4]
    a52a:	4613      	mov	r3, r2
    a52c:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a530:	f7f6 fb3c 	bl	bac <Sys_GetCoreID>
    a534:	4603      	mov	r3, r0
    a536:	9303      	str	r3, [sp, #12]

    Det_RuntimeModuleId[u32CoreId] = ModuleId;
    a538:	490d      	ldr	r1, [pc, #52]	; (a570 <Det_ReportRuntimeError+0x64>)
    a53a:	9b03      	ldr	r3, [sp, #12]
    a53c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    a540:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_RuntimeInstanceId[u32CoreId] = InstanceId;
    a544:	4a0b      	ldr	r2, [pc, #44]	; (a574 <Det_ReportRuntimeError+0x68>)
    a546:	9b03      	ldr	r3, [sp, #12]
    a548:	4413      	add	r3, r2
    a54a:	f89d 2005 	ldrb.w	r2, [sp, #5]
    a54e:	701a      	strb	r2, [r3, #0]
    Det_RuntimeApiId[u32CoreId] = ApiId;
    a550:	4a09      	ldr	r2, [pc, #36]	; (a578 <Det_ReportRuntimeError+0x6c>)
    a552:	9b03      	ldr	r3, [sp, #12]
    a554:	4413      	add	r3, r2
    a556:	f89d 2004 	ldrb.w	r2, [sp, #4]
    a55a:	701a      	strb	r2, [r3, #0]
    Det_RuntimeErrorId[u32CoreId] = ErrorId;
    a55c:	4a07      	ldr	r2, [pc, #28]	; (a57c <Det_ReportRuntimeError+0x70>)
    a55e:	9b03      	ldr	r3, [sp, #12]
    a560:	4413      	add	r3, r2
    a562:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a566:	701a      	strb	r2, [r3, #0]

    return E_OK;
    a568:	2300      	movs	r3, #0
}
    a56a:	4618      	mov	r0, r3
    a56c:	b004      	add	sp, #16
    a56e:	bd10      	pop	{r4, pc}
    a570:	1fff9090 	.word	0x1fff9090
    a574:	1fff9070 	.word	0x1fff9070
    a578:	1fff9074 	.word	0x1fff9074
    a57c:	1fff9078 	.word	0x1fff9078

0000a580 <Det_ReportTransientFault>:
*/
Std_ReturnType Det_ReportTransientFault(uint16 ModuleId,
                                        uint8 InstanceId,
                                        uint8 ApiId,
                                        uint8 FaultId)
{
    a580:	b510      	push	{r4, lr}
    a582:	b084      	sub	sp, #16
    a584:	4604      	mov	r4, r0
    a586:	4608      	mov	r0, r1
    a588:	4611      	mov	r1, r2
    a58a:	461a      	mov	r2, r3
    a58c:	4623      	mov	r3, r4
    a58e:	f8ad 3006 	strh.w	r3, [sp, #6]
    a592:	4603      	mov	r3, r0
    a594:	f88d 3005 	strb.w	r3, [sp, #5]
    a598:	460b      	mov	r3, r1
    a59a:	f88d 3004 	strb.w	r3, [sp, #4]
    a59e:	4613      	mov	r3, r2
    a5a0:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    a5a4:	f7f6 fb02 	bl	bac <Sys_GetCoreID>
    a5a8:	4603      	mov	r3, r0
    a5aa:	9303      	str	r3, [sp, #12]

    Det_TransientModuleId[u32CoreId] = ModuleId;
    a5ac:	490d      	ldr	r1, [pc, #52]	; (a5e4 <Det_ReportTransientFault+0x64>)
    a5ae:	9b03      	ldr	r3, [sp, #12]
    a5b0:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    a5b4:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_TransientInstanceId[u32CoreId] = InstanceId;
    a5b8:	4a0b      	ldr	r2, [pc, #44]	; (a5e8 <Det_ReportTransientFault+0x68>)
    a5ba:	9b03      	ldr	r3, [sp, #12]
    a5bc:	4413      	add	r3, r2
    a5be:	f89d 2005 	ldrb.w	r2, [sp, #5]
    a5c2:	701a      	strb	r2, [r3, #0]
    Det_TransientApiId[u32CoreId] = ApiId;
    a5c4:	4a09      	ldr	r2, [pc, #36]	; (a5ec <Det_ReportTransientFault+0x6c>)
    a5c6:	9b03      	ldr	r3, [sp, #12]
    a5c8:	4413      	add	r3, r2
    a5ca:	f89d 2004 	ldrb.w	r2, [sp, #4]
    a5ce:	701a      	strb	r2, [r3, #0]
    Det_TransientFaultId[u32CoreId] = FaultId;
    a5d0:	4a07      	ldr	r2, [pc, #28]	; (a5f0 <Det_ReportTransientFault+0x70>)
    a5d2:	9b03      	ldr	r3, [sp, #12]
    a5d4:	4413      	add	r3, r2
    a5d6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a5da:	701a      	strb	r2, [r3, #0]

    return E_OK;
    a5dc:	2300      	movs	r3, #0
}
    a5de:	4618      	mov	r0, r3
    a5e0:	b004      	add	sp, #16
    a5e2:	bd10      	pop	{r4, pc}
    a5e4:	1fff9088 	.word	0x1fff9088
    a5e8:	1fff907c 	.word	0x1fff907c
    a5ec:	1fff9080 	.word	0x1fff9080
    a5f0:	1fff9084 	.word	0x1fff9084

0000a5f4 <Det_Start>:
* @requirement DET010
*/
void Det_Start(void)
{
    /* Do nothing */
}
    a5f4:	bf00      	nop
    a5f6:	4770      	bx	lr

0000a5f8 <Clock_Ip_axSelectorCallbacks>:
    a5f8:	0e4d 0000 0e4d 0000 0e57 0000 0e71 0000     M...M...W...q...
    a608:	0e4d 0000 0e8b 0000 0ea5 0000 0ebf 0000     M...............
    a618:	0ed9 0000 0ef3 0000 0f0d 0000 0f27 0000     ............'...
    a628:	0f41 0000 0f5b 0000 0f75 0000 0f8f 0000     A...[...u.......
    a638:	0fa9 0000 0fc3 0000 0fdd 0000 0ff7 0000     ................
    a648:	1011 0000 102b 0000                         ....+...

0000a650 <Clock_Ip_au8DividerCallbackIndex>:
    a650:	0c00 0e0d 0201 0603 0409 0a07 0805 000b     ................

0000a660 <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

0000a670 <Clock_Ip_au8XoscCallbackIndex>:
    a670:	0100 0000 0000 0000 0000 0000 0000 0000     ................

0000a680 <Clock_Ip_au8IrcoscCallbackIndex>:
    a680:	0100 0302 0004 0000 0000 0000 0000 0000     ................

0000a690 <Clock_Ip_au8GateCallbackIndex>:
    a690:	0200 0601 0301 0104 0500 0000 0000 0000     ................

0000a6a0 <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

0000a6b0 <Clock_Ip_au8PllCallbackIndex>:
    a6b0:	0100 0000 0000 0000 0000 0000 0000 0000     ................

0000a6c0 <Clock_Ip_au8SelectorCallbackIndex>:
    a6c0:	0800 0a09 0109 0302 0504 0706 0000 0000     ................

0000a6d0 <Clock_Ip_au8PcfsCallbackIndex>:
	...

0000a6e0 <Clock_Ip_au8CmuCallbackIndex>:
	...

0000a6f0 <Clock_Ip_au8ClockFeatures>:
	...
    a700:	0000 0100 0000 0000 0000 0000 0002 0000     ................
    a710:	0000 0000 0300 0000 0000 0000 0000 0004     ................
    a720:	0000 0000 0000 0500 0000 0000 0000 0000     ................
    a730:	0006 0000 0000 0000 0100 0000 0000 0000     ................
    a740:	0000 0001 0000 0000 0000 0400 0000 0000     ................
    a750:	0000 0000 0005 0000 0001 0000 0401 0000     ................
    a760:	0200 0000 0100 0005 0000 0003 0000 0402     ................
    a770:	0000 0400 0000 0200 0005 0000 0005 0000     ................
    a780:	0403 0000 0600 0000 0300 0005 0000 0007     ................
    a790:	0000 0500 0000 0000 0000 0000 0006 0000     ................
	...
    a7d0:	0000 0005 0000 0000 0000 0600 0100 0000     ................
    a7e0:	0000 0000 0007 0003 0000 0000 0000 0000     ................
    a7f0:	0000 0000 0000 0006 0000 0000 0000 0700     ................
    a800:	0100 0000 0000 0000 0008 0003 0000 0000     ................
	...
    a818:	0000 0009 0000 0000 0000 0a00 0100 0000     ................
    a828:	0000 0000 000b 0003 0000 0000 0000 0000     ................
    a838:	0000 0000 0000 000c 0000 0000 0000 0d00     ................
    a848:	0100 0000 0000 0000 000e 0003 0000 0000     ................
    a858:	0800 0000 0000 0000 0000 0009 0000 0000     ................
    a868:	0000 0a00 0000 0000 0000 0000 000b 0000     ................
    a878:	0000 0000 0b01 0000 0000 0000 0200 000b     ................
    a888:	0000 0000 0000 0b03 0000 0000 0000 0000     ................
	...
    a8a0:	0400 0000 003b 003b 0000 0004 2700 2700     ....;.;......'.'
    a8b0:	0000 0100 0000 0000 0000 0000 0007 0000     ................
    a8c0:	7300 0000 0700 0000 0000 0032 0000 0009     .s........2.....
    a8d0:	0000 0200 0000 0700 0000 0000 0021 0000     ............!...
    a8e0:	0009 0000 0400 0000 0900 0000 0000 0003     ................
    a8f0:	0000 0007 0000 6100 0000 0700 0000 0000     .......a........
    a900:	0024 0000 0007 0000 2500 0000 0700 0000     $........%......
    a910:	0000 002b 0000 0004 5a00 5a00 0000 0700     ..+......Z.Z....
    a920:	0000 0000 0020 0000 0004 3800 3800 0000     .... ......8.8..
    a930:	0400 0000 0039 0039 0000 0004 3a00 3a00     ....9.9......:.:
    a940:	0000 0400 0000 0026 0026 0000 0004 6600     ......&.&......f
    a950:	6600 0000 0400 0000 0037 0037 0000 0004     .f......7.7.....
    a960:	2c00 2c00 0000 0400 0000 002d 002d 0000     .,.,......-.-...
    a970:	0004 2e00 2e00 0000 0200 0000 4040 0040     ............@@@.
    a980:	0000 0004 6a00 6a00 0000 0400 0000 006b     .....j.j......k.
    a990:	006b 0000 0004 6c00 6c00 0000 0900 0000     k......l.l......
    a9a0:	0000 0001 0000 0009 0000 0000 0000 0700     ................
    a9b0:	0000 0000 0036 0000 0007 0000 3100 0000     ....6........1..
    a9c0:	0700 0000 0000 0049 0000 0007 0000 4a00     ......I........J
    a9d0:	0000 0700 0000 0000 004b 0000 0007 0000     ........K.......
    a9e0:	4c00 0000 0700 0000 0000 004d 0000 0007     .L........M.....
    a9f0:	0000 3d00 0000 0300 0000 0000 0000 0000     ...=............

0000aa00 <Clock_Ip_au16SelectorEntryHardwareValue>:
    aa00:	0a03 0101 0001 0101 0002 0404 0603 0200     ................
    aa10:	0810 0001 0100 0202 0000 0000 0007 0000     ................
    aa20:	0009 0000 0000 0000 0c0e 0000 0000 0000     ................
	...

0000aa58 <Clock_Ip_au8SelectorEntryScsHardwareValue>:
    aa58:	0000 0002 0300 0000 0601 0000 0000 0000     ................
	...

0000aa88 <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
    aa88:	0700 0000 0000 0000 0000 0202 0303 0101     ................
    aa98:	0606 0302 0000 0000 0000 0000 0000 0000     ................
	...

0000aab8 <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
    aab8:	0001 0000 0000 0000 0000 0202 0303 0101     ................
    aac8:	0606 0302 0000 0000 0000 0000 0000 0000     ................
	...

0000aae8 <Clock_Ip_au8DividerValueHardwareValue>:
    aae8:	0100 0002 0003 0000 0004 0000 0000 0000     ................
    aaf8:	0005 0000 0000 0000 0000 0000 0000 0000     ................
    ab08:	0006 0000 0000 0000 0000 0000 0000 0000     ................
	...
    ab28:	0007 0000                                   ....

0000ab2c <Clock_Ip_apxScgPeriphAsyncDivs>:
    ab2c:	4204 4006 4304 4006 4104 4006 4604 4006     .B.@.C.@.A.@.F.@

0000ab3c <Clock_Ip_aeSourceTypeClockName>:
    ab3c:	0000 0000 0001 0000 0001 0000 0001 0000     ................
    ab4c:	0001 0000 0001 0000 0001 0000 0001 0000     ................
    ab5c:	0002 0000 0003 0000 0001 0000 0001 0000     ................
    ab6c:	0001 0000 0001 0000 0002 0000 0002 0000     ................
    ab7c:	0003 0000 0003 0000 0001 0000 0001 0000     ................
    ab8c:	0004 0000 0004 0000 0004 0000 0004 0000     ................
	...

0000abf8 <Clock_Ip_aeHwPllName>:
    abf8:	0009 0000                                   ....

0000abfc <Clock_Ip_aeHwDfsName>:
    abfc:	0057 0000                                   W...

0000ac00 <ClockSource>:
    ac00:	0000 0000 0008 0000 0002 0000 0005 0000     ................
	...
    ac18:	0009 0000                                   ....

0000ac1c <ResetReasonArray>:
    ac1c:	0000 0000 0001 0000 0002 0000 0003 0000     ................
    ac2c:	0004 0000 0005 0000 0006 0000 0007 0000     ................
    ac3c:	0008 0000 0009 0000 000a 0000 000b 0000     ................
    ac4c:	000c 0000 000d 0000 000e 0000               ............

0000ac58 <Clock_Ip_axExtOscCallbacks>:
    ac58:	24b5 0000 24b5 0000 24b5 0000 24bf 0000     .$...$...$...$..
    ac68:	24b5 0000 24c9 0000 24e3 0000 24fd 0000     .$...$...$...$..
    ac78:	2581 0000 2595 0000                         .%...%..

0000ac80 <Clock_Ip_axGateCallbacks>:
    ac80:	3881 0000 388b 0000 398b 0000 39a5 0000     .8...8...9...9..
    ac90:	393b 0000 3955 0000 38eb 0000 3905 0000     ;9..U9...8...9..
    aca0:	389b 0000 38b5 0000 39db 0000 39f5 0000     .8...8...9...9..
    acb0:	3a2b 0000 3a45 0000                         +:..E:..

0000acb8 <Clock_Ip_axFracDivCallbacks>:
    acb8:	3c91 0000 3c91 0000 3c9b 0000               .<...<...<..

0000acc4 <Clock_Ip_axDividerTriggerCallbacks>:
    acc4:	3ca7 0000 3ca7 0000                         .<...<..

0000accc <Clock_Ip_axIntOscCallbacks>:
    accc:	3cb1 0000 3cb1 0000 3cbb 0000 3cc5 0000     .<...<...<...<..
    acdc:	3cdf 0000 3cf9 0000 3d0d 0000 3d27 0000     .<...<...=..'=..
    acec:	3d41 0000 3d55 0000 3d6f 0000 3d89 0000     A=..U=..o=...=..
    acfc:	3e31 0000 3e4b 0000 3e65 0000               1>..K>..e>..

0000ad08 <Clock_Ip_axCmuCallbacks>:
    ad08:	448d 0000 4497 0000 44a3 0000 448d 0000     .D...D...D...D..

0000ad18 <Clock_Ip_axDividerCallbacks>:
    ad18:	4521 0000 452b 0000 4545 0000 455f 0000     !E..+E..EE.._E..
    ad28:	4579 0000 4593 0000 45ad 0000 45c7 0000     yE...E...E...E..
    ad38:	45e1 0000 45fb 0000 4615 0000 462f 0000     .E...E...F../F..
    ad48:	4649 0000 4663 0000 467d 0000               IF..cF..}F..

0000ad54 <Clock_Ip_axPcfsCallbacks>:
    ad54:	4cb9 0000                                   .L..

0000ad58 <Clock_Ip_axPllCallbacks>:
    ad58:	4cc5 0000 4cc5 0000 4ccf 0000 4cc5 0000     .L...L...L...L..
    ad68:	4cdb 0000 4ce5 0000 4cff 0000 4d19 0000     .L...L...L...M..
    ad78:	4dbd 0000 4da9 0000                         .M...M..

0000ad80 <Port_au32PortCiPortBaseAddr>:
    ad80:	9000 4004 a000 4004 b000 4004 c000 4004     ...@...@...@...@
    ad90:	d000 4004                                   ...@

0000ad94 <Port_au32PortCiGpioBaseAddr>:
    ad94:	f000 400f f040 400f f080 400f f0c0 400f     ...@@..@...@...@
    ada4:	f100 400f                                   ...@

0000ada8 <ftmGptBase>:
    ada8:	8000 4003 9000 4003 a000 4003 6000 4002     ...@...@...@.`.@

0000adb8 <Mcu_aClockConfigPB>:
	...
    adc0:	0101 1c00 0010 0400 0029 0100 0005 0000     ........).......
    add0:	0001 0000 0000 0000 0057 0000 0000 0000     ........W.......
    ade0:	0000 0000 0008 0000 1200 007a 0001 0000     ..........z.....
    adf0:	0001 0000 0000 0000 0057 0000 0000 0000     ........W.......
    ae00:	0057 0000 0000 0000 0000 0000 0000 0000     W...............
	...
    ae20:	0019 0000 0005 0000 001a 0000 0002 0000     ................
    ae30:	001b 0000 0005 0000 002a 0000 0005 0000     ........*.......
    ae40:	0028 0000 000e 0000 0029 0000 0001 0000     (.......).......
    ae50:	0056 0000 001c 0000 0032 0000 002a 0000     V.......2...*...
    ae60:	002b 0000 0014 0000 002c 0000 0014 0000     +.......,.......
    ae70:	002d 0000 0014 0000 002e 0000 0014 0000     -...............
    ae80:	003f 0000 0000 0000 0040 0000 0000 0000     ?.......@.......
    ae90:	0041 0000 0000 0000 0042 0000 0000 0000     A.......B.......
    aea0:	0031 0000 0000 0000 0045 0000 0000 0000     1.......E.......
    aeb0:	0046 0000 0000 0000 0047 0000 0000 0000     F.......G.......
    aec0:	0044 0000 0000 0000 0030 0000 0000 0000     D.......0.......
    aed0:	003d 0000 0000 0000 0043 0000 0000 0000     =.......C.......
    aee0:	0049 0000 0000 0000 004a 0000 0000 0000     I.......J.......
    aef0:	004b 0000 0000 0000 0048 0000 0000 0000     K.......H.......
    af00:	000c 0000 0001 0000 0000 0000 000d 0000     ................
    af10:	0002 0000 0000 0000 000e 0000 0001 0000     ................
    af20:	0000 0000 000f 0000 0001 0000 0000 0000     ................
    af30:	001d 0000 0001 0000 0000 0000 001e 0000     ................
    af40:	0008 0000 0000 0000 001f 0000 0001 0000     ................
    af50:	0000 0000 0021 0000 0001 0000 0000 0000     ....!...........
    af60:	0022 0000 0002 0000 0000 0000 0023 0000     "...........#...
    af70:	0001 0000 0000 0000 0025 0000 0003 0000     ........%.......
    af80:	0000 0000 0026 0000 0004 0000 0000 0000     ....&...........
    af90:	0027 0000 0002 0000 0000 0000 0032 0000     '...........2...
    afa0:	0001 0000 0000 0000 0048 0000 0001 0000     ........H.......
    afb0:	0001 0000 0056 0000 0001 0000 0001 0000     ....V...........
    afc0:	0057 0000 0000 0000 0000 0000 0057 0000     W...........W...
	...
    afd8:	0057 0000 0000 0000 0000 0000 0057 0000     W...........W...
	...
    aff0:	0057 0000 0000 0000 0057 0000 0057 0000     W.......W...W...
	...
    b00c:	0014 0000 7d00 0000 0015 0000 7d00 0000     .....}.......}..
    b01c:	0016 0000 7d00 0000 0017 0000 8000 0000     .....}..........
    b02c:	0012 0000 0001 0000 0013 0000 0001 0000     ................
    b03c:	0030 0000 0000 0000 0031 0000 0000 0000     0.......1.......
    b04c:	0032 0000 0000 0000 0033 0000 0000 0000     2.......3.......
    b05c:	0034 0000 0000 0000 0035 0000 0001 0000     4.......5.......
    b06c:	0036 0000 0000 0000 0037 0000 0001 0000     6.......7.......
    b07c:	0038 0000 0001 0000 0039 0000 0000 0000     8.......9.......
    b08c:	003a 0000 0000 0000 003b 0000 0000 0000     :.......;.......
    b09c:	003c 0000 0000 0000 003d 0000 0000 0000     <.......=.......
    b0ac:	003e 0000 0000 0000 003f 0000 0001 0000     >.......?.......
    b0bc:	0040 0000 0000 0000 0041 0000 0000 0000     @.......A.......
    b0cc:	0042 0000 0000 0000 0043 0000 0000 0000     B.......C.......
    b0dc:	0044 0000 0000 0000 0045 0000 0000 0000     D.......E.......
    b0ec:	0046 0000 0000 0000 0047 0000 0000 0000     F.......G.......
    b0fc:	0048 0000 0000 0000 0049 0000 0000 0000     H.......I.......
    b10c:	004a 0000 0000 0000 004b 0000 0000 0000     J.......K.......
    b11c:	004c 0000 0001 0000 004d 0000 0001 0000     L.......M.......
    b12c:	004e 0000 0000 0000 004f 0000 0000 0000     N.......O.......
    b13c:	0050 0000 0001 0000 0051 0000 0001 0000     P.......Q.......
    b14c:	0052 0000 0001 0000 0053 0000 0001 0000     R.......S.......
    b15c:	0054 0000 0001 0000 0055 0000 0000 0000     T.......U.......
    b16c:	0056 0000 0001 0000 0057 0000 0000 0000     V.......W.......
    b17c:	0000 0000 0057 0000 0000 0000 0057 0000     ....W.......W...
	...

0000b1b0 <u8GptChannelIdToIndexMap>:
    b1b0:	0000 0000                                   ....

0000b1b4 <Gpt_InitChannelPB>:
	...
    b1bc:	ffff 0000 0001 0000 8b48 1fff               ........H...

0000b1c8 <Gpt_Config>:
    b1c8:	0001 0000 b1b4 0000 0001 0000 8b38 1fff     ............8...
    b1d8:	b1b0 0000                                   ....

0000b1dc <Mcu_Config>:
    b1dc:	005a 0000 0000 0000 0001 0000 0001 0000     Z...............
    b1ec:	b350 0000 adb8 0000 b35c 0000               P.......\...

0000b1f8 <g_pin_mux_InitConfigArr>:
    b1f8:	c000 4004 f0c0 400f 0000 0000 0002 0000     ...@...@........
    b208:	0001 0000 0002 0000 0000 0000 0000 0000     ................
	...

0000b220 <au8Port_PartitionList>:
    b220:	0001 0000                                   ....

0000b224 <au32Port_PinToPartitionMap>:
    b224:	0001 0000                                   ....

0000b228 <Port_au16NoUnUsedPadsArrayDefault>:
    b228:	0000 0001 0002 0003 0006 0007 0008 0009     ................
    b238:	000b 000c 000d 000e 000f 0010 0011 0020     .............. .
    b248:	0021 0022 0023 0024 0025 0026 0027 0028     !.".#.$.%.&.'.(.
    b258:	0029 002a 002b 002c 002d 002e 002f 0030     ).*.+.,.-.../.0.
    b268:	0031 0040 0041 0042 0043 0046 0047 0048     1.@.A.B.C.F.G.H.
    b278:	0049 004a 004b 004c 004d 004e 004f 0050     I.J.K.L.M.N.O.P.
    b288:	0051 0061 0062 0063 0064 0065 0066 0067     Q.a.b.c.d.e.f.g.
    b298:	0068 0069 006a 006b 006c 006d 006e 006f     h.i.j.k.l.m.n.o.
    b2a8:	0070 0071 0080 0081 0082 0083 0084 0085     p.q.............
    b2b8:	0086 0087 0088 0089 008a 008b 008c 008d     ................
    b2c8:	008e 008f 0090 0000                         ........

0000b2d0 <Port_UnUsedPin>:
    b2d0:	0100 0000 0001 0000 0000 0000               ............

0000b2dc <Port_aPinConfigDefault>:
    b2dc:	0060 0000 0100 0000 0000 0000 0002 0000     `...............
    b2ec:	0001 0001                                   ....

0000b2f0 <Port_Config>:
    b2f0:	0001 0053 b228 0000 b2d0 0000 b2dc 0000     ..S.(...........
	...
    b308:	b224 0000 b220 0000 b1f8 0000               $... .......

0000b314 <FTM_0_InitConfig_PB>:
    b314:	0000 0000 0001 0000 0007 0000 0001 0000     ................

0000b324 <FTM_0_ChannelConfig_PB>:
    b324:	0000 0000 64a1 0000 0000 0000 0001 0000     .....d..........

0000b334 <OsIf_xPredefinedConfig>:
    b334:	0000 0000 6c00 02dc                         .....l..

0000b33c <OsIf_apxPredefinedConfig>:
    b33c:	b334 0000                                   4...

0000b340 <Power_Ip_RCM_ConfigPB>:
	...

0000b348 <Power_Ip_PMC_ConfigPB>:
    b348:	0000 0000                                   ....

0000b34c <Power_Ip_SMC_ConfigPB>:
    b34c:	0000 0000                                   ....

0000b350 <Power_Ip_aModeConfigPB>:
	...

0000b35c <Power_Ip_HwIPsConfigPB>:
    b35c:	b340 0000 b348 0000 b34c 0000               @...H...L...

0000b368 <__INIT_TABLE>:
    b368:	00000002 	.word	0x00000002
    b36c:	1fff8b10 	.word	0x1fff8b10
    b370:	0000b390 	.word	0x0000b390
    b374:	0000b3e0 	.word	0x0000b3e0
    b378:	1fff8800 	.word	0x1fff8800
    b37c:	00000000 	.word	0x00000000
    b380:	00000310 	.word	0x00000310

0000b384 <__ZERO_TABLE>:
    b384:	00000001 	.word	0x00000001
    b388:	1fff8b60 	.word	0x1fff8b60
    b38c:	1fff90a0 	.word	0x1fff90a0
